// generatedy by JSX compiler 0.9.56 (2013-07-17 21:18:01 -0700; 6acc52a3f509ed30c9e04715405d1181adc00070)
var JSX = {};
(function (JSX) {
/**
 * extends the class
 */
function $__jsx_extend(derivations, base) {
	var ctor = function () {};
	ctor.prototype = base.prototype;
	var proto = new ctor();
	for (var i in derivations) {
		derivations[i].prototype = proto;
	}
}

/**
 * copies the implementations from source interface to target
 */
function $__jsx_merge_interface(target, source) {
	for (var k in source.prototype)
		if (source.prototype.hasOwnProperty(k))
			target.prototype[k] = source.prototype[k];
}

/**
 * defers the initialization of the property
 */
function $__jsx_lazy_init(obj, prop, func) {
	function reset(obj, prop, value) {
		delete obj[prop];
		obj[prop] = value;
		return value;
	}

	Object.defineProperty(obj, prop, {
		get: function () {
			return reset(obj, prop, func());
		},
		set: function (v) {
			reset(obj, prop, v);
		},
		enumerable: true,
		configurable: true
	});
}

/**
 * sideeffect().a /= b
 */
function $__jsx_div_assign(obj, prop, divisor) {
	return obj[prop] = (obj[prop] / divisor) | 0;
}

/*
 * global functions, renamed to avoid conflict with local variable names
 */
var $__jsx_parseInt = parseInt;
var $__jsx_parseFloat = parseFloat;
function $__jsx_isNaN(n) { return n !== n; }
var $__jsx_isFinite = isFinite;

var $__jsx_encodeURIComponent = encodeURIComponent;
var $__jsx_decodeURIComponent = decodeURIComponent;
var $__jsx_encodeURI = encodeURI;
var $__jsx_decodeURI = decodeURI;

var $__jsx_ObjectToString = Object.prototype.toString;
var $__jsx_ObjectHasOwnProperty = Object.prototype.hasOwnProperty;

/*
 * profiler object, initialized afterwards
 */
function $__jsx_profiler() {
}

/*
 * public interface to JSX code
 */
JSX.require = function (path) {
	var m = $__jsx_classMap[path];
	return m !== undefined ? m : null;
};

JSX.profilerIsRunning = function () {
	return $__jsx_profiler.getResults != null;
};

JSX.getProfileResults = function () {
	return ($__jsx_profiler.getResults || function () { return {}; })();
};

JSX.postProfileResults = function (url, cb) {
	if ($__jsx_profiler.postResults == null)
		throw new Error("profiler has not been turned on");
	return $__jsx_profiler.postResults(url, cb);
};

JSX.resetProfileResults = function () {
	if ($__jsx_profiler.resetResults == null)
		throw new Error("profiler has not been turned on");
	return $__jsx_profiler.resetResults();
};
JSX.DEBUG = false;
function g_StopIteration() {
	Error.call(this);
};

$__jsx_extend([g_StopIteration], Error);
function ScriptLoader() {
};

$__jsx_extend([ScriptLoader], Object);
function ScriptLoader$load$() {
	var scripts;
	var i;
	var l;
	var script;
	var id;
	scripts = dom.document.getElementsByTagName("script");
	for ((i = 0, l = scripts.length); i < l; ++ i) {
		script = scripts[i];
		if (script.type === "application/jsx") {
			id = (script.src ? script.src : script.innerHTML);
			if ($__jsx_ObjectHasOwnProperty.call(ScriptLoader.seen, id)) {
				continue;
			}
			ScriptLoader.seen[id] = true;
			ScriptLoader$loadScript$LHTMLScriptElement$(script);
		}
	}
};

ScriptLoader.load$ = ScriptLoader$load$;

function ScriptLoader$loadScript$LHTMLScriptElement$(script) {
	var t0;
	var platform;
	var c;
	var o;
	var emitter;
	var sourceFile;
	var optimizeCommands;
	var output;
	var compiledScript;
	var scriptSection;
	var applicationArguments;
	var args;
	var array;
	var i;
	var jsxModule;
	var jsxRequire;
	var jsxRuntime;
	var jsxMain;
	var content$0;
	var array$len$0;
	t0 = Date.now();
	platform = new BrowserPlatform();
	c = new Compiler(platform);
	o = ({_compiler: null, _commands: [], _log: "", _dumpLogs: false, _enableRunTimeTypeCheck: true});
	emitter = new JavaScriptEmitter(platform);
	c._emitter = emitter;
	if (script.src) {
		sourceFile = script.src.replace(/^.*\//, "");
	} else {
		sourceFile = "<script>";
		content$0 = script.innerHTML;
		platform.fileContent["<script>"] = content$0;
	}
	Compiler$addSourceFile$LCompiler$LToken$S(c, null, sourceFile);
	if (ScriptLoader.optimizationLevel > 0) {
		optimizeCommands = [ "lto", "no-assert", "no-log", "no-debug", "fold-const", "return-if", "inline", "dce", "unbox", "fold-const", "lcse", "dce", "fold-const", "array-length", "unclassify", "staticize" ].filter((function (command) {
			return command !== "no-log";
		}));
		Optimizer$setup$LOptimizer$AS(o, optimizeCommands);
		o._enableRunTimeTypeCheck = false;
		emitter._enableRunTimeTypeCheck = false;
	}
	c._optimizer = o;
	if (! Compiler$compile$LCompiler$(c)) {
		throw new Error("Failed to compile!");
	}
	output = emitter.getOutput$();
	if (ScriptLoader.optimizationLevel > 1) {
		output = BrowserPlatform$applyClosureCompiler$LBrowserPlatform$SSB(platform, output, "SIMPLE_OPTIMIZATIONS", false);
	}
	compiledScript = dom.document.createElement("script");
	scriptSection = dom.document.createTextNode(output);
	compiledScript.appendChild(scriptSection);
	script.parentNode.appendChild(compiledScript);
	console.log("jsx-script-loader: load " + sourceFile + " in " + (Date.now() - t0 + "") + " ms.");
	applicationArguments = script.getAttribute("data-arguments");
	if (applicationArguments) {
		args = JSON.parse(applicationArguments);
		if (args instanceof Array) {
			array = args;
			for ((i = 0, array$len$0 = array.length); i < array$len$0; ++ i) {
				if (typeof array[i] !== "string") {
					throw new TypeError("Not an array of string: arguments[i] is " + JSON.stringify(array[i]));
				}
			}
		} else {
			throw new TypeError("Not an array of string: " + applicationArguments);
		}
		BrowserPlatform$debug$LBrowserPlatform$X(platform, Util$format$SAS("run _Main.main()@%1 with %2", [ sourceFile, applicationArguments ]));
		jsxModule = js.global.JSX;
		jsxRequire = jsxModule.require;
		jsxRuntime = jsxRequire(sourceFile);
		jsxMain = jsxRuntime._Main;
		jsxMain["main$AS"](args);
	}
};

ScriptLoader.loadScript$LHTMLScriptElement$ = ScriptLoader$loadScript$LHTMLScriptElement$;

function _Main() {
};

$__jsx_extend([_Main], Object);
function _Main$main$AS(args) {
	ScriptLoader$load$();
};

_Main.main = _Main$main$AS;
_Main.main$AS = _Main$main$AS;

function dom() {
};

$__jsx_extend([dom], Object);
function dom$id$S(id) {
	return dom.document.getElementById(id);
};

dom.id$S = dom$id$S;

function dom$getElementById$S(id) {
	return dom.document.getElementById(id);
};

dom.getElementById$S = dom$getElementById$S;

function dom$createElement$S(tag) {
	return dom.document.createElement(tag);
};

dom.createElement$S = dom$createElement$S;

function EventInit() {
	this.bubbles = false;
	this.cancelable = false;
};

$__jsx_extend([EventInit], Object);
function CustomEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.detail = null;
};

$__jsx_extend([CustomEventInit], EventInit);
function MutationObserverInit() {
	this.childList = false;
	this.attributes = false;
	this.characterData = false;
	this.subtree = false;
	this.attributeOldValue = false;
	this.characterDataOldValue = false;
	this.attributeFilter = null;
};

$__jsx_extend([MutationObserverInit], Object);
function UIEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.view = null;
	this.detail = 0;
};

$__jsx_extend([UIEventInit], EventInit);
function FocusEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.view = null;
	this.detail = 0;
	this.relatedTarget = null;
};

$__jsx_extend([FocusEventInit], Object);
function MouseEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.view = null;
	this.detail = 0;
	this.screenX = 0;
	this.screenY = 0;
	this.clientX = 0;
	this.clientY = 0;
	this.ctrlKey = false;
	this.shiftKey = false;
	this.altKey = false;
	this.metaKey = false;
	this.button = 0;
	this.buttons = 0;
	this.relatedTarget = null;
	this.region = null;
};

$__jsx_extend([MouseEventInit], UIEventInit);
function WheelEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.view = null;
	this.detail = 0;
	this.screenX = 0;
	this.screenY = 0;
	this.clientX = 0;
	this.clientY = 0;
	this.ctrlKey = false;
	this.shiftKey = false;
	this.altKey = false;
	this.metaKey = false;
	this.button = 0;
	this.buttons = 0;
	this.relatedTarget = null;
	this.deltaX = 0;
	this.deltaY = 0;
	this.deltaZ = 0;
	this.deltaMode = 0;
};

$__jsx_extend([WheelEventInit], Object);
function KeyboardEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.view = null;
	this.detail = 0;
	this.char = "";
	this.key = "";
	this.location = 0;
	this.ctrlKey = false;
	this.shiftKey = false;
	this.altKey = false;
	this.metaKey = false;
	this.repeat = false;
	this.locale = "";
	this.charCode = 0;
	this.keyCode = 0;
	this.which = 0;
};

$__jsx_extend([KeyboardEventInit], Object);
function CompositionEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.view = null;
	this.detail = 0;
	this.data = null;
	this.locale = "";
};

$__jsx_extend([CompositionEventInit], Object);
function ProgressEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.lengthComputable = false;
	this.loaded = 0;
	this.total = 0;
};

$__jsx_extend([ProgressEventInit], EventInit);
function XMLHttpRequestOptions() {
	this.anon = false;
};

$__jsx_extend([XMLHttpRequestOptions], Object);
function TrackEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.track = null;
};

$__jsx_extend([TrackEventInit], EventInit);
function PopStateEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.state = null;
};

$__jsx_extend([PopStateEventInit], EventInit);
function HashChangeEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.oldURL = "";
	this.newURL = "";
};

$__jsx_extend([HashChangeEventInit], EventInit);
function PageTransitionEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.persisted = false;
};

$__jsx_extend([PageTransitionEventInit], EventInit);
function DragEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.view = null;
	this.detail = 0;
	this.screenX = 0;
	this.screenY = 0;
	this.clientX = 0;
	this.clientY = 0;
	this.ctrlKey = false;
	this.shiftKey = false;
	this.altKey = false;
	this.metaKey = false;
	this.button = 0;
	this.buttons = 0;
	this.relatedTarget = null;
	this.dataTransfer = null;
};

$__jsx_extend([DragEventInit], EventInit);
function CloseEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.wasClean = false;
	this.code = 0;
	this.reason = "";
};

$__jsx_extend([CloseEventInit], EventInit);
function StorageEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.key = null;
	this.oldValue = null;
	this.newValue = null;
	this.url = "";
	this.storageArea = null;
};

$__jsx_extend([StorageEventInit], EventInit);
function MessageEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.data = null;
	this.origin = "";
	this.lastEventId = "";
	this.source = null;
	this.ports = null;
};

$__jsx_extend([MessageEventInit], EventInit);
function ErrorEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.message = "";
	this.filename = "";
	this.lineno = 0;
};

$__jsx_extend([ErrorEventInit], EventInit);
function EventSourceInit() {
	this.withCredentials = false;
};

$__jsx_extend([EventSourceInit], Object);
function IDBObjectStoreParameters() {
	this.keyPath = null;
	this.autoIncrement = false;
};

$__jsx_extend([IDBObjectStoreParameters], Object);
function IDBIndexParameters() {
	this.unique = false;
	this.multiEntry = false;
};

$__jsx_extend([IDBIndexParameters], Object);
function IDBVersionChangeEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.oldVersion = 0;
	this.newVersion = null;
};

$__jsx_extend([IDBVersionChangeEventInit], EventInit);
function NotificationOptions() {
	this.titleDir = "";
	this.body = "";
	this.bodyDir = "";
	this.tag = "";
	this.iconUrl = "";
};

$__jsx_extend([NotificationOptions], Object);
function RTCSessionDescriptionInit() {
	this.type = "";
	this.sdp = "";
};

$__jsx_extend([RTCSessionDescriptionInit], Object);
function RTCIceCandidateInit() {
	this.candidate = "";
	this.sdpMid = "";
	this.sdpMLineIndex = 0;
};

$__jsx_extend([RTCIceCandidateInit], Object);
function RTCIceServer() {
	this.url = "";
	this.credential = null;
};

$__jsx_extend([RTCIceServer], Object);
function RTCConfiguration() {
	this.iceServers = null;
};

$__jsx_extend([RTCConfiguration], Object);
function DataChannelInit() {
	this.reliable = false;
};

$__jsx_extend([DataChannelInit], Object);
function RTCPeerConnectionIceEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.candidate = null;
};

$__jsx_extend([RTCPeerConnectionIceEventInit], EventInit);
function MediaStreamEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.stream = null;
};

$__jsx_extend([MediaStreamEventInit], EventInit);
function DataChannelEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.channel = null;
};

$__jsx_extend([DataChannelEventInit], EventInit);
function MediaStreamConstraints() {
	this.video = null;
	this.audio = null;
};

$__jsx_extend([MediaStreamConstraints], Object);
function MediaTrackConstraints() {
	this.mandatory = null;
	this.optional = null;
};

$__jsx_extend([MediaTrackConstraints], Object);
function HitRegionOptions() {
	this.path = null;
	this.id = "";
	this.parentID = null;
	this.cursor = "";
	this.control = null;
	this.label = null;
	this.role = null;
};

$__jsx_extend([HitRegionOptions], Object);
function WebGLContextAttributes() {
	this.alpha = false;
	this.depth = false;
	this.stencil = false;
	this.antialias = false;
	this.premultipliedAlpha = false;
	this.preserveDrawingBuffer = false;
};

$__jsx_extend([WebGLContextAttributes], Object);
function WebGLContextEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.statusMessage = "";
};

$__jsx_extend([WebGLContextEventInit], EventInit);
function DeviceOrientationEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.alpha = null;
	this.beta = null;
	this.gamma = null;
	this.absolute = false;
};

$__jsx_extend([DeviceOrientationEventInit], EventInit);
function DeviceMotionEventInit() {
	this.bubbles = false;
	this.cancelable = false;
	this.acceleration = null;
	this.accelerationIncludingGravity = null;
	this.rotationRate = null;
	this.interval = null;
};

$__jsx_extend([DeviceMotionEventInit], EventInit);
var _remove_require$0 = (function (exports) { exports.require = function (module) { console.error('ignore loading module: ' + module); return {}; }; }(new Function('return this')()));
function Compiler(platform) {
	this._builtinParsers = null;
	this._emitter = null;
	this._platform = platform;
	this._mode = 0;
	this._optimizer = null;
	this._warningFilters = [  ];
	this._warningAsError = false;
	this._parsers = [];
	this._fileCache = {};
	this._searchPaths = [ this._platform.getRoot$() + "/lib/common" ];
	Compiler$addSourceFile$LCompiler$LToken$S(this, null, this._platform.getRoot$() + "/lib/built-in.jsx");
	this._builtinParsers = this._parsers.concat([]);
};

$__jsx_extend([Compiler], Object);
Compiler.prototype.addSearchPath$S = function (path) {
	this._searchPaths.unshift(path);
};


function Compiler$addSearchPath$LCompiler$S($this, path) {
	$this._searchPaths.unshift(path);
};

Compiler.addSearchPath$LCompiler$S = Compiler$addSearchPath$LCompiler$S;

Compiler.prototype.getPlatform$ = function () {
	return this._platform;
};


function Compiler$getPlatform$LCompiler$($this) {
	return $this._platform;
};

Compiler.getPlatform$LCompiler$ = Compiler$getPlatform$LCompiler$;

Compiler.prototype.getMode$ = function () {
	return this._mode;
};


function Compiler$getMode$LCompiler$($this) {
	return $this._mode;
};

Compiler.getMode$LCompiler$ = Compiler$getMode$LCompiler$;

Compiler.prototype.setMode$N = function (mode) {
	this._mode = mode;
	return this;
};


function Compiler$setMode$LCompiler$N($this, mode) {
	$this._mode = mode;
	return $this;
};

Compiler.setMode$LCompiler$N = Compiler$setMode$LCompiler$N;

Compiler.prototype.getEmitter$ = function () {
	return this._emitter;
};


function Compiler$getEmitter$LCompiler$($this) {
	return $this._emitter;
};

Compiler.getEmitter$LCompiler$ = Compiler$getEmitter$LCompiler$;

Compiler.prototype.setEmitter$LEmitter$ = function (emitter) {
	this._emitter = emitter;
};


function Compiler$setEmitter$LCompiler$LEmitter$($this, emitter) {
	$this._emitter = emitter;
};

Compiler.setEmitter$LCompiler$LEmitter$ = Compiler$setEmitter$LCompiler$LEmitter$;

Compiler.prototype.setOptimizer$LOptimizer$ = function (optimizer) {
	this._optimizer = optimizer;
};


function Compiler$setOptimizer$LCompiler$LOptimizer$($this, optimizer) {
	$this._optimizer = optimizer;
};

Compiler.setOptimizer$LCompiler$LOptimizer$ = Compiler$setOptimizer$LCompiler$LOptimizer$;

Compiler.prototype.getWarningFilters$ = function () {
	return this._warningFilters;
};


function Compiler$getWarningFilters$LCompiler$($this) {
	return $this._warningFilters;
};

Compiler.getWarningFilters$LCompiler$ = Compiler$getWarningFilters$LCompiler$;

Compiler.prototype.setWarningAsError$B = function (f) {
	this._warningAsError = f;
};


function Compiler$setWarningAsError$LCompiler$B($this, f) {
	$this._warningAsError = f;
};

Compiler.setWarningAsError$LCompiler$B = Compiler$setWarningAsError$LCompiler$B;

Compiler.prototype.getParsers$ = function () {
	return this._parsers;
};


function Compiler$getParsers$LCompiler$($this) {
	return $this._parsers;
};

Compiler.getParsers$LCompiler$ = Compiler$getParsers$LCompiler$;

Compiler.prototype.addSourceFile$LToken$S = function (token, path) {
	return Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$(this, token, path, null);
};


function Compiler$addSourceFile$LCompiler$LToken$S($this, token, path) {
	return Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$($this, token, path, null);
};

Compiler.addSourceFile$LCompiler$LToken$S = Compiler$addSourceFile$LCompiler$LToken$S;

Compiler.prototype.addSourceFile$LToken$SLCompletionRequest$ = function (token, path, completionRequest) {
	var parser;
	if ((parser = Compiler$findParser$LCompiler$S(this, path)) == null) {
		parser = ({_sourceToken: token, _filename: path, _completionRequest: completionRequest, _input: "", _lines: null, _tokenLength: 0, _lineNumber: 0, _columnOffset: 0, _fileLevelDocComment: null, _docComment: null, _errors: null, _templateClassDefs: null, _classDefs: null, _imports: null, _isGenerator: false, _locals: null, _statements: null, _closures: null, _outerClass: null, _classType: null, _extendType: null, _implementTypes: null, _objectTypesUsed: null, _inners: null, _templateInners: null, _templateInstantiationRequests: null, _prevScope: null, _funcLocal: null, _arguments: null, _classFlags: 0, _typeArgs: null});
		this._parsers.push(parser);
	}
	return parser;
};


function Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$($this, token, path, completionRequest) {
	var parser;
	if ((parser = Compiler$findParser$LCompiler$S($this, path)) == null) {
		parser = ({_sourceToken: token, _filename: path, _completionRequest: completionRequest, _input: "", _lines: null, _tokenLength: 0, _lineNumber: 0, _columnOffset: 0, _fileLevelDocComment: null, _docComment: null, _errors: null, _templateClassDefs: null, _classDefs: null, _imports: null, _isGenerator: false, _locals: null, _statements: null, _closures: null, _outerClass: null, _classType: null, _extendType: null, _implementTypes: null, _objectTypesUsed: null, _inners: null, _templateInners: null, _templateInstantiationRequests: null, _prevScope: null, _funcLocal: null, _arguments: null, _classFlags: 0, _typeArgs: null});
		$this._parsers.push(parser);
	}
	return parser;
};

Compiler.addSourceFile$LCompiler$LToken$SLCompletionRequest$ = Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$;

Compiler.prototype.findParser$S = function (path) {
	var i;
	for (i = 0; i < this._parsers.length; ++ i) {
		if (this._parsers[i]._filename === path) {
			return this._parsers[i];
		}
	}
	return null;
};


function Compiler$findParser$LCompiler$S($this, path) {
	var i;
	for (i = 0; i < $this._parsers.length; ++ i) {
		if ($this._parsers[i]._filename === path) {
			return $this._parsers[i];
		}
	}
	return null;
};

Compiler.findParser$LCompiler$S = Compiler$findParser$LCompiler$S;

Compiler.prototype.compile$ = function () {
	var $this = this;
	var errors;
	var i;
	var builtins;
	var transformer;
	errors = [];
	for (i = 0; i < this._parsers.length; ++ i) {
		if (! Compiler$parseFile$LCompiler$ALCompileError$LParser$(this, errors, this._parsers[i])) {
			if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
				return false;
			}
		}
	}
	switch (this._mode) {
	case 1:
		return true;
	}
	Compiler$normalizeClassDefs$LCompiler$ALCompileError$(this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
		return false;
	}
	Compiler$_resolveImports$LCompiler$ALCompileError$(this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
		return false;
	}
	builtins = this._builtinParsers[0];
	BooleanType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Boolean");
	NumberType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Number");
	StringType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "String");
	FunctionType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Function");
	CodeTransformer.stopIterationType = new ObjectType(Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "g_StopIteration"));
	for (i = 0; i < builtins._templateClassDefs.length; ++ i) {
		if (builtins._templateClassDefs[i]._className === "__jsx_generator") {
			CodeTransformer.jsxGeneratorClassDef = builtins._templateClassDefs[i];
		}
	}
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
		return false;
	}
	Compiler$_resolveTypes$LCompiler$ALCompileError$(this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
		return false;
	}
	Compiler$_exportEntryPoints$LCompiler$(this);
	Compiler$_analyze$LCompiler$ALCompileError$(this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
		return false;
	}
	switch (this._mode) {
	case 2:
		return true;
	case 3:
		return true;
	}
	transformer = ({_labelMap: [], _statementIDs: {}});
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function onMember(member) {
			var funcDef;
			if (member instanceof MemberFunctionDefinition) {
				funcDef = member;
				if (MemberFunctionDefinition$isGenerator$LMemberFunctionDefinition$(funcDef)) {
					CodeTransformer$transformFunctionDefinition$LCodeTransformer$LMemberFunctionDefinition$(transformer, funcDef);
				}
			}
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(member, (function (funcDef) {
				return onMember(funcDef);
			}));
		}));
	}));
	Compiler$_optimize$LCompiler$(this);
	Compiler$_generateCode$LCompiler$ALCompileError$(this, errors);
	return (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors) ? false : true);
};


function Compiler$compile$LCompiler$($this) {
	var errors;
	var i;
	var builtins;
	var transformer;
	errors = [];
	for (i = 0; i < $this._parsers.length; ++ i) {
		if (! Compiler$parseFile$LCompiler$ALCompileError$LParser$($this, errors, $this._parsers[i])) {
			if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
				return false;
			}
		}
	}
	switch ($this._mode) {
	case 1:
		return true;
	}
	Compiler$normalizeClassDefs$LCompiler$ALCompileError$($this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
		return false;
	}
	Compiler$_resolveImports$LCompiler$ALCompileError$($this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
		return false;
	}
	builtins = $this._builtinParsers[0];
	BooleanType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Boolean");
	NumberType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Number");
	StringType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "String");
	FunctionType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Function");
	CodeTransformer.stopIterationType = new ObjectType(Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "g_StopIteration"));
	for (i = 0; i < builtins._templateClassDefs.length; ++ i) {
		if (builtins._templateClassDefs[i]._className === "__jsx_generator") {
			CodeTransformer.jsxGeneratorClassDef = builtins._templateClassDefs[i];
		}
	}
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
		return false;
	}
	Compiler$_resolveTypes$LCompiler$ALCompileError$($this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
		return false;
	}
	Compiler$_exportEntryPoints$LCompiler$($this);
	Compiler$_analyze$LCompiler$ALCompileError$($this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
		return false;
	}
	switch ($this._mode) {
	case 2:
		return true;
	case 3:
		return true;
	}
	transformer = ({_labelMap: [], _statementIDs: {}});
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function onMember(member) {
			var funcDef;
			if (member instanceof MemberFunctionDefinition) {
				funcDef = member;
				if (MemberFunctionDefinition$isGenerator$LMemberFunctionDefinition$(funcDef)) {
					CodeTransformer$transformFunctionDefinition$LCodeTransformer$LMemberFunctionDefinition$(transformer, funcDef);
				}
			}
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(member, (function (funcDef) {
				return onMember(funcDef);
			}));
		}));
	}));
	Compiler$_optimize$LCompiler$($this);
	Compiler$_generateCode$LCompiler$ALCompileError$($this, errors);
	return (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors) ? false : true);
};

Compiler.compile$LCompiler$ = Compiler$compile$LCompiler$;

Compiler.prototype.getAST$ = function () {
	var classDefs;
	var i;
	classDefs = [];
	for (i = 0; i < this._parsers.length; ++ i) {
		classDefs = classDefs.concat(this._parsers[i]._classDefs);
	}
	return ClassDefinition$serialize$ALClassDefinition$(classDefs);
};


function Compiler$getAST$LCompiler$($this) {
	var classDefs;
	var i;
	classDefs = [];
	for (i = 0; i < $this._parsers.length; ++ i) {
		classDefs = classDefs.concat($this._parsers[i]._classDefs);
	}
	return ClassDefinition$serialize$ALClassDefinition$(classDefs);
};

Compiler.getAST$LCompiler$ = Compiler$getAST$LCompiler$;

Compiler.prototype.getFileContent$ALCompileError$LToken$S = function (errors, sourceToken, path) {
	if (this._fileCache[path] == null) {
		try {
			this._fileCache[path] = this._platform.load$S(path);
		} catch ($__jsx_catch_0) {
			if ($__jsx_catch_0 instanceof Error) {
				errors.push(new CompileError(sourceToken, "could not open file: " + path + ", " + $__jsx_catch_0.toString()));
				this._fileCache[path] = null;
			} else {
				throw $__jsx_catch_0;
			}
		}
	}
	return this._fileCache[path];
};


function Compiler$getFileContent$LCompiler$ALCompileError$LToken$S($this, errors, sourceToken, path) {
	if ($this._fileCache[path] == null) {
		try {
			$this._fileCache[path] = $this._platform.load$S(path);
		} catch ($__jsx_catch_0) {
			if ($__jsx_catch_0 instanceof Error) {
				errors.push(new CompileError(sourceToken, "could not open file: " + path + ", " + $__jsx_catch_0.toString()));
				$this._fileCache[path] = null;
			} else {
				throw $__jsx_catch_0;
			}
		}
	}
	return $this._fileCache[path];
};

Compiler.getFileContent$LCompiler$ALCompileError$LToken$S = Compiler$getFileContent$LCompiler$ALCompileError$LToken$S;

Compiler.prototype.parseFile$ALCompileError$LParser$ = function (errors, parser) {
	var content;
	var imports;
	var i;
	var imports$len$0;
	content = Compiler$getFileContent$LCompiler$ALCompileError$LToken$S(this, errors, parser._sourceToken, parser._filename);
	if (content == null) {
		Parser$parse$LParser$SALCompileError$(parser, "", []);
		return false;
	}
	Parser$parse$LParser$SALCompileError$(parser, content, errors);
	if (this._mode !== 1) {
		imports = parser._imports;
		for ((i = 0, imports$len$0 = imports.length); i < imports$len$0; ++ i) {
			if (! Compiler$_handleImport$LCompiler$ALCompileError$LParser$LImport$(this, errors, parser, imports[i])) {
				return false;
			}
		}
	}
	return true;
};


function Compiler$parseFile$LCompiler$ALCompileError$LParser$($this, errors, parser) {
	var content;
	var imports;
	var i;
	var imports$len$0;
	content = Compiler$getFileContent$LCompiler$ALCompileError$LToken$S($this, errors, parser._sourceToken, parser._filename);
	if (content == null) {
		Parser$parse$LParser$SALCompileError$(parser, "", []);
		return false;
	}
	Parser$parse$LParser$SALCompileError$(parser, content, errors);
	if ($this._mode !== 1) {
		imports = parser._imports;
		for ((i = 0, imports$len$0 = imports.length); i < imports$len$0; ++ i) {
			if (! Compiler$_handleImport$LCompiler$ALCompileError$LParser$LImport$($this, errors, parser, imports[i])) {
				return false;
			}
		}
	}
	return true;
};

Compiler.parseFile$LCompiler$ALCompileError$LParser$ = Compiler$parseFile$LCompiler$ALCompileError$LParser$;

Compiler.prototype._handleImport$ALCompileError$LParser$LImport$ = function (errors, parser, imprt) {
	var wildImprt;
	var resolvedDir;
	var files;
	var found;
	var i;
	var path;
	var newParser;
	var _filenameToken$0;
	if (imprt instanceof WildcardImport) {
		wildImprt = imprt;
		resolvedDir = Compiler$_resolvePath$LCompiler$SS(this, wildImprt._filenameToken._filename, wildImprt._directory);
		files = [];
		try {
			files = this._platform.getFilesInDirectory$S(resolvedDir);
		} catch ($__jsx_catch_0) {
			if ($__jsx_catch_0 instanceof Error) {
				errors.push(new CompileError(wildImprt._filenameToken, "could not read files in directory: " + resolvedDir + ", " + $__jsx_catch_0.toString()));
				return false;
			} else {
				throw $__jsx_catch_0;
			}
		}
		found = false;
		for (i = 0; i < files.length; ++ i) {
			if (files[i].length >= wildImprt._suffix.length && files[i].charAt(0) !== "." && files[i].substring(files[i].length - wildImprt._suffix.length) === wildImprt._suffix) {
				path = resolvedDir + "/" + files[i];
				if (path !== parser._filename) {
					newParser = Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$(this, wildImprt._filenameToken, resolvedDir + "/" + files[i], null);
					wildImprt._sourceParsers.push(newParser);
					found = true;
				}
			}
		}
		if (! found) {
			errors.push(new CompileError(wildImprt._filenameToken, "no matching files found in directory: " + resolvedDir));
			return false;
		}
	} else {
		path = Compiler$_resolvePath$LCompiler$SS(this, (_filenameToken$0 = imprt._filenameToken)._filename, Util$decodeStringLiteral$S(_filenameToken$0._value));
		if (path === parser._filename) {
			errors.push(new CompileError(imprt._filenameToken, "cannot import itself"));
			return false;
		}
		newParser = Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$(this, imprt._filenameToken, path, null);
		imprt._sourceParsers.push(newParser);
	}
	return true;
};


function Compiler$_handleImport$LCompiler$ALCompileError$LParser$LImport$($this, errors, parser, imprt) {
	var wildImprt;
	var resolvedDir;
	var files;
	var found;
	var i;
	var path;
	var newParser;
	var _filenameToken$0;
	if (imprt instanceof WildcardImport) {
		wildImprt = imprt;
		resolvedDir = Compiler$_resolvePath$LCompiler$SS($this, wildImprt._filenameToken._filename, wildImprt._directory);
		files = [];
		try {
			files = $this._platform.getFilesInDirectory$S(resolvedDir);
		} catch ($__jsx_catch_0) {
			if ($__jsx_catch_0 instanceof Error) {
				errors.push(new CompileError(wildImprt._filenameToken, "could not read files in directory: " + resolvedDir + ", " + $__jsx_catch_0.toString()));
				return false;
			} else {
				throw $__jsx_catch_0;
			}
		}
		found = false;
		for (i = 0; i < files.length; ++ i) {
			if (files[i].length >= wildImprt._suffix.length && files[i].charAt(0) !== "." && files[i].substring(files[i].length - wildImprt._suffix.length) === wildImprt._suffix) {
				path = resolvedDir + "/" + files[i];
				if (path !== parser._filename) {
					newParser = Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$($this, wildImprt._filenameToken, resolvedDir + "/" + files[i], null);
					wildImprt._sourceParsers.push(newParser);
					found = true;
				}
			}
		}
		if (! found) {
			errors.push(new CompileError(wildImprt._filenameToken, "no matching files found in directory: " + resolvedDir));
			return false;
		}
	} else {
		path = Compiler$_resolvePath$LCompiler$SS($this, (_filenameToken$0 = imprt._filenameToken)._filename, Util$decodeStringLiteral$S(_filenameToken$0._value));
		if (path === parser._filename) {
			errors.push(new CompileError(imprt._filenameToken, "cannot import itself"));
			return false;
		}
		newParser = Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$($this, imprt._filenameToken, path, null);
		imprt._sourceParsers.push(newParser);
	}
	return true;
};

Compiler._handleImport$LCompiler$ALCompileError$LParser$LImport$ = Compiler$_handleImport$LCompiler$ALCompileError$LParser$LImport$;

Compiler.prototype.forEachClassDef$F$LParser$LClassDefinition$B$ = function (f) {
	var $this = this;
	var onClassDef;
	var i;
	var parser;
	var classDefs;
	var j;
	var classDefs$len$0;
	function onClassDef(parser, classDef) {
		var inners;
		var i;
		var inners$len$0;
		if (! f(parser, classDef)) {
			return false;
		}
		inners = classDef._inners;
		for ((i = 0, inners$len$0 = inners.length); i < inners$len$0; ++ i) {
			if (! onClassDef(parser, inners[i])) {
				return false;
			}
		}
		return true;
	}
	for (i = 0; i < this._parsers.length; ++ i) {
		parser = this._parsers[i];
		classDefs = parser._classDefs;
		for ((j = 0, classDefs$len$0 = classDefs.length); j < classDefs$len$0; ++ j) {
			if (! onClassDef(parser, classDefs[j])) {
				return false;
			}
		}
	}
	return true;
};


function Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, f) {
	var onClassDef;
	var i;
	var parser;
	var classDefs;
	var j;
	var classDefs$len$0;
	function onClassDef(parser, classDef) {
		var inners;
		var i;
		var inners$len$0;
		if (! f(parser, classDef)) {
			return false;
		}
		inners = classDef._inners;
		for ((i = 0, inners$len$0 = inners.length); i < inners$len$0; ++ i) {
			if (! onClassDef(parser, inners[i])) {
				return false;
			}
		}
		return true;
	}
	for (i = 0; i < $this._parsers.length; ++ i) {
		parser = $this._parsers[i];
		classDefs = parser._classDefs;
		for ((j = 0, classDefs$len$0 = classDefs.length); j < classDefs$len$0; ++ j) {
			if (! onClassDef(parser, classDefs[j])) {
				return false;
			}
		}
	}
	return true;
};

Compiler.forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$ = Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$;

Compiler.prototype.normalizeClassDefs$ALCompileError$ = function (errors) {
	var $this = this;
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		ClassDefinition$normalizeClassDefs$LClassDefinition$ALCompileError$(classDef, errors);
		return true;
	}));
};


function Compiler$normalizeClassDefs$LCompiler$ALCompileError$($this, errors) {
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		ClassDefinition$normalizeClassDefs$LClassDefinition$ALCompileError$(classDef, errors);
		return true;
	}));
};

Compiler.normalizeClassDefs$LCompiler$ALCompileError$ = Compiler$normalizeClassDefs$LCompiler$ALCompileError$;

Compiler.prototype._resolveImports$ALCompileError$ = function (errors) {
	var i;
	var imports;
	var j;
	for (i = 0; i < this._parsers.length; ++ i) {
		Parser$registerBuiltinImports$LParser$ALParser$(this._parsers[i], this._builtinParsers);
		imports = this._parsers[i]._imports;
		for (j = 0; j < imports.length; ++ j) {
			Import$assertExistenceOfNamedClasses$LImport$ALCompileError$(imports[j], errors);
		}
	}
};


function Compiler$_resolveImports$LCompiler$ALCompileError$($this, errors) {
	var i;
	var imports;
	var j;
	for (i = 0; i < $this._parsers.length; ++ i) {
		Parser$registerBuiltinImports$LParser$ALParser$($this._parsers[i], $this._builtinParsers);
		imports = $this._parsers[i]._imports;
		for (j = 0; j < imports.length; ++ j) {
			Import$assertExistenceOfNamedClasses$LImport$ALCompileError$(imports[j], errors);
		}
	}
};

Compiler._resolveImports$LCompiler$ALCompileError$ = Compiler$_resolveImports$LCompiler$ALCompileError$;

Compiler.prototype._resolveTypes$ALCompileError$ = function (errors) {
	var $this = this;
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(classDef, ({errors: errors, parser: parser, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}));
		return true;
	}));
};


function Compiler$_resolveTypes$LCompiler$ALCompileError$($this, errors) {
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(classDef, ({errors: errors, parser: parser, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}));
		return true;
	}));
};

Compiler._resolveTypes$LCompiler$ALCompileError$ = Compiler$_resolveTypes$LCompiler$ALCompileError$;

Compiler.prototype._analyze$ALCompileError$ = function (errors) {
	var $this = this;
	var createContext;
	createContext = (function (parser) {
		return ({errors: errors, parser: parser, postInstantiationCallback: (function (parser, classDef) {
			ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			return classDef;
		}), funcDef: null, blockStack: null, statement: null});
	});
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		ClassDefinition$analyzeUnusedVariables$LClassDefinition$(classDef);
		return true;
	}));
};


function Compiler$_analyze$LCompiler$ALCompileError$($this, errors) {
	var createContext;
	createContext = (function (parser) {
		return ({errors: errors, parser: parser, postInstantiationCallback: (function (parser, classDef) {
			ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			return classDef;
		}), funcDef: null, blockStack: null, statement: null});
	});
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		ClassDefinition$analyzeUnusedVariables$LClassDefinition$(classDef);
		return true;
	}));
};

Compiler._analyze$LCompiler$ALCompileError$ = Compiler$_analyze$LCompiler$ALCompileError$;

Compiler.prototype._optimize$ = function () {
	if (this._optimizer != null) {
		Optimizer$performOptimization$LOptimizer$(Optimizer$setCompiler$LOptimizer$LCompiler$(this._optimizer, this));
	}
};


function Compiler$_optimize$LCompiler$($this) {
	if ($this._optimizer != null) {
		Optimizer$performOptimization$LOptimizer$(Optimizer$setCompiler$LOptimizer$LCompiler$($this._optimizer, $this));
	}
};

Compiler._optimize$LCompiler$ = Compiler$_optimize$LCompiler$;

Compiler.prototype._generateCode$ALCompileError$ = function (errors) {
	var $this = this;
	var classDefs;
	var i;
	var nativeClassNames;
	var foundConflict;
	var getMaxIndexOfClasses;
	var deps;
	var maxIndexOfClasses;
	var this$0;
	var i$0;
	var i$1;
	classDefs = [];
	for (i = 0; i < this._parsers.length; ++ i) {
		classDefs = classDefs.concat(this._parsers[i]._classDefs);
		this$0 = this._parsers[i]._templateClassDefs;
		for (i$0 in this$0) {
			(function (templateClassDef) {
				if ((templateClassDef._flags & 16) !== 0 && templateClassDef._nativeSource != null) {
					classDefs.push(templateClassDef);
				}
			})(this$0[i$0]);
		}
	}
	for (i = 0; i < classDefs.length; ++ i) {
		if (classDefs[i]._inners.length !== 0) {
			classDefs = classDefs.concat(classDefs[i]._inners);
		}
	}
	nativeClassNames = {};
	foundConflict = false;
	for (i$1 in classDefs) {
		(function (classDef) {
			var getTemplateClass$this$0;
			if ((classDef.flags$() & 16) === 0) {
				return;
			}
			if ($__jsx_ObjectHasOwnProperty.call(nativeClassNames, classDef.className$()) && ! (classDef instanceof InstantiatedClassDefinition && nativeClassNames[classDef.className$()] instanceof InstantiatedClassDefinition && classDef._templateClassDef == (getTemplateClass$this$0 = nativeClassNames[classDef.className$()], getTemplateClass$this$0._templateClassDef)) && classDef._nativeSource == null) {
				errors.push(CompileError$addCompileNote$LCompileError$LCompileNote$(new CompileError(classDef.getToken$(), "native class with same name is already defined"), new CompileNote(nativeClassNames[classDef.className$()].getToken$(), "here")));
				foundConflict = true;
				return;
			}
			nativeClassNames[classDef.className$()] = classDef;
		})(classDefs[i$1]);
	}
	if (foundConflict) {
		return;
	}
	getMaxIndexOfClasses = (function (deps) {
		var i;
		var j;
		deps = deps.concat([  ]);
		if (deps.length === 0) {
			return -1;
		}
		for (i = 0; i < classDefs.length; ++ i) {
			for (j = 0; j < deps.length; ++ j) {
				if (classDefs[i] == deps[j]) {
					deps.splice(j, 1);
					if (deps.length === 0) {
						return i;
					}
				}
			}
		}
		throw new Error("logic flaw, could not find class definition of '" + deps[0].className$() + "'");
	});
	for (i = 0; i < classDefs.length; ) {
		deps = classDefs[i]._implementTypes.map((function (t) {
			return t._classDef;
		})).concat([  ]);
		if (classDefs[i]._extendType != null) {
			deps.unshift(classDefs[i]._extendType._classDef);
		}
		if (classDefs[i]._outerClassDef != null && deps.indexOf(classDefs[i]._outerClassDef) === -1) {
			deps.unshift(classDefs[i]._outerClassDef);
		}
		maxIndexOfClasses = getMaxIndexOfClasses(deps);
		if (maxIndexOfClasses > i) {
			classDefs.splice(maxIndexOfClasses + 1, 0, classDefs[i]);
			classDefs.splice(i, 1);
		} else {
			++ i;
		}
	}
	this._emitter.emit$ALClassDefinition$(classDefs);
};


function Compiler$_generateCode$LCompiler$ALCompileError$($this, errors) {
	var classDefs;
	var i;
	var nativeClassNames;
	var foundConflict;
	var getMaxIndexOfClasses;
	var deps;
	var maxIndexOfClasses;
	var this$0;
	var i$0;
	var i$1;
	classDefs = [];
	for (i = 0; i < $this._parsers.length; ++ i) {
		classDefs = classDefs.concat($this._parsers[i]._classDefs);
		this$0 = $this._parsers[i]._templateClassDefs;
		for (i$0 in this$0) {
			(function (templateClassDef) {
				if ((templateClassDef._flags & 16) !== 0 && templateClassDef._nativeSource != null) {
					classDefs.push(templateClassDef);
				}
			})(this$0[i$0]);
		}
	}
	for (i = 0; i < classDefs.length; ++ i) {
		if (classDefs[i]._inners.length !== 0) {
			classDefs = classDefs.concat(classDefs[i]._inners);
		}
	}
	nativeClassNames = {};
	foundConflict = false;
	for (i$1 in classDefs) {
		(function (classDef) {
			var getTemplateClass$this$0;
			if ((classDef.flags$() & 16) === 0) {
				return;
			}
			if ($__jsx_ObjectHasOwnProperty.call(nativeClassNames, classDef.className$()) && ! (classDef instanceof InstantiatedClassDefinition && nativeClassNames[classDef.className$()] instanceof InstantiatedClassDefinition && classDef._templateClassDef == (getTemplateClass$this$0 = nativeClassNames[classDef.className$()], getTemplateClass$this$0._templateClassDef)) && classDef._nativeSource == null) {
				errors.push(CompileError$addCompileNote$LCompileError$LCompileNote$(new CompileError(classDef.getToken$(), "native class with same name is already defined"), new CompileNote(nativeClassNames[classDef.className$()].getToken$(), "here")));
				foundConflict = true;
				return;
			}
			nativeClassNames[classDef.className$()] = classDef;
		})(classDefs[i$1]);
	}
	if (foundConflict) {
		return;
	}
	getMaxIndexOfClasses = (function (deps) {
		var i;
		var j;
		deps = deps.concat([  ]);
		if (deps.length === 0) {
			return -1;
		}
		for (i = 0; i < classDefs.length; ++ i) {
			for (j = 0; j < deps.length; ++ j) {
				if (classDefs[i] == deps[j]) {
					deps.splice(j, 1);
					if (deps.length === 0) {
						return i;
					}
				}
			}
		}
		throw new Error("logic flaw, could not find class definition of '" + deps[0].className$() + "'");
	});
	for (i = 0; i < classDefs.length; ) {
		deps = classDefs[i]._implementTypes.map((function (t) {
			return t._classDef;
		})).concat([  ]);
		if (classDefs[i]._extendType != null) {
			deps.unshift(classDefs[i]._extendType._classDef);
		}
		if (classDefs[i]._outerClassDef != null && deps.indexOf(classDefs[i]._outerClassDef) === -1) {
			deps.unshift(classDefs[i]._outerClassDef);
		}
		maxIndexOfClasses = getMaxIndexOfClasses(deps);
		if (maxIndexOfClasses > i) {
			classDefs.splice(maxIndexOfClasses + 1, 0, classDefs[i]);
			classDefs.splice(i, 1);
		} else {
			++ i;
		}
	}
	$this._emitter.emit$ALClassDefinition$(classDefs);
};

Compiler._generateCode$LCompiler$ALCompileError$ = Compiler$_generateCode$LCompiler$ALCompileError$;

Compiler.prototype._exportEntryPoints$ = function () {
	var $this = this;
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		switch (ClassDefinition$classFullName$LClassDefinition$(classDef)) {
		case "_Main":
			ClassDefinition$setFlags$LClassDefinition$N(classDef, classDef.flags$() | 16384);
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_STATIC) !== 0 && MemberDefinition$name$LMemberDefinition$(funcDef) === "main" && MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef).length === 1 && Util$isArrayOf$LClassDefinition$LType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)[0].getClassDef$(), Type.stringType)) {
					MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_EXPORT);
				}
				return true;
			}));
			break;
		case "_Test":
			ClassDefinition$setFlags$LClassDefinition$N(classDef, classDef.flags$() | 16384);
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_STATIC) === 0 && (MemberDefinition$name$LMemberDefinition$(funcDef).match(/^test/) || MemberDefinition$name$LMemberDefinition$(funcDef) === "constructor") && MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef).length === 0) {
					MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_EXPORT);
				}
				return true;
			}));
			break;
		}
		return true;
	}));
};


function Compiler$_exportEntryPoints$LCompiler$($this) {
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		switch (ClassDefinition$classFullName$LClassDefinition$(classDef)) {
		case "_Main":
			ClassDefinition$setFlags$LClassDefinition$N(classDef, classDef.flags$() | 16384);
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_STATIC) !== 0 && MemberDefinition$name$LMemberDefinition$(funcDef) === "main" && MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef).length === 1 && Util$isArrayOf$LClassDefinition$LType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)[0].getClassDef$(), Type.stringType)) {
					MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_EXPORT);
				}
				return true;
			}));
			break;
		case "_Test":
			ClassDefinition$setFlags$LClassDefinition$N(classDef, classDef.flags$() | 16384);
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_STATIC) === 0 && (MemberDefinition$name$LMemberDefinition$(funcDef).match(/^test/) || MemberDefinition$name$LMemberDefinition$(funcDef) === "constructor") && MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef).length === 0) {
					MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_EXPORT);
				}
				return true;
			}));
			break;
		}
		return true;
	}));
};

Compiler._exportEntryPoints$LCompiler$ = Compiler$_exportEntryPoints$LCompiler$;

Compiler.prototype._handleErrors$ALCompileError$ = function (errors) {
	var $this = this;
	var isFatal;
	var i$0;
	if (this._mode === 2) {
		errors.splice(0, errors.length);
		return true;
	}
	isFatal = false;
	for (i$0 in errors) {
		(function (error) {
			var warning;
			var doWarn;
			var i;
			var s$0;
			var this$0;
			var i$0;
			var platform$0;
			var note$0;
			var _platform$0;
			var _platform$1;
			if (error instanceof CompileWarning) {
				warning = error;
				for (i = 0; i < $this._warningFilters.length; ++ i) {
					if ((doWarn = $this._warningFilters[i](warning)) != null) {
						break;
					}
				}
				if (doWarn !== false) {
					platform$0 = $this._platform;
					s$0 = Util$makeErrorMessage$LPlatform$SUSNNN(platform$0, "Warning: " + warning._message, warning._filename, warning._lineNumber, warning._columnNumber, warning._size);
					console.warn(s$0);
					isFatal = $this._warningAsError;
				}
			} else {
				(_platform$1 = $this._platform).error$S(Util$makeErrorMessage$LPlatform$SUSNNN(_platform$1, error.getPrefix$() + error._message, error._filename, error._lineNumber, error._columnNumber, error._size));
				this$0 = error._notes;
				for (i$0 in this$0) {
					note$0 = this$0[i$0];
					(_platform$0 = $this._platform).error$S(Util$makeErrorMessage$LPlatform$SUSNNN(_platform$0, "Note: " + note$0._message, note$0._filename, note$0._lineNumber, note$0._columnNumber, note$0._size));
				}
				isFatal = true;
			}
		})(errors[i$0]);
	}
	errors.splice(0, errors.length);
	return ! isFatal;
};


function Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors) {
	var isFatal;
	var i$0;
	if ($this._mode === 2) {
		errors.splice(0, errors.length);
		return true;
	}
	isFatal = false;
	for (i$0 in errors) {
		(function (error) {
			var warning;
			var doWarn;
			var i;
			var s$0;
			var this$0;
			var i$0;
			var platform$0;
			var note$0;
			var _platform$0;
			var _platform$1;
			if (error instanceof CompileWarning) {
				warning = error;
				for (i = 0; i < $this._warningFilters.length; ++ i) {
					if ((doWarn = $this._warningFilters[i](warning)) != null) {
						break;
					}
				}
				if (doWarn !== false) {
					platform$0 = $this._platform;
					s$0 = Util$makeErrorMessage$LPlatform$SUSNNN(platform$0, "Warning: " + warning._message, warning._filename, warning._lineNumber, warning._columnNumber, warning._size);
					console.warn(s$0);
					isFatal = $this._warningAsError;
				}
			} else {
				(_platform$1 = $this._platform).error$S(Util$makeErrorMessage$LPlatform$SUSNNN(_platform$1, error.getPrefix$() + error._message, error._filename, error._lineNumber, error._columnNumber, error._size));
				this$0 = error._notes;
				for (i$0 in this$0) {
					note$0 = this$0[i$0];
					(_platform$0 = $this._platform).error$S(Util$makeErrorMessage$LPlatform$SUSNNN(_platform$0, "Note: " + note$0._message, note$0._filename, note$0._lineNumber, note$0._columnNumber, note$0._size));
				}
				isFatal = true;
			}
		})(errors[i$0]);
	}
	errors.splice(0, errors.length);
	return ! isFatal;
};

Compiler._handleErrors$LCompiler$ALCompileError$ = Compiler$_handleErrors$LCompiler$ALCompileError$;

Compiler.prototype._resolvePath$SS = function (srcPath, givenPath) {
	var searchPaths;
	var i;
	var path;
	var lastSlashAt;
	var path$0;
	var path$1;
	if (givenPath.match(/^\.{1,2}\//) == null) {
		searchPaths = this._searchPaths.concat(this._emitter.getSearchPaths$());
		for (i = 0; i < searchPaths.length; ++ i) {
			path$0 = searchPaths[i] + "/" + givenPath;
			path = Util$_resolvedPathParts$S(path$0).join("/");
			if (this._platform.fileExists$S(path)) {
				return path;
			}
		}
	}
	lastSlashAt = srcPath.lastIndexOf("/");
	path$1 = (lastSlashAt !== -1 ? srcPath.substring(0, lastSlashAt + 1) : "") + givenPath;
	path = Util$_resolvedPathParts$S(path$1).join("/");
	return path;
};


function Compiler$_resolvePath$LCompiler$SS($this, srcPath, givenPath) {
	var searchPaths;
	var i;
	var path;
	var lastSlashAt;
	var path$0;
	var path$1;
	if (givenPath.match(/^\.{1,2}\//) == null) {
		searchPaths = $this._searchPaths.concat($this._emitter.getSearchPaths$());
		for (i = 0; i < searchPaths.length; ++ i) {
			path$0 = searchPaths[i] + "/" + givenPath;
			path = Util$_resolvedPathParts$S(path$0).join("/");
			if ($this._platform.fileExists$S(path)) {
				return path;
			}
		}
	}
	lastSlashAt = srcPath.lastIndexOf("/");
	path$1 = (lastSlashAt !== -1 ? srcPath.substring(0, lastSlashAt + 1) : "") + givenPath;
	path = Util$_resolvedPathParts$S(path$1).join("/");
	return path;
};

Compiler._resolvePath$LCompiler$SS = Compiler$_resolvePath$LCompiler$SS;

function _Util() {
};

$__jsx_extend([_Util], Object);
function _Util$handleSubStatements$F$ALStatement$B$LStatement$(cb, statement) {
	var ret;
	ret = false;
	if (statement instanceof ContinuableStatement) {
		if (cb(statement.getStatements$())) {
			ret = true;
		}
	} else {
		if (statement instanceof IfStatement) {
			if (cb(statement._onTrueStatements)) {
				ret = true;
			}
			if (cb(statement._onFalseStatements)) {
				ret = true;
			}
		} else {
			if (statement instanceof SwitchStatement) {
				if (cb(statement._statements)) {
					ret = true;
				}
			} else {
				if (statement instanceof TryStatement) {
					if (cb(statement._tryStatements)) {
						ret = true;
					}
					if (cb(statement._catchStatements.map((function (s) {
						return s;
					})))) {
						ret = true;
					}
					if (cb(statement._finallyStatements)) {
						ret = true;
					}
				} else {
					if (statement instanceof CatchStatement) {
						if (cb(statement._statements)) {
							ret = true;
						}
					}
				}
			}
		}
	}
	return ret;
};

_Util.handleSubStatements$F$ALStatement$B$LStatement$ = _Util$handleSubStatements$F$ALStatement$B$LStatement$;

function _Util$classIsNative$LClassDefinition$(classDef) {
	return ! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(classDef, (function (classDef) {
		return (classDef.className$() === "Object" || (classDef.flags$() & 16) === 0 ? true : false);
	}));
};

_Util.classIsNative$LClassDefinition$ = _Util$classIsNative$LClassDefinition$;

function _Util$exprHasSideEffects$LExpression$(expr) {
	var onExpr;
	function onExpr(expr, _) {
		var callingFuncDef;
		var type;
		if (expr instanceof NewExpression || expr instanceof AssignmentExpression || expr instanceof PreIncrementExpression || expr instanceof PostIncrementExpression || expr instanceof SuperExpression) {
			return false;
		} else {
			if (expr instanceof CallExpression) {
				callingFuncDef = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr);
				if (callingFuncDef != null && (callingFuncDef._flags & 2048) !== 0) {
				} else {
					return false;
				}
			} else {
				if (expr instanceof PropertyExpression) {
					type = expr._expr.getType$();
					if (type instanceof ObjectType && (type._classDef.flags$() & 16) !== 0 && ! Util$isBuiltInContainer$LType$(type)) {
						return false;
					}
				} else {
					if (expr instanceof ArrayExpression) {
						type = expr._expr1.getType$();
						if (type instanceof ObjectType && (type._classDef.flags$() & 16) !== 0 && ! Util$isBuiltInContainer$LType$(type)) {
							return false;
						}
					}
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}
	return ! onExpr(expr, null);
};

_Util.exprHasSideEffects$LExpression$ = _Util$exprHasSideEffects$LExpression$;

function _Util$conditionIsConstant$LExpression$(expr) {
	var leafIsConstant;
	var asExpr;
	function leafIsConstant(expr) {
		if (expr instanceof NullExpression) {
			return false;
		} else {
			if (expr instanceof BooleanLiteralExpression) {
				return expr._token._value === "true";
			} else {
				if (expr instanceof StringLiteralExpression) {
					return expr._token._value.length > 2;
				} else {
					if (expr instanceof NumberLiteralExpression || expr instanceof IntegerLiteralExpression) {
						return !! (+expr._token._value);
					} else {
						if (expr instanceof MapLiteralExpression || expr instanceof ArrayLiteralExpression) {
							return true;
						}
					}
				}
			}
		}
		return null;
	}
	if (expr instanceof LeafExpression) {
		return leafIsConstant(expr);
	} else {
		if (expr instanceof AsExpression) {
			asExpr = expr;
			return (asExpr._type.equals$LType$(Type.booleanType) ? leafIsConstant(asExpr._expr) : null);
		} else {
			return null;
		}
	}
};

_Util.conditionIsConstant$LExpression$ = _Util$conditionIsConstant$LExpression$;

function _Util$optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$(funcDef, optimizeExpressions) {
	var optimizeStatements;
	var statements;
	function optimizeStatements(statements) {
		var statementIndex;
		var exprsToOptimize;
		var setOptimizedExprs;
		var statement;
		var expr;
		var i;
		statementIndex = 0;
		while (statementIndex < statements.length) {
			exprsToOptimize = [];
			setOptimizedExprs = [];
			while (statementIndex < statements.length) {
				statement = statements[statementIndex++];
				if (statement instanceof ExpressionStatement) {
					exprsToOptimize.push(statement._expr);
					setOptimizedExprs.push((function (statement) {
						return (function (expr) {
							UnaryExpressionStatement$setExpr$LUnaryExpressionStatement$LExpression$(statement, expr);
						});
					})(statement));
				} else {
					if (statement instanceof ReturnStatement) {
						expr = statement._expr;
						if (expr != null) {
							exprsToOptimize.push(statement._expr);
							setOptimizedExprs.push((function (statement) {
								return (function (expr) {
									ReturnStatement$setExpr$LReturnStatement$LExpression$(statement, expr);
								});
							})(statement));
						}
						break;
					} else {
						statement.handleStatements$F$ALStatement$B$((function (statements) {
							optimizeStatements(statements);
							return true;
						}));
						if (statement instanceof IfStatement) {
							exprsToOptimize.push(statement._expr);
							setOptimizedExprs.push((function (statement) {
								return (function (expr) {
									IfStatement$setExpr$LIfStatement$LExpression$(statement, expr);
								});
							})(statement));
						} else {
							if (statement instanceof SwitchStatement) {
								exprsToOptimize.push(statement._expr);
								setOptimizedExprs.push((function (statement) {
									return (function (expr) {
										SwitchStatement$setExpr$LSwitchStatement$LExpression$(statement, expr);
									});
								})(statement));
							}
						}
						break;
					}
				}
			}
			if (exprsToOptimize.length !== 0) {
				optimizeExpressions(exprsToOptimize);
				for (i = 0; i < exprsToOptimize.length; ++ i) {
					setOptimizedExprs[i](exprsToOptimize[i]);
				}
			}
		}
	}
	statements = funcDef._statements;
	if (statements != null) {
		optimizeStatements(statements);
	}
};

_Util.optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$ = _Util$optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$;

function Optimizer() {
	this._compiler = null;
	this._commands = [];
	this._log = "";
	this._dumpLogs = false;
	this._enableRunTimeTypeCheck = true;
};

$__jsx_extend([Optimizer], Object);
function Optimizer$getReleaseOptimizationCommands$() {
	return [ "lto", "no-assert", "no-log", "no-debug", "fold-const", "return-if", "inline", "dce", "unbox", "fold-const", "lcse", "dce", "fold-const", "array-length", "unclassify", "staticize" ];
};

Optimizer.getReleaseOptimizationCommands$ = Optimizer$getReleaseOptimizationCommands$;

function Optimizer$setup$LOptimizer$AS($this, cmds) {
	var calleesAreDetermined;
	var determineCallee;
	var i;
	var cmd;
	var _commands$0;
	calleesAreDetermined = false;
	function determineCallee() {
		if (! calleesAreDetermined) {
			$this._commands.push(new _DetermineCalleeCommand());
			calleesAreDetermined = true;
		}
	}
	for (i = 0; i < cmds.length; ++ i) {
		cmd = cmds[i];
		if (cmd === "lto") {
			$this._commands.push(new _LinkTimeOptimizationCommand());
		} else {
			if (cmd === "no-assert") {
				$this._commands.push(new _NoAssertCommand());
			} else {
				if (cmd === "no-log") {
					$this._commands.push(new _NoLogCommand());
				} else {
					if (cmd === "no-debug") {
						$this._commands.push(new _NoDebugCommand());
					} else {
						if (cmd === "strip") {
							$this._commands.push(new _StripOptimizeCommand());
						} else {
							if (cmd === "staticize") {
								$this._commands.push(new _StaticizeOptimizeCommand());
								calleesAreDetermined = false;
							} else {
								if (cmd === "unclassify") {
									$this._commands.push(new _UnclassifyOptimizationCommand());
									calleesAreDetermined = false;
								} else {
									if (cmd === "fold-const") {
										$this._commands.push(new _FoldConstantCommand());
									} else {
										if (cmd === "dce") {
											determineCallee();
											$this._commands.push(new _DeadCodeEliminationOptimizeCommand());
										} else {
											if (cmd === "inline") {
												determineCallee();
												$this._commands.push(new _InlineOptimizeCommand());
											} else {
												if (cmd === "return-if") {
													$this._commands.push(new _ReturnIfOptimizeCommand());
												} else {
													if (cmd === "lcse") {
														$this._commands.push(new _LCSEOptimizeCommand());
													} else {
														if (cmd === "unbox") {
															determineCallee();
															$this._commands.push(new _UnboxOptimizeCommand());
														} else {
															if (cmd === "array-length") {
																$this._commands.push(new _ArrayLengthOptimizeCommand());
															} else {
																if (cmd === "dump-logs") {
																	$this._dumpLogs = true;
																} else {
																	return "unknown optimization command: " + cmd;
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	for (i = 0; i < $this._commands.length; ++ i) {
		if ($this._commands[i] instanceof _LinkTimeOptimizationCommand) {
			break;
		}
	}
	if (i !== $this._commands.length) {
		(_commands$0 = $this._commands).unshift(_commands$0.splice(i, 1)[0]);
	}
	return null;
};

Optimizer.setup$LOptimizer$AS = Optimizer$setup$LOptimizer$AS;

function Optimizer$enableRuntimeTypeCheck$LOptimizer$($this) {
	return $this._enableRunTimeTypeCheck;
};

Optimizer.enableRuntimeTypeCheck$LOptimizer$ = Optimizer$enableRuntimeTypeCheck$LOptimizer$;

function Optimizer$setEnableRunTimeTypeCheck$LOptimizer$B($this, mode) {
	$this._enableRunTimeTypeCheck = mode;
};

Optimizer.setEnableRunTimeTypeCheck$LOptimizer$B = Optimizer$setEnableRunTimeTypeCheck$LOptimizer$B;

function Optimizer$setCompiler$LOptimizer$LCompiler$($this, compiler) {
	$this._compiler = compiler;
	return $this;
};

Optimizer.setCompiler$LOptimizer$LCompiler$ = Optimizer$setCompiler$LOptimizer$LCompiler$;

function Optimizer$getCompiler$LOptimizer$($this) {
	return $this._compiler;
};

Optimizer.getCompiler$LOptimizer$ = Optimizer$getCompiler$LOptimizer$;

function Optimizer$performOptimization$LOptimizer$($this) {
	var i;
	var platform;
	var message$0;
	var message$1;
	var s$0;
	var _commands$0;
	for (i = 0; i < $this._commands.length; ++ i) {
		try {
			message$0 = "starting optimizer: " + (_commands$0 = $this._commands)[i]._identifier;
			$this._log += message$0 + "\n";
			_OptimizeCommand$setup$L_OptimizeCommand$LOptimizer$(_commands$0[i], $this).performOptimization$();
			message$1 = "finished optimizer: " + $this._commands[i]._identifier;
			$this._log += message$1 + "\n";
		} catch ($__jsx_catch_0) {
			if ($__jsx_catch_0 instanceof Error) {
				platform = $this._compiler._platform;
				platform.error$S("fatal error: optimizer '" + $this._commands[i]._identifier + "' died unexpectedly, dumping the logs" + $this._log);
				throw $__jsx_catch_0;
			} else {
				throw $__jsx_catch_0;
			}
		}
	}
	if ($this._dumpLogs) {
		platform = $this._compiler._platform;
		s$0 = $this._log;
		console.warn(s$0);
	}
};

Optimizer.performOptimization$LOptimizer$ = Optimizer$performOptimization$LOptimizer$;

function Optimizer$log$LOptimizer$S($this, message) {
	$this._log += message + "\n";
};

Optimizer.log$LOptimizer$S = Optimizer$log$LOptimizer$S;

function Optimizer$dumpLogs$LOptimizer$($this) {
	return $this._log;
};

Optimizer.dumpLogs$LOptimizer$ = Optimizer$dumpLogs$LOptimizer$;

function _OptimizeCommand(identifier) {
	this._identifier = identifier;
	this._optimizer = null;
};

$__jsx_extend([_OptimizeCommand], Object);
_OptimizeCommand.prototype.setup$LOptimizer$ = function (optimizer) {
	this._optimizer = optimizer;
	return this;
};


function _OptimizeCommand$setup$L_OptimizeCommand$LOptimizer$($this, optimizer) {
	$this._optimizer = optimizer;
	return $this;
};

_OptimizeCommand.setup$L_OptimizeCommand$LOptimizer$ = _OptimizeCommand$setup$L_OptimizeCommand$LOptimizer$;

_OptimizeCommand.prototype.getCompiler$ = function () {
	return this._optimizer._compiler;
};


function _OptimizeCommand$getCompiler$L_OptimizeCommand$($this) {
	return $this._optimizer._compiler;
};

_OptimizeCommand.getCompiler$L_OptimizeCommand$ = _OptimizeCommand$getCompiler$L_OptimizeCommand$;

_OptimizeCommand.prototype.getStash$LStashable$ = function (stashable) {
	var stash;
	stash = stashable.getStash$S(this._identifier);
	if (stash == null) {
		stash = stashable.setStash$SLStash$(this._identifier, this._createStash$());
	}
	return stash;
};


function _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, stashable) {
	var stash;
	stash = stashable.getStash$S($this._identifier);
	if (stash == null) {
		stash = stashable.setStash$SLStash$($this._identifier, $this._createStash$());
	}
	return stash;
};

_OptimizeCommand.getStash$L_OptimizeCommand$LStashable$ = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$;

_OptimizeCommand.prototype._createStash$ = function () {
	throw new Error("if you are going to use the stash, you need to override this function");
};


_OptimizeCommand.prototype.resetStash$LStashable$ = function (stashable) {
	stashable.setStash$SLStash$(this._identifier, null);
};


function _OptimizeCommand$resetStash$L_OptimizeCommand$LStashable$($this, stashable) {
	stashable.setStash$SLStash$($this._identifier, null);
};

_OptimizeCommand.resetStash$L_OptimizeCommand$LStashable$ = _OptimizeCommand$resetStash$L_OptimizeCommand$LStashable$;

_OptimizeCommand.prototype.createVar$LMemberFunctionDefinition$LType$S = function (funcDef, type, baseName) {
	var $this = this;
	var locals;
	var nameExists;
	var i;
	var newLocal;
	var message$0;
	var message$0$0;
	locals = funcDef._locals;
	function nameExists(n) {
		var i;
		var locals$len$0;
		for ((i = 0, locals$len$0 = locals.length); i < locals$len$0; ++ i) {
			if (locals[i]._name._value === n) {
				return true;
			}
		}
		return false;
	}
	for (i = 0; nameExists(baseName + "$" + (i + "")); ++ i) {
	}
	newLocal = new LocalVariable(new Token$1(baseName + "$" + (i + ""), false), type);
	locals.push(newLocal);
	message$0 = "rewriting " + baseName + " to " + newLocal._name._value;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	return newLocal;
};


function _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, type, baseName) {
	var locals;
	var nameExists;
	var i;
	var newLocal;
	var message$0;
	var message$0$0;
	locals = funcDef._locals;
	function nameExists(n) {
		var i;
		var locals$len$0;
		for ((i = 0, locals$len$0 = locals.length); i < locals$len$0; ++ i) {
			if (locals[i]._name._value === n) {
				return true;
			}
		}
		return false;
	}
	for (i = 0; nameExists(baseName + "$" + (i + "")); ++ i) {
	}
	newLocal = new LocalVariable(new Token$1(baseName + "$" + (i + ""), false), type);
	locals.push(newLocal);
	message$0 = "rewriting " + baseName + " to " + newLocal._name._value;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	$this._optimizer._log += message$0$0 + "\n";
	return newLocal;
};

_OptimizeCommand.createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S;

_OptimizeCommand.prototype.log$S = function (message) {
	var message$0;
	message$0 = "[" + this._identifier + "] " + message;
	this._optimizer._log += message$0 + "\n";
};


function _OptimizeCommand$log$L_OptimizeCommand$S($this, message) {
	var message$0;
	message$0 = "[" + $this._identifier + "] " + message;
	$this._optimizer._log += message$0 + "\n";
};

_OptimizeCommand.log$L_OptimizeCommand$S = _OptimizeCommand$log$L_OptimizeCommand$S;

_OptimizeCommand.prototype.setupCommand$L_OptimizeCommand$ = function (command) {
	var optimizer$0;
	optimizer$0 = this._optimizer;
	command._optimizer = optimizer$0;
	return command;
};


function _OptimizeCommand$setupCommand$L_OptimizeCommand$L_OptimizeCommand$($this, command) {
	var optimizer$0;
	optimizer$0 = $this._optimizer;
	command._optimizer = optimizer$0;
	return command;
};

_OptimizeCommand.setupCommand$L_OptimizeCommand$L_OptimizeCommand$ = _OptimizeCommand$setupCommand$L_OptimizeCommand$L_OptimizeCommand$;

function _FunctionOptimizeCommand(identifier) {
	this._identifier = identifier;
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_FunctionOptimizeCommand], _OptimizeCommand);
_FunctionOptimizeCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var doit;
	function doit(funcDef) {
		var message$0;
		var message$0$0;
		var message$1;
		var message$0$1;
		message$0 = "starting optimization of " + funcDef.getNotation$();
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		$this._optimizer._log += message$0$0 + "\n";
		$this.optimizeFunction$LMemberFunctionDefinition$(funcDef);
		message$1 = "finished optimization of " + funcDef.getNotation$();
		message$0$1 = "[" + $this._identifier + "] " + message$1;
		$this._optimizer._log += message$0$1 + "\n";
	}
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
			var funcDef;
			if (member instanceof MemberFunctionDefinition) {
				funcDef = member;
				if (MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef) != null) {
					doit(funcDef);
				}
			}
			MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(member, (function (funcDef) {
				doit(funcDef);
				return true;
			}));
			return true;
		}));
		return true;
	}));
};


function _LinkTimeOptimizationCommand() {
	this._identifier = "lto";
	this._optimizer = null;
};

$__jsx_extend([_LinkTimeOptimizationCommand], _OptimizeCommand);
_LinkTimeOptimizationCommand.prototype._createStash$ = function () {
	return new _LinkTimeOptimizationCommand$x2EStash();
};


_LinkTimeOptimizationCommand.prototype.performOptimization$ = function () {
	var $this = this;
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		var i;
		if (classDef._extendType != null) {
			_OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, classDef._extendType._classDef).extendedBy.push(classDef);
		}
		for (i = 0; i < classDef._implementTypes.length; ++ i) {
			_OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, classDef._implementTypes[i]._classDef).extendedBy.push(classDef);
		}
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		var message$0;
		var message$0$0;
		if ((classDef.flags$() & 16596) === 0 && _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, classDef).extendedBy.length === 0) {
			message$0 = "marking class as final: " + classDef.className$();
			message$0$0 = "[" + $this._identifier + "] " + message$0;
			$this._optimizer._log += message$0$0 + "\n";
			ClassDefinition$setFlags$LClassDefinition$N(classDef, classDef.flags$() | 4);
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_FINAL)) === 0) {
					MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_FINAL);
				}
				return true;
			}));
		} else {
			if ((classDef.flags$() & 20) === 0) {
				ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
					var overrides;
					if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_NATIVE | ClassDefinition.IS_FINAL)) !== 0) {
					} else {
						if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_ABSTRACT) === 0) {
							if (MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef) == null) {
								throw new Error("a non-native, non-abstract function with out function body?");
							}
							overrides = _LinkTimeOptimizationCommand$_getOverrides$L_LinkTimeOptimizationCommand$LClassDefinition$ALClassDefinition$SALType$($this, classDef, _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, classDef).extendedBy, MemberDefinition$name$LMemberDefinition$(funcDef), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef));
							if (overrides.length === 0) {
								_OptimizeCommand$log$L_OptimizeCommand$S($this, "marking function as final: " + funcDef.getNotation$());
								MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_FINAL);
							} else {
								_OptimizeCommand$log$L_OptimizeCommand$S($this, "function has overrides, not marking as final: " + funcDef.getNotation$());
							}
						} else {
							if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_ABSTRACT) !== 0) {
							}
						}
					}
					return true;
				}));
			}
		}
		return true;
	}));
};


_LinkTimeOptimizationCommand.prototype._getOverrides$LClassDefinition$ALClassDefinition$SALType$ = function (srcClassDef, classDefs, name, argTypes) {
	var overrides;
	var i;
	overrides = [];
	for (i = 0; i < classDefs.length; ++ i) {
		overrides = overrides.concat(_LinkTimeOptimizationCommand$_getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$(this, srcClassDef, classDefs[i], name, argTypes));
	}
	return overrides;
};


function _LinkTimeOptimizationCommand$_getOverrides$L_LinkTimeOptimizationCommand$LClassDefinition$ALClassDefinition$SALType$($this, srcClassDef, classDefs, name, argTypes) {
	var overrides;
	var i;
	overrides = [];
	for (i = 0; i < classDefs.length; ++ i) {
		overrides = overrides.concat(_LinkTimeOptimizationCommand$_getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$($this, srcClassDef, classDefs[i], name, argTypes));
	}
	return overrides;
};

_LinkTimeOptimizationCommand._getOverrides$L_LinkTimeOptimizationCommand$LClassDefinition$ALClassDefinition$SALType$ = _LinkTimeOptimizationCommand$_getOverrides$L_LinkTimeOptimizationCommand$LClassDefinition$ALClassDefinition$SALType$;

_LinkTimeOptimizationCommand.prototype._getOverridesByClass$LClassDefinition$LClassDefinition$SALType$ = function (srcClassDef, classDef, name, argTypes) {
	var $this = this;
	var overrides;
	var addOverride;
	var implementClassDefs;
	var i;
	overrides = _LinkTimeOptimizationCommand$_getOverrides$L_LinkTimeOptimizationCommand$LClassDefinition$ALClassDefinition$SALType$(this, srcClassDef, _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$(this, classDef).extendedBy, name, argTypes);
	function addOverride(funcDef) {
		if (funcDef._nameToken._value === name && (funcDef._flags & 2) === 0 && Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), argTypes)) {
			overrides.push(funcDef);
			return false;
		}
		return true;
	}
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, addOverride);
	implementClassDefs = classDef._implementTypes.map((function (type) {
		return type._classDef;
	}));
	for (i = 0; i < implementClassDefs.length; ++ i) {
		if (srcClassDef != implementClassDefs[i]) {
			ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(implementClassDefs[i], (function (classDef) {
				return ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, addOverride);
			}));
		}
	}
	return overrides;
};


function _LinkTimeOptimizationCommand$_getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$($this, srcClassDef, classDef, name, argTypes) {
	var overrides;
	var addOverride;
	var implementClassDefs;
	var i;
	overrides = _LinkTimeOptimizationCommand$_getOverrides$L_LinkTimeOptimizationCommand$LClassDefinition$ALClassDefinition$SALType$($this, srcClassDef, _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, classDef).extendedBy, name, argTypes);
	function addOverride(funcDef) {
		if (funcDef._nameToken._value === name && (funcDef._flags & 2) === 0 && Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), argTypes)) {
			overrides.push(funcDef);
			return false;
		}
		return true;
	}
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, addOverride);
	implementClassDefs = classDef._implementTypes.map((function (type) {
		return type._classDef;
	}));
	for (i = 0; i < implementClassDefs.length; ++ i) {
		if (srcClassDef != implementClassDefs[i]) {
			ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(implementClassDefs[i], (function (classDef) {
				return ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, addOverride);
			}));
		}
	}
	return overrides;
};

_LinkTimeOptimizationCommand._getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$ = _LinkTimeOptimizationCommand$_getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$;

function _StripOptimizeCommand() {
	this._identifier = "strip";
	this._optimizer = null;
	this._classesInstantiated = [];
	this._methodsAlive = {};
	this._membersToWalk = [];
};

$__jsx_extend([_StripOptimizeCommand], _OptimizeCommand);
_StripOptimizeCommand.prototype._createStash$ = function () {
	return new _StripOptimizeCommand$x2E_Stash();
};


_StripOptimizeCommand.prototype._touchStatic$LMemberDefinition$ = function (member) {
	var stash;
	var message$0;
	var message$0$0;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$(this, member);
	if (stash.touched) {
		return;
	}
	message$0 = "touched " + member.getNotation$();
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	stash.touched = true;
	this._membersToWalk.push(member);
};


function _StripOptimizeCommand$_touchStatic$L_StripOptimizeCommand$LMemberDefinition$($this, member) {
	var stash;
	var message$0;
	var message$0$0;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, member);
	if (stash.touched) {
		return;
	}
	message$0 = "touched " + member.getNotation$();
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	$this._optimizer._log += message$0$0 + "\n";
	stash.touched = true;
	$this._membersToWalk.push(member);
};

_StripOptimizeCommand._touchStatic$L_StripOptimizeCommand$LMemberDefinition$ = _StripOptimizeCommand$_touchStatic$L_StripOptimizeCommand$LMemberDefinition$;

_StripOptimizeCommand.prototype._touchInstance$LClassDefinition$ = function (classDef) {
	var $this = this;
	var stash;
	var name;
	var listOfArgTypes;
	var i;
	var funcDef;
	var message$0;
	var message$0$0;
	var this$0;
	var i$0;
	var implementType$0;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$(this, classDef);
	if (stash.touched) {
		return;
	}
	message$0 = "touched " + classDef.className$();
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	stash.touched = true;
	this._classesInstantiated.push(classDef);
	for (name in this._methodsAlive) {
		listOfArgTypes = this._methodsAlive[name];
		for (i = 0; i !== listOfArgTypes.length; ++ i) {
			funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, listOfArgTypes[i], false);
			if (funcDef != null) {
				this._membersToWalk.push(funcDef);
			}
		}
	}
	if (classDef._extendType != null) {
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$(this, classDef._extendType._classDef);
	}
	this$0 = classDef._implementTypes;
	for (i$0 in this$0) {
		implementType$0 = this$0[i$0];
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$(this, implementType$0._classDef);
	}
	if (classDef._outerClassDef != null) {
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$(this, classDef._outerClassDef);
	}
};


function _StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, classDef) {
	var stash;
	var name;
	var listOfArgTypes;
	var i;
	var funcDef;
	var message$0;
	var message$0$0;
	var this$0;
	var i$0;
	var implementType$0;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, classDef);
	if (stash.touched) {
		return;
	}
	message$0 = "touched " + classDef.className$();
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	$this._optimizer._log += message$0$0 + "\n";
	stash.touched = true;
	$this._classesInstantiated.push(classDef);
	for (name in $this._methodsAlive) {
		listOfArgTypes = $this._methodsAlive[name];
		for (i = 0; i !== listOfArgTypes.length; ++ i) {
			funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, listOfArgTypes[i], false);
			if (funcDef != null) {
				$this._membersToWalk.push(funcDef);
			}
		}
	}
	if (classDef._extendType != null) {
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, classDef._extendType._classDef);
	}
	this$0 = classDef._implementTypes;
	for (i$0 in this$0) {
		implementType$0 = this$0[i$0];
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, implementType$0._classDef);
	}
	if (classDef._outerClassDef != null) {
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, classDef._outerClassDef);
	}
};

_StripOptimizeCommand._touchInstance$L_StripOptimizeCommand$LClassDefinition$ = _StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$;

_StripOptimizeCommand.prototype._touchConstructor$LMemberFunctionDefinition$ = function (funcDef) {
	var stash;
	var message$0;
	var message$0$0;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$(this, funcDef);
	if (stash.touched) {
		return;
	}
	message$0 = "touched " + funcDef.getNotation$();
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	stash.touched = true;
	this._membersToWalk.push(funcDef);
	_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$(this, funcDef._classDef);
};


function _StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var stash;
	var message$0;
	var message$0$0;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, funcDef);
	if (stash.touched) {
		return;
	}
	message$0 = "touched " + funcDef.getNotation$();
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	$this._optimizer._log += message$0$0 + "\n";
	stash.touched = true;
	$this._membersToWalk.push(funcDef);
	_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, funcDef._classDef);
};

_StripOptimizeCommand._touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$ = _StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$;

_StripOptimizeCommand.prototype._touchMethod$SALType$ = function (name, argTypes) {
	var listOfArgTypes;
	var i;
	var funcDef;
	var message$0;
	var message$0$0;
	if ($__jsx_ObjectHasOwnProperty.call(this._methodsAlive, name)) {
		listOfArgTypes = this._methodsAlive[name];
	} else {
		listOfArgTypes = this._methodsAlive[name] = [];
	}
	for (i = 0; i < listOfArgTypes.length; ++ i) {
		if (Util$typesAreEqual$ALType$ALType$(listOfArgTypes[i], argTypes)) {
			return;
		}
	}
	message$0 = "touched #" + name;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	listOfArgTypes.push(argTypes.concat());
	for (i = 0; i < this._classesInstantiated.length; ++ i) {
		funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B(this._classesInstantiated[i], name, argTypes, false);
		if (funcDef != null) {
			this._membersToWalk.push(funcDef);
		}
	}
};


function _StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, name, argTypes) {
	var listOfArgTypes;
	var i;
	var funcDef;
	var message$0;
	var message$0$0;
	if ($__jsx_ObjectHasOwnProperty.call($this._methodsAlive, name)) {
		listOfArgTypes = $this._methodsAlive[name];
	} else {
		listOfArgTypes = $this._methodsAlive[name] = [];
	}
	for (i = 0; i < listOfArgTypes.length; ++ i) {
		if (Util$typesAreEqual$ALType$ALType$(listOfArgTypes[i], argTypes)) {
			return;
		}
	}
	message$0 = "touched #" + name;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	$this._optimizer._log += message$0$0 + "\n";
	listOfArgTypes.push(argTypes.concat());
	for (i = 0; i < $this._classesInstantiated.length; ++ i) {
		funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B($this._classesInstantiated[i], name, argTypes, false);
		if (funcDef != null) {
			$this._membersToWalk.push(funcDef);
		}
	}
};

_StripOptimizeCommand._touchMethod$L_StripOptimizeCommand$SALType$ = _StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$;

_StripOptimizeCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var isEmittedClass;
	var member;
	var memberShouldPreserve;
	var message$0;
	var message$0$0;
	var this$0;
	var i$0;
	function isEmittedClass(classDef) {
		return (classDef instanceof TemplateClassDefinition ? false : (classDef.flags$() & 16) !== 0 ? false : true);
	}
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		classDef.setStash$SLStash$($this._identifier, null);
		return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
			_OptimizeCommand$resetStash$L_OptimizeCommand$LStashable$($this, member);
			return true;
		}));
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		if (! (classDef instanceof TemplateClassDefinition) && (classDef.flags$() & 16) !== 0) {
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if (MemberDefinition$name$LMemberDefinition$(funcDef) === "constructor") {
				} else {
					if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_FINAL) !== 0) {
					} else {
						_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, MemberDefinition$name$LMemberDefinition$(funcDef), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef));
					}
				}
				return true;
			}));
		}
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		if (isEmittedClass(classDef)) {
			if ((classDef.flags$() & 16384) !== 0) {
				_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, classDef);
			}
			ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				var funcDef;
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_EXPORT) !== 0) {
					if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_STATIC) !== 0) {
						_StripOptimizeCommand$_touchStatic$L_StripOptimizeCommand$LMemberDefinition$($this, member);
					} else {
						if (member instanceof MemberFunctionDefinition) {
							funcDef = member;
							if (MemberDefinition$name$LMemberDefinition$(funcDef) === "constructor") {
								_StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
							} else {
								_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, MemberDefinition$name$LMemberDefinition$(funcDef), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef));
							}
						}
					}
				}
				return true;
			}));
		}
		return true;
	}));
	while (this._membersToWalk.length !== 0) {
		member = this._membersToWalk.shift();
		message$0 = "walking " + member.getNotation$();
		message$0$0 = "[" + this._identifier + "] " + message$0;
		this._optimizer._log += message$0$0 + "\n";
		if (member instanceof MemberFunctionDefinition) {
			_StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$(this, member);
		} else {
			_StripOptimizeCommand$_walkVariableDefinition$L_StripOptimizeCommand$LMemberVariableDefinition$(this, member);
		}
	}
	function memberShouldPreserve(member) {
		var isTouched;
		var listOfArgTypes;
		var i;
		if ((member._flags & 16384) !== 0) {
			return true;
		}
		isTouched = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, member).touched;
		if ((member._flags & 8) !== 0) {
			return isTouched;
		} else {
			if (member instanceof MemberFunctionDefinition) {
				if (member._nameToken._value === "constructor") {
					return isTouched;
				} else {
					if (_OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, member._classDef).touched && $__jsx_ObjectHasOwnProperty.call($this._methodsAlive, member._nameToken._value)) {
						listOfArgTypes = $this._methodsAlive[member._nameToken._value];
						for (i = 0; i !== listOfArgTypes.length; ++ i) {
							if (Util$typesAreEqual$ALType$ALType$(listOfArgTypes[i], MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member))) {
								return true;
							}
						}
					}
					return false;
				}
			} else {
				return true;
			}
		}
	}
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		var numConstructors;
		var members;
		var memberIndex;
		var member;
		var ctor;
		var message$0;
		var message$0$0;
		var message$1;
		var message$0$1;
		var message$2;
		var message$0$2;
		if (isEmittedClass(classDef)) {
			numConstructors = 0;
			members = classDef._members;
			for (memberIndex = 0; memberIndex !== members.length; ) {
				member = members[memberIndex];
				if (memberShouldPreserve(member)) {
					if (member instanceof MemberFunctionDefinition && (member._flags & 8) === 0 && member._nameToken._value === "constructor") {
						++ numConstructors;
					}
					++ memberIndex;
					message$0 = "preserving used: " + member.getNotation$();
					message$0$0 = "[" + $this._identifier + "] " + message$0;
					$this._optimizer._log += message$0$0 + "\n";
				} else {
					message$1 = "removing unused: " + member.getNotation$();
					message$0$1 = "[" + $this._identifier + "] " + message$1;
					$this._optimizer._log += message$0$1 + "\n";
					members.splice(memberIndex, 1);
				}
			}
			if (numConstructors === 0) {
				message$2 = "substituting fake constructor for class: " + classDef.className$();
				message$0$2 = "[" + $this._identifier + "] " + message$2;
				$this._optimizer._log += message$0$2 + "\n";
				ctor = new MemberFunctionDefinition(null, new Token$1("constructor", true), 4 | classDef.flags$() & 16384, Type.voidType, [], [], [], [], classDef.getToken$(), null);
				ctor._classDef = classDef;
				members.push(ctor);
			}
		}
		return true;
	}));
	this$0 = this._optimizer._compiler._parsers;
	for (i$0 in this$0) {
		(function (parser) {
			var classDefs;
			var i;
			var preserve;
			var message$0;
			var message$0$0;
			classDefs = parser._classDefs;
			for (i = 0; i !== classDefs.length; ) {
				preserve = true;
				if ((classDefs[i].flags$() & 16) !== 0 && classDefs[i]._nativeSource != null && ! _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, classDefs[i]).touched && ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDefs[i], (function (member) {
					if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_STATIC) === 0) {
						return true;
					}
					return ! _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, member).touched;
				}))) {
					preserve = false;
				}
				if (preserve) {
					++ i;
				} else {
					message$0 = "removing unused native class: " + classDefs[i].className$();
					message$0$0 = "[" + $this._identifier + "] " + message$0;
					$this._optimizer._log += message$0$0 + "\n";
					classDefs.splice(i, 1);
				}
			}
		})(this$0[i$0]);
	}
};


_StripOptimizeCommand.prototype._walkExpression$LExpression$ = function (expr) {
	var $this = this;
	var onExpr;
	function onExpr(expr) {
		var callee;
		var propertyExpr;
		var holderClassDef;
		var name;
		var member;
		var superExpr;
		var this$0;
		var exprType$0;
		var getArgumentTypes$this$0;
		var exprType$1;
		var getArgumentTypes$this$1;
		if (expr instanceof NewExpression) {
			callee = Util$findFunctionInClass$LClassDefinition$SALType$B(expr.getType$().getClassDef$(), "constructor", expr._constructor._argTypes, false);
			_StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, callee);
		} else {
			if (expr instanceof InstanceofExpression) {
				_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, expr._expectedType.getClassDef$());
			} else {
				if (expr instanceof AsExpression) {
					if (expr.getType$() instanceof ObjectType) {
						_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, expr.getType$().getClassDef$());
					}
				} else {
					if (expr instanceof AsNoConvertExpression) {
						if (expr.getType$() instanceof ObjectType) {
							_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, expr.getType$().getClassDef$());
						}
					} else {
						if (expr instanceof PropertyExpression) {
							propertyExpr = expr;
							holderClassDef = propertyExpr.getHolderType$().getClassDef$();
							if (propertyExpr._isInner) {
								if ((holderClassDef.flags$() & 16) !== 0) {
									_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, holderClassDef);
								}
							} else {
								this$0 = propertyExpr._identifierToken;
								name = this$0._value;
								if (propertyExpr._expr.isClassSpecifier$()) {
									exprType$0 = propertyExpr._type;
									if (! (exprType$0 instanceof FunctionType) ? false : exprType$0.isAssignable$() ? false : true) {
										member = Util$findFunctionInClass$LClassDefinition$SALType$B(holderClassDef, name, (getArgumentTypes$this$0 = expr.getType$(), getArgumentTypes$this$0._argTypes), true);
									} else {
										member = Util$findVariableInClass$LClassDefinition$SB(holderClassDef, name, true);
									}
									_StripOptimizeCommand$_touchStatic$L_StripOptimizeCommand$LMemberDefinition$($this, member);
								} else {
									exprType$1 = propertyExpr._type;
									if (! (exprType$1 instanceof FunctionType) ? false : exprType$1.isAssignable$() ? false : true) {
										_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, name, (getArgumentTypes$this$1 = expr.getType$(), getArgumentTypes$this$1._argTypes));
									}
								}
							}
						} else {
							if (expr instanceof SuperExpression) {
								superExpr = expr;
								_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, superExpr._name._value, superExpr._funcType._argTypes);
							}
						}
					}
				}
			}
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}
	return onExpr(expr);
};


function _StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$($this, expr) {
	var onExpr;
	function onExpr(expr) {
		var callee;
		var propertyExpr;
		var holderClassDef;
		var name;
		var member;
		var superExpr;
		var this$0;
		var exprType$0;
		var getArgumentTypes$this$0;
		var exprType$1;
		var getArgumentTypes$this$1;
		if (expr instanceof NewExpression) {
			callee = Util$findFunctionInClass$LClassDefinition$SALType$B(expr.getType$().getClassDef$(), "constructor", expr._constructor._argTypes, false);
			_StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, callee);
		} else {
			if (expr instanceof InstanceofExpression) {
				_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, expr._expectedType.getClassDef$());
			} else {
				if (expr instanceof AsExpression) {
					if (expr.getType$() instanceof ObjectType) {
						_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, expr.getType$().getClassDef$());
					}
				} else {
					if (expr instanceof AsNoConvertExpression) {
						if (expr.getType$() instanceof ObjectType) {
							_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, expr.getType$().getClassDef$());
						}
					} else {
						if (expr instanceof PropertyExpression) {
							propertyExpr = expr;
							holderClassDef = propertyExpr.getHolderType$().getClassDef$();
							if (propertyExpr._isInner) {
								if ((holderClassDef.flags$() & 16) !== 0) {
									_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, holderClassDef);
								}
							} else {
								this$0 = propertyExpr._identifierToken;
								name = this$0._value;
								if (propertyExpr._expr.isClassSpecifier$()) {
									exprType$0 = propertyExpr._type;
									if (! (exprType$0 instanceof FunctionType) ? false : exprType$0.isAssignable$() ? false : true) {
										member = Util$findFunctionInClass$LClassDefinition$SALType$B(holderClassDef, name, (getArgumentTypes$this$0 = expr.getType$(), getArgumentTypes$this$0._argTypes), true);
									} else {
										member = Util$findVariableInClass$LClassDefinition$SB(holderClassDef, name, true);
									}
									_StripOptimizeCommand$_touchStatic$L_StripOptimizeCommand$LMemberDefinition$($this, member);
								} else {
									exprType$1 = propertyExpr._type;
									if (! (exprType$1 instanceof FunctionType) ? false : exprType$1.isAssignable$() ? false : true) {
										_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, name, (getArgumentTypes$this$1 = expr.getType$(), getArgumentTypes$this$1._argTypes));
									}
								}
							}
						} else {
							if (expr instanceof SuperExpression) {
								superExpr = expr;
								_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, superExpr._name._value, superExpr._funcType._argTypes);
							}
						}
					}
				}
			}
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}
	return onExpr(expr);
};

_StripOptimizeCommand._walkExpression$L_StripOptimizeCommand$LExpression$ = _StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$;

_StripOptimizeCommand.prototype._walkStatement$LStatement$ = function (statement) {
	var $this = this;
	var onStatement;
	function onStatement(statement) {
		var ctorStatement;
		var callee;
		if (statement instanceof ConstructorInvocationStatement) {
			ctorStatement = statement;
			callee = Util$findFunctionInClass$LClassDefinition$SALType$B(ctorStatement._ctorClassType.getClassDef$(), "constructor", ctorStatement._ctorFunctionType._argTypes, false);
			_StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, callee);
		}
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
			return _StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$($this, expr);
		}));
		return statement.forEachStatement$F$LStatement$B$(onStatement);
	}
	return onStatement(statement);
};


function _StripOptimizeCommand$_walkStatement$L_StripOptimizeCommand$LStatement$($this, statement) {
	var onStatement;
	function onStatement(statement) {
		var ctorStatement;
		var callee;
		if (statement instanceof ConstructorInvocationStatement) {
			ctorStatement = statement;
			callee = Util$findFunctionInClass$LClassDefinition$SALType$B(ctorStatement._ctorClassType.getClassDef$(), "constructor", ctorStatement._ctorFunctionType._argTypes, false);
			_StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, callee);
		}
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
			return _StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$($this, expr);
		}));
		return statement.forEachStatement$F$LStatement$B$(onStatement);
	}
	return onStatement(statement);
};

_StripOptimizeCommand._walkStatement$L_StripOptimizeCommand$LStatement$ = _StripOptimizeCommand$_walkStatement$L_StripOptimizeCommand$LStatement$;

_StripOptimizeCommand.prototype._walkFunctionDefinition$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	if (funcDef._statements != null) {
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			return _StripOptimizeCommand$_walkStatement$L_StripOptimizeCommand$LStatement$($this, statement);
		}), funcDef._statements);
	}
	return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, (function (funcDef) {
		return _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
	}));
};


function _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	if (funcDef._statements != null) {
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			return _StripOptimizeCommand$_walkStatement$L_StripOptimizeCommand$LStatement$($this, statement);
		}), funcDef._statements);
	}
	return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, (function (funcDef) {
		return _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
	}));
};

_StripOptimizeCommand._walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$ = _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$;

_StripOptimizeCommand.prototype._walkVariableDefinition$LMemberVariableDefinition$ = function (varDef) {
	var $this = this;
	var initialValue;
	initialValue = varDef._initialValue;
	if (initialValue != null) {
		_StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$(this, initialValue);
	}
	return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(varDef, (function (funcDef) {
		return _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
	}));
};


function _StripOptimizeCommand$_walkVariableDefinition$L_StripOptimizeCommand$LMemberVariableDefinition$($this, varDef) {
	var initialValue;
	initialValue = varDef._initialValue;
	if (initialValue != null) {
		_StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$($this, initialValue);
	}
	return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(varDef, (function (funcDef) {
		return _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
	}));
};

_StripOptimizeCommand._walkVariableDefinition$L_StripOptimizeCommand$LMemberVariableDefinition$ = _StripOptimizeCommand$_walkVariableDefinition$L_StripOptimizeCommand$LMemberVariableDefinition$;

function _NoAssertCommand() {
	this._identifier = "no-assert";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_NoAssertCommand], _FunctionOptimizeCommand);
_NoAssertCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	_NoAssertCommand$_optimizeStatements$L_NoAssertCommand$ALStatement$(this, funcDef._statements);
	return true;
};


_NoAssertCommand.prototype._optimizeStatements$ALStatement$ = function (statements) {
	var $this = this;
	var optimize;
	function optimize(statements) {
		var i;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof AssertStatement) {
				statements.splice(i, 1);
			} else {
				_Util$handleSubStatements$F$ALStatement$B$LStatement$(optimize, statements[i]);
				++ i;
			}
		}
		return false;
	}
	optimize(statements);
};


function _NoAssertCommand$_optimizeStatements$L_NoAssertCommand$ALStatement$($this, statements) {
	var optimize;
	function optimize(statements) {
		var i;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof AssertStatement) {
				statements.splice(i, 1);
			} else {
				_Util$handleSubStatements$F$ALStatement$B$LStatement$(optimize, statements[i]);
				++ i;
			}
		}
		return false;
	}
	optimize(statements);
};

_NoAssertCommand._optimizeStatements$L_NoAssertCommand$ALStatement$ = _NoAssertCommand$_optimizeStatements$L_NoAssertCommand$ALStatement$;

function _NoLogCommand() {
	this._identifier = "no-log";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_NoLogCommand], _FunctionOptimizeCommand);
_NoLogCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	_NoLogCommand$_optimizeStatements$L_NoLogCommand$ALStatement$(this, funcDef._statements);
	return true;
};


_NoLogCommand.prototype._optimizeStatements$ALStatement$ = function (statements) {
	var $this = this;
	var optimize;
	function optimize(statements) {
		var i;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof LogStatement) {
				statements.splice(i, 1);
			} else {
				_Util$handleSubStatements$F$ALStatement$B$LStatement$(optimize, statements[i]);
				++ i;
			}
		}
		return false;
	}
	optimize(statements);
};


function _NoLogCommand$_optimizeStatements$L_NoLogCommand$ALStatement$($this, statements) {
	var optimize;
	function optimize(statements) {
		var i;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof LogStatement) {
				statements.splice(i, 1);
			} else {
				_Util$handleSubStatements$F$ALStatement$B$LStatement$(optimize, statements[i]);
				++ i;
			}
		}
		return false;
	}
	optimize(statements);
};

_NoLogCommand._optimizeStatements$L_NoLogCommand$ALStatement$ = _NoLogCommand$_optimizeStatements$L_NoLogCommand$ALStatement$;

function _DetermineCalleeCommand() {
	this._identifier = "determine-callee";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_DetermineCalleeCommand], _FunctionOptimizeCommand);
_DetermineCalleeCommand.prototype._createStash$ = function () {
	return new _DetermineCalleeCommand$x2EStash();
};


_DetermineCalleeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var callingFuncDef;
		var this$0;
		if (statement instanceof ConstructorInvocationStatement) {
			callingFuncDef = _DetermineCalleeCommand$findCallingFunctionInClass$LClassDefinition$SALType$B(statement._ctorClassType.getClassDef$(), "constructor", statement._ctorFunctionType._argTypes, false);
			if (callingFuncDef == null) {
				throw new Error("could not determine the associated parent ctor");
			}
			_OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, statement).callingFuncDef = callingFuncDef;
		} else {
			if (statement instanceof FunctionStatement) {
				this$0 = statement._funcDef;
				Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
			}
		}
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			var calleeExpr;
			var propertyExpr;
			var holderType;
			var callingFuncDef;
			if (expr instanceof CallExpression) {
				calleeExpr = CallExpression$getExpr$LCallExpression$(expr);
				if (calleeExpr instanceof PropertyExpression && ! calleeExpr.getType$().isAssignable$()) {
					propertyExpr = calleeExpr;
					holderType = propertyExpr.getHolderType$();
					callingFuncDef = _DetermineCalleeCommand$findCallingFunction$LClassDefinition$SALType$B(holderType.getClassDef$(), Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(propertyExpr)), ResolvedFunctionType$getArgumentTypes$LResolvedFunctionType$(propertyExpr.getType$()), UnaryExpression$getExpr$LUnaryExpression$(propertyExpr).isClassSpecifier$());
					_DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$($this, expr, callingFuncDef);
				} else {
					if (calleeExpr instanceof FunctionExpression) {
						_DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$($this, expr, FunctionExpression$getFuncDef$LFunctionExpression$(calleeExpr));
					} else {
						_DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$($this, expr, null);
					}
				}
			} else {
				if (expr instanceof NewExpression) {
					callingFuncDef = _DetermineCalleeCommand$findCallingFunctionInClass$LClassDefinition$SALType$B(expr.getType$().getClassDef$(), "constructor", ResolvedFunctionType$getArgumentTypes$LResolvedFunctionType$(NewExpression$getConstructor$LNewExpression$(expr)), false);
					if (callingFuncDef == null) {
						throw new Error("could not find matching constructor for " + NewExpression$getConstructor$LNewExpression$(expr).toString());
					}
					_DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$($this, expr, callingFuncDef);
				}
			}
			if (expr instanceof FunctionExpression) {
				return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
			} else {
				return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			}
		}));
		return statement.forEachStatement$F$LStatement$B$(onStatement);
	}), funcDef._statements);
	return true;
};


_DetermineCalleeCommand.prototype._setCallingFuncDef$LStashable$LMemberFunctionDefinition$ = function (stashable, funcDef) {
	_OptimizeCommand$getStash$L_OptimizeCommand$LStashable$(this, stashable).callingFuncDef = funcDef;
};


function _DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$($this, stashable, funcDef) {
	_OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, stashable).callingFuncDef = funcDef;
};

_DetermineCalleeCommand._setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$ = _DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$;

function _DetermineCalleeCommand$findCallingFunctionInClass$LClassDefinition$SALType$B(classDef, funcName, argTypes, isStatic) {
	var found;
	found = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, funcName, argTypes, isStatic);
	if (found != null) {
		if ((found._flags & 12) === 0) {
			found = null;
		}
	}
	return found;
};

_DetermineCalleeCommand.findCallingFunctionInClass$LClassDefinition$SALType$B = _DetermineCalleeCommand$findCallingFunctionInClass$LClassDefinition$SALType$B;

function _DetermineCalleeCommand$findCallingFunction$LClassDefinition$SALType$B(classDef, funcName, argTypes, isStatic) {
	var found;
	found = null;
	ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(classDef, (function (classDef) {
		return ((found = _DetermineCalleeCommand$findCallingFunctionInClass$LClassDefinition$SALType$B(classDef, funcName, argTypes, isStatic)) != null ? false : true);
	}));
	return found;
};

_DetermineCalleeCommand.findCallingFunction$LClassDefinition$SALType$B = _DetermineCalleeCommand$findCallingFunction$LClassDefinition$SALType$B;

function _DetermineCalleeCommand$getCallingFuncDef$LStashable$(stashable) {
	var stash;
	stash = stashable.getStash$S("determine-callee");
	if (stash == null) {
		throw new Error("callee not searched");
	}
	return stash.callingFuncDef;
};

_DetermineCalleeCommand.getCallingFuncDef$LStashable$ = _DetermineCalleeCommand$getCallingFuncDef$LStashable$;

function _StaticizeOptimizeCommand() {
	this._identifier = "staticize";
	this._optimizer = null;
};

$__jsx_extend([_StaticizeOptimizeCommand], _OptimizeCommand);
_StaticizeOptimizeCommand.prototype._createStash$ = function () {
	return new _StaticizeOptimizeCommand$x2EStash();
};


_StaticizeOptimizeCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var memberCanBeStaticized;
	function memberCanBeStaticized(funcDef) {
		return (funcDef._flags & 62) === 4 && funcDef._nameToken._value !== "constructor";
	}
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		if ((classDef.flags$() & 192) !== 0) {
			return true;
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function onFunction(funcDef) {
			if (memberCanBeStaticized(funcDef)) {
				_OptimizeCommand$log$L_OptimizeCommand$S($this, "staticizing method: " + MemberDefinition$name$LMemberDefinition$(funcDef));
				_StaticizeOptimizeCommand$_staticizeMethod$L_StaticizeOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
			}
			return true;
		}));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		var onFunction;
		var message$0;
		var message$0$0;
		message$0 = "rewriting member method calls in class: " + classDef.className$();
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		$this._optimizer._log += message$0$0 + "\n";
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			if (MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef) == null) {
				return true;
			}
			_StaticizeOptimizeCommand$_rewriteMethodCallsToStatic$L_StaticizeOptimizeCommand$LExpression$F$LExpression$V$LMemberFunctionDefinition$($this, MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef), (function (expr) {
				MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$(varDef, expr);
			}), null);
			return true;
		}));
		function onFunction(funcDef) {
			var onStatement;
			function onStatement(statement) {
				statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
					_StaticizeOptimizeCommand$_rewriteMethodCallsToStatic$L_StaticizeOptimizeCommand$LExpression$F$LExpression$V$LMemberFunctionDefinition$($this, expr, replaceCb, funcDef);
					return true;
				}));
				return statement.forEachStatement$F$LStatement$B$(onStatement);
			}
			MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(funcDef, onStatement);
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFunction);
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, onFunction);
		return true;
	}));
};


_StaticizeOptimizeCommand.prototype._staticizeMethod$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var staticFuncDef;
	var classDef;
	var newName;
	var thisArg;
	var getArgumentTypes$this$0;
	var _members$0;
	staticFuncDef = MemberFunctionDefinition$clone$LMemberFunctionDefinition$(funcDef);
	classDef = funcDef._classDef;
	staticFuncDef._classDef = classDef;
	(_members$0 = classDef._members).splice(_members$0.indexOf(funcDef) + 1, 0, staticFuncDef);
	newName = _StaticizeOptimizeCommand$_newStaticFunctionName$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B(this, classDef, funcDef._nameToken._value, [ new ObjectType(classDef) ].concat((getArgumentTypes$this$0 = funcDef.getType$(), getArgumentTypes$this$0._argTypes)), true);
	_OptimizeCommand$getStash$L_OptimizeCommand$LStashable$(this, funcDef).altName = newName;
	staticFuncDef._nameToken = new Token$1(newName, true);
	MemberDefinition$setFlags$LMemberDefinition$N(staticFuncDef, funcDef._flags & -16385 | 8);
	thisArg = new ArgumentDeclaration(new Token$1("$this", false), new ObjectType(classDef));
	staticFuncDef._args.unshift(thisArg);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		if (statement instanceof FunctionStatement) {
			this$0 = statement._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
			if (expr instanceof ThisExpression) {
				replaceCb(new LocalExpression(LocalVariable$getName$LLocalVariable$(thisArg), thisArg));
			} else {
				if (expr instanceof FunctionExpression) {
					return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
				}
			}
			return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		})) && statement.forEachStatement$F$LStatement$B$(onStatement);
	}), staticFuncDef._statements);
};


function _StaticizeOptimizeCommand$_staticizeMethod$L_StaticizeOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var staticFuncDef;
	var classDef;
	var newName;
	var thisArg;
	var getArgumentTypes$this$0;
	var _members$0;
	staticFuncDef = MemberFunctionDefinition$clone$LMemberFunctionDefinition$(funcDef);
	classDef = funcDef._classDef;
	staticFuncDef._classDef = classDef;
	(_members$0 = classDef._members).splice(_members$0.indexOf(funcDef) + 1, 0, staticFuncDef);
	newName = _StaticizeOptimizeCommand$_newStaticFunctionName$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, classDef, funcDef._nameToken._value, [ new ObjectType(classDef) ].concat((getArgumentTypes$this$0 = funcDef.getType$(), getArgumentTypes$this$0._argTypes)), true);
	_OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, funcDef).altName = newName;
	staticFuncDef._nameToken = new Token$1(newName, true);
	MemberDefinition$setFlags$LMemberDefinition$N(staticFuncDef, funcDef._flags & -16385 | 8);
	thisArg = new ArgumentDeclaration(new Token$1("$this", false), new ObjectType(classDef));
	staticFuncDef._args.unshift(thisArg);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		if (statement instanceof FunctionStatement) {
			this$0 = statement._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
			if (expr instanceof ThisExpression) {
				replaceCb(new LocalExpression(LocalVariable$getName$LLocalVariable$(thisArg), thisArg));
			} else {
				if (expr instanceof FunctionExpression) {
					return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
				}
			}
			return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		})) && statement.forEachStatement$F$LStatement$B$(onStatement);
	}), staticFuncDef._statements);
};

_StaticizeOptimizeCommand._staticizeMethod$L_StaticizeOptimizeCommand$LMemberFunctionDefinition$ = _StaticizeOptimizeCommand$_staticizeMethod$L_StaticizeOptimizeCommand$LMemberFunctionDefinition$;

_StaticizeOptimizeCommand.prototype._newStaticFunctionName$LClassDefinition$SALType$B = function (classDef, baseName, argTypes, isStatic) {
	var index;
	var newName;
	index = 0;
	newName = baseName;
	while (Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, newName, argTypes, isStatic) != null) {
		newName = Util$format$SAS("%1_%2", [ baseName, index + "" ]);
		++ index;
	}
	return newName;
};


function _StaticizeOptimizeCommand$_newStaticFunctionName$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, classDef, baseName, argTypes, isStatic) {
	var index;
	var newName;
	index = 0;
	newName = baseName;
	while (Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, newName, argTypes, isStatic) != null) {
		newName = Util$format$SAS("%1_%2", [ baseName, index + "" ]);
		++ index;
	}
	return newName;
};

_StaticizeOptimizeCommand._newStaticFunctionName$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B = _StaticizeOptimizeCommand$_newStaticFunctionName$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B;

_StaticizeOptimizeCommand.prototype._rewriteMethodCallsToStatic$LExpression$F$LExpression$V$LMemberFunctionDefinition$ = function (expr, replaceCb, rewritingFuncDef) {
	var $this = this;
	var onExpr;
	function onExpr(expr, replaceCb) {
		var calleeExpr;
		var propertyExpr;
		var receiverType;
		var funcDef;
		var newName;
		var superExpr;
		var classDef;
		var thisVar;
		var thisArg;
		var this$0;
		var getReturnType$this$0;
		var getArgumentTypes$this$0;
		var getReturnType$this$1;
		var getArgumentTypes$this$1;
		if (expr instanceof CallExpression) {
			calleeExpr = expr._expr;
			if (calleeExpr instanceof PropertyExpression && ! calleeExpr._expr.isClassSpecifier$() && ! calleeExpr._type.isAssignable$()) {
				propertyExpr = calleeExpr;
				this$0 = propertyExpr._expr.getType$();
				receiverType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
				if ((receiverType.getClassDef$().flags$() & 192) === 0) {
					funcDef = _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, receiverType.getClassDef$(), propertyExpr._identifierToken._value, propertyExpr._type._argTypes, false);
					if (funcDef != null && (newName = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, funcDef).altName) != null) {
						onExpr(propertyExpr._expr, (function (expr) {
							UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
						}));
						Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
						replaceCb(new CallExpression(expr._token, new PropertyExpression$0(propertyExpr._token, new ClassExpression(new Token$1(funcDef._classDef.className$(), true), new ObjectType(funcDef._classDef)), new Token$1(newName, true), propertyExpr._typeArgs, new StaticFunctionType(null, (getReturnType$this$0 = funcDef.getType$(), getReturnType$this$0._returnType), [ new ObjectType(funcDef._classDef) ].concat((getArgumentTypes$this$0 = funcDef.getType$(), getArgumentTypes$this$0._argTypes)), false)), [ propertyExpr._expr ].concat(expr._args)));
						return true;
					}
				}
			}
		} else {
			if (expr instanceof SuperExpression) {
				superExpr = expr;
				classDef = superExpr._funcType._objectType.getClassDef$();
				funcDef = _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, classDef, superExpr._name._value, superExpr._funcType._argTypes, false);
				if (funcDef != null && (newName = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, funcDef).altName) != null) {
					Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, superExpr._args);
					if ((rewritingFuncDef._flags & 8) !== 0) {
						thisArg = rewritingFuncDef._args[0];
						thisVar = new LocalExpression(thisArg._name, thisArg);
					} else {
						thisVar = new ThisExpression(new Token$1("this", false), funcDef._classDef);
					}
					replaceCb(new CallExpression(expr._token, new PropertyExpression$0(superExpr._token, new ClassExpression(new Token$1(funcDef._classDef.className$(), true), new ObjectType(funcDef._classDef)), new Token$1(newName, true), [  ], new StaticFunctionType(null, (getReturnType$this$1 = funcDef.getType$(), getReturnType$this$1._returnType), [ new ObjectType(funcDef._classDef) ].concat((getArgumentTypes$this$1 = funcDef.getType$(), getArgumentTypes$this$1._argTypes)), false)), [ thisVar ].concat(superExpr._args)));
					return true;
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}
	onExpr(expr, replaceCb);
};


function _StaticizeOptimizeCommand$_rewriteMethodCallsToStatic$L_StaticizeOptimizeCommand$LExpression$F$LExpression$V$LMemberFunctionDefinition$($this, expr, replaceCb, rewritingFuncDef) {
	var onExpr;
	function onExpr(expr, replaceCb) {
		var calleeExpr;
		var propertyExpr;
		var receiverType;
		var funcDef;
		var newName;
		var superExpr;
		var classDef;
		var thisVar;
		var thisArg;
		var this$0;
		var getReturnType$this$0;
		var getArgumentTypes$this$0;
		var getReturnType$this$1;
		var getArgumentTypes$this$1;
		if (expr instanceof CallExpression) {
			calleeExpr = expr._expr;
			if (calleeExpr instanceof PropertyExpression && ! calleeExpr._expr.isClassSpecifier$() && ! calleeExpr._type.isAssignable$()) {
				propertyExpr = calleeExpr;
				this$0 = propertyExpr._expr.getType$();
				receiverType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
				if ((receiverType.getClassDef$().flags$() & 192) === 0) {
					funcDef = _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, receiverType.getClassDef$(), propertyExpr._identifierToken._value, propertyExpr._type._argTypes, false);
					if (funcDef != null && (newName = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, funcDef).altName) != null) {
						onExpr(propertyExpr._expr, (function (expr) {
							UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
						}));
						Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
						replaceCb(new CallExpression(expr._token, new PropertyExpression$0(propertyExpr._token, new ClassExpression(new Token$1(funcDef._classDef.className$(), true), new ObjectType(funcDef._classDef)), new Token$1(newName, true), propertyExpr._typeArgs, new StaticFunctionType(null, (getReturnType$this$0 = funcDef.getType$(), getReturnType$this$0._returnType), [ new ObjectType(funcDef._classDef) ].concat((getArgumentTypes$this$0 = funcDef.getType$(), getArgumentTypes$this$0._argTypes)), false)), [ propertyExpr._expr ].concat(expr._args)));
						return true;
					}
				}
			}
		} else {
			if (expr instanceof SuperExpression) {
				superExpr = expr;
				classDef = superExpr._funcType._objectType.getClassDef$();
				funcDef = _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, classDef, superExpr._name._value, superExpr._funcType._argTypes, false);
				if (funcDef != null && (newName = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, funcDef).altName) != null) {
					Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, superExpr._args);
					if ((rewritingFuncDef._flags & 8) !== 0) {
						thisArg = rewritingFuncDef._args[0];
						thisVar = new LocalExpression(thisArg._name, thisArg);
					} else {
						thisVar = new ThisExpression(new Token$1("this", false), funcDef._classDef);
					}
					replaceCb(new CallExpression(expr._token, new PropertyExpression$0(superExpr._token, new ClassExpression(new Token$1(funcDef._classDef.className$(), true), new ObjectType(funcDef._classDef)), new Token$1(newName, true), [  ], new StaticFunctionType(null, (getReturnType$this$1 = funcDef.getType$(), getReturnType$this$1._returnType), [ new ObjectType(funcDef._classDef) ].concat((getArgumentTypes$this$1 = funcDef.getType$(), getArgumentTypes$this$1._argTypes)), false)), [ thisVar ].concat(superExpr._args)));
					return true;
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}
	onExpr(expr, replaceCb);
};

_StaticizeOptimizeCommand._rewriteMethodCallsToStatic$L_StaticizeOptimizeCommand$LExpression$F$LExpression$V$LMemberFunctionDefinition$ = _StaticizeOptimizeCommand$_rewriteMethodCallsToStatic$L_StaticizeOptimizeCommand$LExpression$F$LExpression$V$LMemberFunctionDefinition$;

_StaticizeOptimizeCommand.prototype._findFunctionInClassTree$LClassDefinition$SALType$B = function (classDef, name, argTypes, isStatic) {
	var funcDef;
	var this$0;
	while (classDef.className$() !== "Object") {
		if ((funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic)) != null) {
			return funcDef;
		}
		this$0 = classDef._extendType;
		classDef = this$0._classDef;
	}
	return Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic);
};


function _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, classDef, name, argTypes, isStatic) {
	var funcDef;
	var this$0;
	while (classDef.className$() !== "Object") {
		if ((funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic)) != null) {
			return funcDef;
		}
		this$0 = classDef._extendType;
		classDef = this$0._classDef;
	}
	return Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic);
};

_StaticizeOptimizeCommand._findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B = _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B;

function _UnclassifyOptimizationCommand() {
	this._identifier = "unclassify";
	this._optimizer = null;
};

$__jsx_extend([_UnclassifyOptimizationCommand], _OptimizeCommand);
_UnclassifyOptimizationCommand.prototype._createStash$ = function () {
	return new _UnclassifyOptimizationCommand$x2EStash();
};


_UnclassifyOptimizationCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var classDefs;
	var i$0;
	classDefs = _UnclassifyOptimizationCommand$_getClassesToUnclassify$L_UnclassifyOptimizationCommand$(this);
	for (i$0 in classDefs) {
		(function (classDef) {
			var message$0;
			var message$0$0;
			message$0 = "unclassifying class: " + classDef.className$();
			message$0$0 = "[" + $this._identifier + "] " + message$0;
			$this._optimizer._log += message$0$0 + "\n";
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function onFunction(funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_STATIC) === 0 && MemberDefinition$name$LMemberDefinition$(funcDef) !== "constructor") {
					_OptimizeCommand$log$L_OptimizeCommand$S($this, "rewriting method to static function: " + MemberDefinition$name$LMemberDefinition$(funcDef));
					_UnclassifyOptimizationCommand$_rewriteFunctionAsStatic$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$($this, funcDef);
				}
				return true;
			}));
		})(classDefs[i$0]);
	}
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		var onFunction;
		var message$0;
		var message$0$0;
		message$0 = "rewriting member method calls in class: " + classDef.className$();
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		$this._optimizer._log += message$0$0 + "\n";
		function onFunction(funcDef) {
			var onStatement;
			function onStatement(statement) {
				statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
					_UnclassifyOptimizationCommand$_rewriteMethodCallsToStatic$L_UnclassifyOptimizationCommand$LExpression$F$LExpression$V$ALClassDefinition$($this, expr, replaceCb, classDefs);
					return true;
				}));
				return statement.forEachStatement$F$LStatement$B$(onStatement);
			}
			MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(funcDef, onStatement);
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFunction);
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, onFunction);
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			if ((MemberDefinition$flags$LMemberDefinition$(varDef) & ClassDefinition.IS_STATIC) !== 0) {
				if (MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef) != null) {
					_UnclassifyOptimizationCommand$_rewriteMethodCallsToStatic$L_UnclassifyOptimizationCommand$LExpression$F$LExpression$V$ALClassDefinition$($this, MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef), (function (expr) {
						MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$(varDef, expr);
					}), classDefs);
				}
			}
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(varDef, onFunction);
		}));
		return true;
	}));
};


_UnclassifyOptimizationCommand.prototype._getClassesToUnclassify$ = function () {
	var $this = this;
	var candidates;
	var candidateIndex;
	var hasInlineableCtor;
	candidates = [];
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		if ((classDef.flags$() & 16404) === 4 && classDef._extendType._classDef.className$() === "Object" && classDef._implementTypes.length === 0 && ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
			return (MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_OVERRIDE | ClassDefinition.IS_EXPORT)) === 0;
		}))) {
			candidates.push(classDef);
		}
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		var onExpr;
		var onFunction;
		if (candidates.length === 0) {
			return false;
		}
		function onExpr(expr) {
			var foundClassDefIndex;
			if (! (expr != null)) {
				debugger;
				throw new Error("[/Users/gfx/repo/try-on-web/JSX/src/optimizer.jsx:1398:28] assertion failure\n                assert expr != null;\n                            ^^\n");
			}
			if (expr instanceof InstanceofExpression) {
				foundClassDefIndex = candidates.indexOf(InstanceofExpression$getExpectedType$LInstanceofExpression$(expr).getClassDef$());
				if (foundClassDefIndex !== - 1) {
					candidates.splice(foundClassDefIndex, 1);
					if (candidates.length === 0) {
						return false;
					}
				}
			} else {
				if (expr instanceof AsExpression && expr.getType$() instanceof ObjectType) {
					foundClassDefIndex = candidates.indexOf(expr.getType$().getClassDef$());
					if (foundClassDefIndex !== - 1) {
						candidates.splice(foundClassDefIndex, 1);
						if (candidates.length === 0) {
							return false;
						}
					}
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}
		function onFunction(funcDef) {
			MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(funcDef, (function onStatement(statement) {
				Statement$forEachExpression$LStatement$F$LExpression$B$(statement, onExpr);
				return statement.forEachStatement$F$LStatement$B$(onStatement);
			}));
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFunction);
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, onFunction);
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			if ((MemberDefinition$flags$LMemberDefinition$(varDef) & ClassDefinition.IS_STATIC) !== 0) {
				if (MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef) != null) {
					onExpr(MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef));
				}
			}
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(varDef, onFunction);
		}));
		return true;
	}));
	for (candidateIndex = candidates.length - 1; candidateIndex >= 0; -- candidateIndex) {
		hasInlineableCtor = false;
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(candidates[candidateIndex], (function (funcDef) {
			var inliner;
			var message$0;
			var message$0$0;
			if ((funcDef._flags & 8) === 0 && funcDef._nameToken._value === "constructor") {
				inliner = _UnclassifyOptimizationCommand$_createInliner$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$($this, funcDef);
				message$0 = funcDef.getNotation$() + " is" + (inliner ? "" : " not") + " inlineable";
				message$0$0 = "[" + $this._identifier + "] " + message$0;
				$this._optimizer._log += message$0$0 + "\n";
				if (inliner) {
					_OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, funcDef).inliner = inliner;
					hasInlineableCtor = true;
				}
			}
			return true;
		}));
		if (! hasInlineableCtor) {
			candidates.splice(candidateIndex, 1);
		}
	}
	return (candidates.length === 0 ? candidates : candidates);
};


function _UnclassifyOptimizationCommand$_getClassesToUnclassify$L_UnclassifyOptimizationCommand$($this) {
	var candidates;
	var candidateIndex;
	var hasInlineableCtor;
	candidates = [];
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this._optimizer._compiler, (function (parser, classDef) {
		if ((classDef.flags$() & 16404) === 4 && classDef._extendType._classDef.className$() === "Object" && classDef._implementTypes.length === 0 && ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
			return (MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_OVERRIDE | ClassDefinition.IS_EXPORT)) === 0;
		}))) {
			candidates.push(classDef);
		}
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this._optimizer._compiler, (function (parser, classDef) {
		var onExpr;
		var onFunction;
		if (candidates.length === 0) {
			return false;
		}
		function onExpr(expr) {
			var foundClassDefIndex;
			if (! (expr != null)) {
				debugger;
				throw new Error("[/Users/gfx/repo/try-on-web/JSX/src/optimizer.jsx:1398:28] assertion failure\n                assert expr != null;\n                            ^^\n");
			}
			if (expr instanceof InstanceofExpression) {
				foundClassDefIndex = candidates.indexOf(InstanceofExpression$getExpectedType$LInstanceofExpression$(expr).getClassDef$());
				if (foundClassDefIndex !== - 1) {
					candidates.splice(foundClassDefIndex, 1);
					if (candidates.length === 0) {
						return false;
					}
				}
			} else {
				if (expr instanceof AsExpression && expr.getType$() instanceof ObjectType) {
					foundClassDefIndex = candidates.indexOf(expr.getType$().getClassDef$());
					if (foundClassDefIndex !== - 1) {
						candidates.splice(foundClassDefIndex, 1);
						if (candidates.length === 0) {
							return false;
						}
					}
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}
		function onFunction(funcDef) {
			MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(funcDef, (function onStatement(statement) {
				Statement$forEachExpression$LStatement$F$LExpression$B$(statement, onExpr);
				return statement.forEachStatement$F$LStatement$B$(onStatement);
			}));
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFunction);
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, onFunction);
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			if ((MemberDefinition$flags$LMemberDefinition$(varDef) & ClassDefinition.IS_STATIC) !== 0) {
				if (MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef) != null) {
					onExpr(MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef));
				}
			}
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(varDef, onFunction);
		}));
		return true;
	}));
	for (candidateIndex = candidates.length - 1; candidateIndex >= 0; -- candidateIndex) {
		hasInlineableCtor = false;
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(candidates[candidateIndex], (function (funcDef) {
			var inliner;
			var message$0;
			var message$0$0;
			if ((funcDef._flags & 8) === 0 && funcDef._nameToken._value === "constructor") {
				inliner = _UnclassifyOptimizationCommand$_createInliner$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$($this, funcDef);
				message$0 = funcDef.getNotation$() + " is" + (inliner ? "" : " not") + " inlineable";
				message$0$0 = "[" + $this._identifier + "] " + message$0;
				$this._optimizer._log += message$0$0 + "\n";
				if (inliner) {
					_OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, funcDef).inliner = inliner;
					hasInlineableCtor = true;
				}
			}
			return true;
		}));
		if (! hasInlineableCtor) {
			candidates.splice(candidateIndex, 1);
		}
	}
	return (candidates.length === 0 ? candidates : candidates);
};

_UnclassifyOptimizationCommand._getClassesToUnclassify$L_UnclassifyOptimizationCommand$ = _UnclassifyOptimizationCommand$_getClassesToUnclassify$L_UnclassifyOptimizationCommand$;

_UnclassifyOptimizationCommand.prototype._createInliner$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var propertyNames;
	var propertyExprs;
	var expectedArgIndex;
	var statements;
	var statementIndex;
	var statementExpr;
	var lhsExpr;
	var onRHSExpr;
	var propertyIndex;
	var i;
	var propertyNames$len$0;
	if (funcDef._locals.length !== 0) {
		return null;
	}
	propertyNames = [];
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(funcDef._classDef, (function (member) {
		if ((member._flags & 8) === 0) {
			propertyNames.push(member._nameToken._value);
		}
		return true;
	}));
	propertyExprs = [];
	expectedArgIndex = 0;
	statements = funcDef._statements;
	if (statements.length !== propertyNames.length) {
		return null;
	}
	for (statementIndex = 0; statementIndex < statements.length; ++ statementIndex) {
		if (! (statements[statementIndex] instanceof ExpressionStatement)) {
			return null;
		}
		statementExpr = statements[statementIndex]._expr;
		if (! (statementExpr instanceof AssignmentExpression)) {
			return null;
		}
		lhsExpr = statementExpr._expr1;
		if (! (lhsExpr instanceof PropertyExpression && lhsExpr._expr instanceof ThisExpression)) {
			return null;
		}
		onRHSExpr = (function (expr) {
			var argIndex;
			if (expr instanceof AssignmentExpression || expr instanceof PreIncrementExpression || expr instanceof PostIncrementExpression) {
				return false;
			} else {
				if (expr instanceof FunctionExpression) {
					return false;
				} else {
					if (expr instanceof ThisExpression) {
						return false;
					} else {
						if (expr instanceof LocalExpression) {
							argIndex = funcDef._args.map((function (i) {
								return i;
							})).indexOf(expr._local);
							if (argIndex === -1) {
								throw new Error("logic flaw; could not find argument: " + expr._local._name._value);
							}
							if (expectedArgIndex !== argIndex) {
								return false;
							}
							++ expectedArgIndex;
						}
					}
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onRHSExpr);
		});
		if (! onRHSExpr(statementExpr._expr2)) {
			return null;
		}
		propertyIndex = propertyNames.indexOf(lhsExpr._identifierToken._value);
		if (propertyIndex === -1) {
			throw new Error("logic flaw; could not find property: " + lhsExpr._identifierToken._value);
		}
		if (propertyExprs[propertyIndex]) {
			return null;
		}
		for ((i = propertyIndex + 1, propertyNames$len$0 = propertyNames.length); i < propertyNames$len$0; ++ i) {
			if (propertyExprs[i] != null && _Util$exprHasSideEffects$LExpression$(propertyExprs[i])) {
				return null;
			}
		}
		propertyExprs[propertyIndex] = statementExpr._expr2.clone$();
	}
	return (function (newExpr) {
		return propertyExprs.map((function (expr) {
			var onExpr;
			function onExpr(expr, replaceCb) {
				var args;
				var argIndex;
				var i;
				if (expr instanceof LocalExpression) {
					(args = MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef), argIndex = - 1);
					for (i in args) {
						if (args[i] == LocalExpression$getLocal$LLocalExpression$(expr)) {
							argIndex = i;
							break;
						}
					}
					if (argIndex === - 1) {
						throw new Error("logic flaw");
					}
					replaceCb(NewExpression$getArguments$LNewExpression$(newExpr)[argIndex]);
					return true;
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			}
			expr = expr.clone$();
			onExpr(expr, (function (newExpr) {
				expr = newExpr;
			}));
			return expr;
		}));
	});
};


function _UnclassifyOptimizationCommand$_createInliner$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$($this, funcDef) {
	var propertyNames;
	var propertyExprs;
	var expectedArgIndex;
	var statements;
	var statementIndex;
	var statementExpr;
	var lhsExpr;
	var onRHSExpr;
	var propertyIndex;
	var i;
	var propertyNames$len$0;
	if (funcDef._locals.length !== 0) {
		return null;
	}
	propertyNames = [];
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(funcDef._classDef, (function (member) {
		if ((member._flags & 8) === 0) {
			propertyNames.push(member._nameToken._value);
		}
		return true;
	}));
	propertyExprs = [];
	expectedArgIndex = 0;
	statements = funcDef._statements;
	if (statements.length !== propertyNames.length) {
		return null;
	}
	for (statementIndex = 0; statementIndex < statements.length; ++ statementIndex) {
		if (! (statements[statementIndex] instanceof ExpressionStatement)) {
			return null;
		}
		statementExpr = statements[statementIndex]._expr;
		if (! (statementExpr instanceof AssignmentExpression)) {
			return null;
		}
		lhsExpr = statementExpr._expr1;
		if (! (lhsExpr instanceof PropertyExpression && lhsExpr._expr instanceof ThisExpression)) {
			return null;
		}
		onRHSExpr = (function (expr) {
			var argIndex;
			if (expr instanceof AssignmentExpression || expr instanceof PreIncrementExpression || expr instanceof PostIncrementExpression) {
				return false;
			} else {
				if (expr instanceof FunctionExpression) {
					return false;
				} else {
					if (expr instanceof ThisExpression) {
						return false;
					} else {
						if (expr instanceof LocalExpression) {
							argIndex = funcDef._args.map((function (i) {
								return i;
							})).indexOf(expr._local);
							if (argIndex === -1) {
								throw new Error("logic flaw; could not find argument: " + expr._local._name._value);
							}
							if (expectedArgIndex !== argIndex) {
								return false;
							}
							++ expectedArgIndex;
						}
					}
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onRHSExpr);
		});
		if (! onRHSExpr(statementExpr._expr2)) {
			return null;
		}
		propertyIndex = propertyNames.indexOf(lhsExpr._identifierToken._value);
		if (propertyIndex === -1) {
			throw new Error("logic flaw; could not find property: " + lhsExpr._identifierToken._value);
		}
		if (propertyExprs[propertyIndex]) {
			return null;
		}
		for ((i = propertyIndex + 1, propertyNames$len$0 = propertyNames.length); i < propertyNames$len$0; ++ i) {
			if (propertyExprs[i] != null && _Util$exprHasSideEffects$LExpression$(propertyExprs[i])) {
				return null;
			}
		}
		propertyExprs[propertyIndex] = statementExpr._expr2.clone$();
	}
	return (function (newExpr) {
		return propertyExprs.map((function (expr) {
			var onExpr;
			function onExpr(expr, replaceCb) {
				var args;
				var argIndex;
				var i;
				if (expr instanceof LocalExpression) {
					(args = MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef), argIndex = - 1);
					for (i in args) {
						if (args[i] == LocalExpression$getLocal$LLocalExpression$(expr)) {
							argIndex = i;
							break;
						}
					}
					if (argIndex === - 1) {
						throw new Error("logic flaw");
					}
					replaceCb(NewExpression$getArguments$LNewExpression$(newExpr)[argIndex]);
					return true;
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			}
			expr = expr.clone$();
			onExpr(expr, (function (newExpr) {
				expr = newExpr;
			}));
			return expr;
		}));
	});
};

_UnclassifyOptimizationCommand._createInliner$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$ = _UnclassifyOptimizationCommand$_createInliner$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$;

_UnclassifyOptimizationCommand.prototype._rewriteFunctionAsStatic$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var thisArg;
	thisArg = new ArgumentDeclaration(new Token$1("$this", false), new ObjectType(funcDef._classDef));
	funcDef._args.unshift(thisArg);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		if (statement instanceof FunctionStatement) {
			this$0 = statement._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
			if (expr instanceof ThisExpression) {
				replaceCb(new LocalExpression(LocalVariable$getName$LLocalVariable$(thisArg), thisArg));
			} else {
				if (expr instanceof FunctionExpression) {
					return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
				}
			}
			return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		})) && statement.forEachStatement$F$LStatement$B$(onStatement);
	}), funcDef._statements);
	MemberDefinition$setFlags$LMemberDefinition$N(funcDef, funcDef._flags | 8);
};


function _UnclassifyOptimizationCommand$_rewriteFunctionAsStatic$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$($this, funcDef) {
	var thisArg;
	thisArg = new ArgumentDeclaration(new Token$1("$this", false), new ObjectType(funcDef._classDef));
	funcDef._args.unshift(thisArg);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		if (statement instanceof FunctionStatement) {
			this$0 = statement._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
			if (expr instanceof ThisExpression) {
				replaceCb(new LocalExpression(LocalVariable$getName$LLocalVariable$(thisArg), thisArg));
			} else {
				if (expr instanceof FunctionExpression) {
					return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
				}
			}
			return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		})) && statement.forEachStatement$F$LStatement$B$(onStatement);
	}), funcDef._statements);
	MemberDefinition$setFlags$LMemberDefinition$N(funcDef, funcDef._flags | 8);
};

_UnclassifyOptimizationCommand._rewriteFunctionAsStatic$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$ = _UnclassifyOptimizationCommand$_rewriteFunctionAsStatic$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$;

_UnclassifyOptimizationCommand.prototype._rewriteMethodCallsToStatic$LExpression$F$LExpression$V$ALClassDefinition$ = function (expr, replaceCb, unclassifyingClassDefs) {
	var $this = this;
	var onExpr;
	onExpr = (function (expr, replaceCb) {
		var calleeExpr;
		var propertyExpr;
		var receiverType;
		var receiverClassDef;
		var funcType;
		var this$0;
		if (expr instanceof CallExpression) {
			calleeExpr = expr._expr;
			if (calleeExpr instanceof PropertyExpression && ! calleeExpr._expr.isClassSpecifier$() && ! calleeExpr._type.isAssignable$() && ! (calleeExpr._identifierToken._value === "toString" && expr._args.length === 0)) {
				propertyExpr = calleeExpr;
				this$0 = propertyExpr._expr.getType$();
				receiverType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
				receiverClassDef = receiverType.getClassDef$();
				if (unclassifyingClassDefs.indexOf(receiverClassDef) !== -1) {
					onExpr(propertyExpr._expr, (function (expr) {
						UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
					}));
					Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
					funcType = propertyExpr._type;
					replaceCb(new CallExpression(expr._token, new PropertyExpression$0(propertyExpr._token, new ClassExpression(new Token$1(receiverClassDef.className$(), true), receiverType), propertyExpr._identifierToken, propertyExpr._typeArgs, new StaticFunctionType(null, funcType._returnType, [ receiverType ].concat(funcType._argTypes), false)), [ propertyExpr._expr ].concat(expr._args)));
					return true;
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	onExpr(expr, replaceCb);
};


function _UnclassifyOptimizationCommand$_rewriteMethodCallsToStatic$L_UnclassifyOptimizationCommand$LExpression$F$LExpression$V$ALClassDefinition$($this, expr, replaceCb, unclassifyingClassDefs) {
	var onExpr;
	onExpr = (function (expr, replaceCb) {
		var calleeExpr;
		var propertyExpr;
		var receiverType;
		var receiverClassDef;
		var funcType;
		var this$0;
		if (expr instanceof CallExpression) {
			calleeExpr = expr._expr;
			if (calleeExpr instanceof PropertyExpression && ! calleeExpr._expr.isClassSpecifier$() && ! calleeExpr._type.isAssignable$() && ! (calleeExpr._identifierToken._value === "toString" && expr._args.length === 0)) {
				propertyExpr = calleeExpr;
				this$0 = propertyExpr._expr.getType$();
				receiverType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
				receiverClassDef = receiverType.getClassDef$();
				if (unclassifyingClassDefs.indexOf(receiverClassDef) !== -1) {
					onExpr(propertyExpr._expr, (function (expr) {
						UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
					}));
					Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
					funcType = propertyExpr._type;
					replaceCb(new CallExpression(expr._token, new PropertyExpression$0(propertyExpr._token, new ClassExpression(new Token$1(receiverClassDef.className$(), true), receiverType), propertyExpr._identifierToken, propertyExpr._typeArgs, new StaticFunctionType(null, funcType._returnType, [ receiverType ].concat(funcType._argTypes), false)), [ propertyExpr._expr ].concat(expr._args)));
					return true;
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	onExpr(expr, replaceCb);
};

_UnclassifyOptimizationCommand._rewriteMethodCallsToStatic$L_UnclassifyOptimizationCommand$LExpression$F$LExpression$V$ALClassDefinition$ = _UnclassifyOptimizationCommand$_rewriteMethodCallsToStatic$L_UnclassifyOptimizationCommand$LExpression$F$LExpression$V$ALClassDefinition$;

function _FoldConstantCommand() {
	this._identifier = "fold-const";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_FoldConstantCommand], _FunctionOptimizeCommand);
_FoldConstantCommand.prototype._createStash$ = function () {
	return new _FoldConstantCommand$x2EStash();
};


_FoldConstantCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		statement.forEachStatement$F$LStatement$B$(onStatement);
		statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
			return _FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$($this, expr, replaceCb);
		}));
		return true;
	}), funcDef._statements);
	return true;
};


_FoldConstantCommand.prototype._optimizeExpression$LExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var $this = this;
	var exprAsNumber;
	var propertyExpr;
	var holderType;
	var member;
	var foldedExpr;
	var calculateCb;
	var baseExpr;
	var firstExpr;
	var secondExpr;
	var innerExpr;
	var condition;
	var op;
	var conditionalExpr;
	var condExpr;
	var ifTrueExpr;
	var ifFalseExpr;
	var callExpr;
	var allArgsAreConstants;
	var message$0;
	var message$0$0;
	var message$1;
	var message$0$1;
	var getNotation$this$0;
	var message$2;
	var message$0$2;
	var getNotation$this$1;
	var message$3;
	var message$0$3;
	var getNotation$this$2;
	var this$0;
	var this$1;
	var i$0;
	var _token$0;
	expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
		return _FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$($this, expr, replaceCb);
	}));
	function exprAsNumber(expr) {
		return +expr._token._value;
	}
	if (expr instanceof PropertyExpression) {
		propertyExpr = expr;
		holderType = propertyExpr.getHolderType$();
		if (propertyExpr._expr.isClassSpecifier$()) {
			member = null;
			ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(holderType.getClassDef$(), (function (m) {
				if (m._nameToken._value === propertyExpr._identifierToken._value) {
					member = m;
				}
				return member == null;
			}));
			if (member != null && (member._flags & 1) !== 0) {
				_FoldConstantCommand$_foldStaticConst$L_FoldConstantCommand$LMemberVariableDefinition$(this, member);
				foldedExpr = _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$(this, member._initialValue, member.getType$());
				if (foldedExpr != null) {
					foldedExpr = _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$(this, foldedExpr, propertyExpr._type);
					if (foldedExpr != null && ! (foldedExpr instanceof StringLiteralExpression && Util$decodeStringLiteral$S(foldedExpr._token._value).length > 64)) {
						message$0 = "folding property " + member.getNotation$() + " at " + (_token$0 = propertyExpr._token)._filename + ":" + (_token$0._lineNumber + "");
						message$0$0 = "[" + this._identifier + "] " + message$0;
						this._optimizer._log += message$0$0 + "\n";
						replaceCb(foldedExpr);
					}
				}
			}
		} else {
			if (propertyExpr._expr instanceof StringLiteralExpression) {
				if (propertyExpr._identifierToken._value === "length") {
					replaceCb(new NumberLiteralExpression(new Token$0(Util$decodeStringLiteral$S(propertyExpr._expr._token._value).length + "")));
				}
			}
		}
	} else {
		if (expr instanceof SignExpression) {
			switch (expr._token._value) {
			case "+":
				calculateCb = (function (x) {
					return + x;
				});
				break;
			case "-":
				calculateCb = (function (x) {
					return - x;
				});
				break;
			default:
				return false;
			}
			baseExpr = expr._expr;
			if (baseExpr instanceof IntegerLiteralExpression) {
				message$1 = "folding operator (number) " + (getNotation$this$0 = expr._token, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + ""));
				message$0$1 = "[" + this._identifier + "] " + message$1;
				this._optimizer._log += message$0$1 + "\n";
				replaceCb(new IntegerLiteralExpression(new Token$0(calculateCb(exprAsNumber(baseExpr)) + "")));
			} else {
				if (baseExpr instanceof NumberLiteralExpression) {
					message$2 = "folding operator (number) " + (getNotation$this$1 = expr._token, "'" + getNotation$this$1._value + "'" + " at " + (getNotation$this$1._filename || "<<unknown>>") + ":" + (getNotation$this$1._lineNumber + ""));
					message$0$2 = "[" + this._identifier + "] " + message$2;
					this._optimizer._log += message$0$2 + "\n";
					replaceCb(new NumberLiteralExpression(new Token$0(calculateCb(exprAsNumber(baseExpr)) + "")));
				}
			}
		} else {
			if (expr instanceof BitwiseNotExpression) {
				baseExpr = expr._expr;
				if (baseExpr instanceof NumberLiteralExpression || baseExpr instanceof IntegerLiteralExpression) {
					message$3 = "folding operator " + (getNotation$this$2 = expr._token, "'" + getNotation$this$2._value + "'" + " at " + (getNotation$this$2._filename || "<<unknown>>") + ":" + (getNotation$this$2._lineNumber + ""));
					message$0$3 = "[" + this._identifier + "] " + message$3;
					this._optimizer._log += message$0$3 + "\n";
					replaceCb(new IntegerLiteralExpression(new Token$0(~ exprAsNumber(baseExpr) + "")));
				}
			} else {
				if (expr instanceof AdditiveExpression) {
					firstExpr = expr._expr1;
					secondExpr = expr._expr2;
					if (_FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$(this, expr, replaceCb)) {
					} else {
						if (firstExpr instanceof StringLiteralExpression && secondExpr instanceof StringLiteralExpression) {
							replaceCb(new StringLiteralExpression(new Token$1(Util$encodeStringLiteral$S(Util$decodeStringLiteral$S(firstExpr._token._value) + Util$decodeStringLiteral$S(secondExpr._token._value)), false)));
						}
					}
				} else {
					if (expr instanceof EqualityExpression) {
						_FoldConstantCommand$_foldEqualityExpression$L_FoldConstantCommand$LEqualityExpression$F$LExpression$V$(this, expr, replaceCb);
					} else {
						if (expr instanceof BinaryNumberExpression || expr instanceof ShiftExpression) {
							_FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$(this, expr, replaceCb);
						} else {
							if (expr instanceof AsExpression) {
								_FoldConstantCommand$_foldAsExpression$L_FoldConstantCommand$LAsExpression$F$LExpression$V$(this, expr, replaceCb);
							} else {
								if (expr instanceof LogicalNotExpression) {
									innerExpr = expr._expr;
									if ((condition = _Util$conditionIsConstant$LExpression$(innerExpr)) != null) {
										replaceCb(new BooleanLiteralExpression(new Token$1((condition ? "false" : "true"), false)));
									}
								} else {
									if (expr instanceof LogicalExpression) {
										firstExpr = expr._expr1;
										secondExpr = expr._expr2;
										if ((condition = _Util$conditionIsConstant$LExpression$(firstExpr)) != null) {
											this$0 = expr._token;
											op = this$0._value;
											if (op === "||" && condition) {
												replaceCb(new AsExpression(firstExpr._token, firstExpr, Type.booleanType));
											} else {
												if (op === "||" && ! condition) {
													replaceCb(new AsExpression(secondExpr._token, secondExpr, Type.booleanType));
												} else {
													if (op === "&&" && condition) {
														replaceCb(new AsExpression(secondExpr._token, secondExpr, Type.booleanType));
													} else {
														if (op === "&&" && ! condition) {
															replaceCb(new AsExpression(firstExpr._token, firstExpr, Type.booleanType));
														} else {
															throw new Error("logic flaw");
														}
													}
												}
											}
										}
									} else {
										if (expr instanceof ConditionalExpression) {
											conditionalExpr = expr;
											condExpr = conditionalExpr._condExpr;
											if ((condition = _Util$conditionIsConstant$LExpression$(condExpr)) != null) {
												ifTrueExpr = conditionalExpr._ifTrueExpr || condExpr;
												ifFalseExpr = conditionalExpr._ifFalseExpr;
												replaceCb(condition ? ifTrueExpr : ifFalseExpr);
											}
										} else {
											if (expr instanceof CallExpression) {
												callExpr = expr;
												if (callExpr._expr instanceof PropertyExpression) {
													allArgsAreConstants = true;
													this$1 = callExpr._args;
													for (i$0 in this$1) {
														(function (expr) {
															if (! (expr instanceof IntegerLiteralExpression || expr instanceof NumberLiteralExpression || expr instanceof BooleanLiteralExpression || expr instanceof StringLiteralExpression)) {
																allArgsAreConstants = false;
															}
														})(this$1[i$0]);
													}
													if (allArgsAreConstants) {
														_FoldConstantCommand$_foldCallExpression$L_FoldConstantCommand$LCallExpression$F$LExpression$V$(this, callExpr, replaceCb);
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return true;
};


function _FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$($this, expr, replaceCb) {
	var exprAsNumber;
	var propertyExpr;
	var holderType;
	var member;
	var foldedExpr;
	var calculateCb;
	var baseExpr;
	var firstExpr;
	var secondExpr;
	var innerExpr;
	var condition;
	var op;
	var conditionalExpr;
	var condExpr;
	var ifTrueExpr;
	var ifFalseExpr;
	var callExpr;
	var allArgsAreConstants;
	var message$0;
	var message$0$0;
	var message$1;
	var message$0$1;
	var getNotation$this$0;
	var message$2;
	var message$0$2;
	var getNotation$this$1;
	var message$3;
	var message$0$3;
	var getNotation$this$2;
	var this$0;
	var this$1;
	var i$0;
	var _token$0;
	expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
		return _FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$($this, expr, replaceCb);
	}));
	function exprAsNumber(expr) {
		return +expr._token._value;
	}
	if (expr instanceof PropertyExpression) {
		propertyExpr = expr;
		holderType = propertyExpr.getHolderType$();
		if (propertyExpr._expr.isClassSpecifier$()) {
			member = null;
			ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(holderType.getClassDef$(), (function (m) {
				if (m._nameToken._value === propertyExpr._identifierToken._value) {
					member = m;
				}
				return member == null;
			}));
			if (member != null && (member._flags & 1) !== 0) {
				_FoldConstantCommand$_foldStaticConst$L_FoldConstantCommand$LMemberVariableDefinition$($this, member);
				foldedExpr = _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$($this, member._initialValue, member.getType$());
				if (foldedExpr != null) {
					foldedExpr = _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$($this, foldedExpr, propertyExpr._type);
					if (foldedExpr != null && ! (foldedExpr instanceof StringLiteralExpression && Util$decodeStringLiteral$S(foldedExpr._token._value).length > 64)) {
						message$0 = "folding property " + member.getNotation$() + " at " + (_token$0 = propertyExpr._token)._filename + ":" + (_token$0._lineNumber + "");
						message$0$0 = "[" + $this._identifier + "] " + message$0;
						$this._optimizer._log += message$0$0 + "\n";
						replaceCb(foldedExpr);
					}
				}
			}
		} else {
			if (propertyExpr._expr instanceof StringLiteralExpression) {
				if (propertyExpr._identifierToken._value === "length") {
					replaceCb(new NumberLiteralExpression(new Token$0(Util$decodeStringLiteral$S(propertyExpr._expr._token._value).length + "")));
				}
			}
		}
	} else {
		if (expr instanceof SignExpression) {
			switch (expr._token._value) {
			case "+":
				calculateCb = (function (x) {
					return + x;
				});
				break;
			case "-":
				calculateCb = (function (x) {
					return - x;
				});
				break;
			default:
				return false;
			}
			baseExpr = expr._expr;
			if (baseExpr instanceof IntegerLiteralExpression) {
				message$1 = "folding operator (number) " + (getNotation$this$0 = expr._token, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + ""));
				message$0$1 = "[" + $this._identifier + "] " + message$1;
				$this._optimizer._log += message$0$1 + "\n";
				replaceCb(new IntegerLiteralExpression(new Token$0(calculateCb(exprAsNumber(baseExpr)) + "")));
			} else {
				if (baseExpr instanceof NumberLiteralExpression) {
					message$2 = "folding operator (number) " + (getNotation$this$1 = expr._token, "'" + getNotation$this$1._value + "'" + " at " + (getNotation$this$1._filename || "<<unknown>>") + ":" + (getNotation$this$1._lineNumber + ""));
					message$0$2 = "[" + $this._identifier + "] " + message$2;
					$this._optimizer._log += message$0$2 + "\n";
					replaceCb(new NumberLiteralExpression(new Token$0(calculateCb(exprAsNumber(baseExpr)) + "")));
				}
			}
		} else {
			if (expr instanceof BitwiseNotExpression) {
				baseExpr = expr._expr;
				if (baseExpr instanceof NumberLiteralExpression || baseExpr instanceof IntegerLiteralExpression) {
					message$3 = "folding operator " + (getNotation$this$2 = expr._token, "'" + getNotation$this$2._value + "'" + " at " + (getNotation$this$2._filename || "<<unknown>>") + ":" + (getNotation$this$2._lineNumber + ""));
					message$0$3 = "[" + $this._identifier + "] " + message$3;
					$this._optimizer._log += message$0$3 + "\n";
					replaceCb(new IntegerLiteralExpression(new Token$0(~ exprAsNumber(baseExpr) + "")));
				}
			} else {
				if (expr instanceof AdditiveExpression) {
					firstExpr = expr._expr1;
					secondExpr = expr._expr2;
					if (_FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$($this, expr, replaceCb)) {
					} else {
						if (firstExpr instanceof StringLiteralExpression && secondExpr instanceof StringLiteralExpression) {
							replaceCb(new StringLiteralExpression(new Token$1(Util$encodeStringLiteral$S(Util$decodeStringLiteral$S(firstExpr._token._value) + Util$decodeStringLiteral$S(secondExpr._token._value)), false)));
						}
					}
				} else {
					if (expr instanceof EqualityExpression) {
						_FoldConstantCommand$_foldEqualityExpression$L_FoldConstantCommand$LEqualityExpression$F$LExpression$V$($this, expr, replaceCb);
					} else {
						if (expr instanceof BinaryNumberExpression || expr instanceof ShiftExpression) {
							_FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$($this, expr, replaceCb);
						} else {
							if (expr instanceof AsExpression) {
								_FoldConstantCommand$_foldAsExpression$L_FoldConstantCommand$LAsExpression$F$LExpression$V$($this, expr, replaceCb);
							} else {
								if (expr instanceof LogicalNotExpression) {
									innerExpr = expr._expr;
									if ((condition = _Util$conditionIsConstant$LExpression$(innerExpr)) != null) {
										replaceCb(new BooleanLiteralExpression(new Token$1((condition ? "false" : "true"), false)));
									}
								} else {
									if (expr instanceof LogicalExpression) {
										firstExpr = expr._expr1;
										secondExpr = expr._expr2;
										if ((condition = _Util$conditionIsConstant$LExpression$(firstExpr)) != null) {
											this$0 = expr._token;
											op = this$0._value;
											if (op === "||" && condition) {
												replaceCb(new AsExpression(firstExpr._token, firstExpr, Type.booleanType));
											} else {
												if (op === "||" && ! condition) {
													replaceCb(new AsExpression(secondExpr._token, secondExpr, Type.booleanType));
												} else {
													if (op === "&&" && condition) {
														replaceCb(new AsExpression(secondExpr._token, secondExpr, Type.booleanType));
													} else {
														if (op === "&&" && ! condition) {
															replaceCb(new AsExpression(firstExpr._token, firstExpr, Type.booleanType));
														} else {
															throw new Error("logic flaw");
														}
													}
												}
											}
										}
									} else {
										if (expr instanceof ConditionalExpression) {
											conditionalExpr = expr;
											condExpr = conditionalExpr._condExpr;
											if ((condition = _Util$conditionIsConstant$LExpression$(condExpr)) != null) {
												ifTrueExpr = conditionalExpr._ifTrueExpr || condExpr;
												ifFalseExpr = conditionalExpr._ifFalseExpr;
												replaceCb(condition ? ifTrueExpr : ifFalseExpr);
											}
										} else {
											if (expr instanceof CallExpression) {
												callExpr = expr;
												if (callExpr._expr instanceof PropertyExpression) {
													allArgsAreConstants = true;
													this$1 = callExpr._args;
													for (i$0 in this$1) {
														(function (expr) {
															if (! (expr instanceof IntegerLiteralExpression || expr instanceof NumberLiteralExpression || expr instanceof BooleanLiteralExpression || expr instanceof StringLiteralExpression)) {
																allArgsAreConstants = false;
															}
														})(this$1[i$0]);
													}
													if (allArgsAreConstants) {
														_FoldConstantCommand$_foldCallExpression$L_FoldConstantCommand$LCallExpression$F$LExpression$V$($this, callExpr, replaceCb);
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return true;
};

_FoldConstantCommand._optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$ = _FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$;

_FoldConstantCommand.prototype._foldCallExpression$LCallExpression$F$LExpression$V$ = function (callExpr, replaceCb) {
	var $this = this;
	var propertyExpr;
	var holderType;
	var argAsNumber;
	var member;
	var s;
	var recvStr;
	var message$0;
	var message$0$0;
	var message$1;
	var message$0$1;
	var message$2;
	var message$0$2;
	var message$3;
	var message$0$3;
	var message$4;
	var message$0$4;
	var message$5;
	var message$0$5;
	var this$0;
	var i$0;
	var message$6;
	var message$0$6;
	var arg$0;
	propertyExpr = callExpr._expr;
	holderType = propertyExpr.getHolderType$();
	if ((holderType.getClassDef$().flags$() & 16) === 0) {
		return;
	}
	function argAsNumber(index) {
		return +callExpr._args[index]._token._value;
	}
	member = null;
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(holderType.getClassDef$(), (function (m) {
		if (m._nameToken._value === propertyExpr._identifierToken._value) {
			member = m;
		}
		return member == null;
	}));
	if (member != null && (member._flags & 2048) === 0) {
		return;
	}
	if (propertyExpr._expr.isClassSpecifier$()) {
		if (ClassDefinition$classFullName$LClassDefinition$(holderType.getClassDef$()) === "Math") {
			switch (propertyExpr._identifierToken._value) {
			case "sqrt":
				message$0 = "folding " + member.getNotation$();
				message$0$0 = "[" + this._identifier + "] " + message$0;
				this._optimizer._log += message$0$0 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$0(Math.sqrt(argAsNumber(0)) + "")));
				break;
			case "log":
				message$1 = "folding " + member.getNotation$();
				message$0$1 = "[" + this._identifier + "] " + message$1;
				this._optimizer._log += message$0$1 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$0(Math.log(argAsNumber(0)) + "")));
				break;
			case "pow":
				message$2 = "folding " + member.getNotation$();
				message$0$2 = "[" + this._identifier + "] " + message$2;
				this._optimizer._log += message$0$2 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$0(Math.pow(argAsNumber(0), argAsNumber(1)) + "")));
				break;
			case "sin":
				message$3 = "folding " + member.getNotation$();
				message$0$3 = "[" + this._identifier + "] " + message$3;
				this._optimizer._log += message$0$3 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$0(Math.sin(argAsNumber(0)) + "")));
				break;
			case "cos":
				message$4 = "folding " + member.getNotation$();
				message$0$4 = "[" + this._identifier + "] " + message$4;
				this._optimizer._log += message$0$4 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$0(Math.cos(argAsNumber(0)) + "")));
				break;
			}
		}
		if (ClassDefinition$classFullName$LClassDefinition$(holderType.getClassDef$()) === "String") {
			switch (propertyExpr._identifierToken._value) {
			case "fromCharCode":
				message$5 = "folding " + member.getNotation$();
				message$0$5 = "[" + this._identifier + "] " + message$5;
				this._optimizer._log += message$0$5 + "\n";
				s = "";
				this$0 = callExpr._args;
				for (i$0 in this$0) {
					arg$0 = this$0[i$0];
					s += String.fromCharCode(+arg$0._token._value);
				}
				replaceCb(new StringLiteralExpression(new Token$0(Util$encodeStringLiteral$S(s))));
				break;
			}
		}
	} else {
		if (propertyExpr._expr instanceof StringLiteralExpression) {
			switch (propertyExpr._identifierToken._value) {
			case "charCodeAt":
				message$6 = "folding " + member.getNotation$();
				message$0$6 = "[" + this._identifier + "] " + message$6;
				this._optimizer._log += message$0$6 + "\n";
				recvStr = Util$decodeStringLiteral$S(propertyExpr._expr._token._value);
				replaceCb(new NumberLiteralExpression(new Token$0(recvStr.charCodeAt(argAsNumber(0)) + "")));
				break;
			}
		}
	}
};


function _FoldConstantCommand$_foldCallExpression$L_FoldConstantCommand$LCallExpression$F$LExpression$V$($this, callExpr, replaceCb) {
	var propertyExpr;
	var holderType;
	var argAsNumber;
	var member;
	var s;
	var recvStr;
	var message$0;
	var message$0$0;
	var message$1;
	var message$0$1;
	var message$2;
	var message$0$2;
	var message$3;
	var message$0$3;
	var message$4;
	var message$0$4;
	var message$5;
	var message$0$5;
	var this$0;
	var i$0;
	var message$6;
	var message$0$6;
	var arg$0;
	propertyExpr = callExpr._expr;
	holderType = propertyExpr.getHolderType$();
	if ((holderType.getClassDef$().flags$() & 16) === 0) {
		return;
	}
	function argAsNumber(index) {
		return +callExpr._args[index]._token._value;
	}
	member = null;
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(holderType.getClassDef$(), (function (m) {
		if (m._nameToken._value === propertyExpr._identifierToken._value) {
			member = m;
		}
		return member == null;
	}));
	if (member != null && (member._flags & 2048) === 0) {
		return;
	}
	if (propertyExpr._expr.isClassSpecifier$()) {
		if (ClassDefinition$classFullName$LClassDefinition$(holderType.getClassDef$()) === "Math") {
			switch (propertyExpr._identifierToken._value) {
			case "sqrt":
				message$0 = "folding " + member.getNotation$();
				message$0$0 = "[" + $this._identifier + "] " + message$0;
				$this._optimizer._log += message$0$0 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$0(Math.sqrt(argAsNumber(0)) + "")));
				break;
			case "log":
				message$1 = "folding " + member.getNotation$();
				message$0$1 = "[" + $this._identifier + "] " + message$1;
				$this._optimizer._log += message$0$1 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$0(Math.log(argAsNumber(0)) + "")));
				break;
			case "pow":
				message$2 = "folding " + member.getNotation$();
				message$0$2 = "[" + $this._identifier + "] " + message$2;
				$this._optimizer._log += message$0$2 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$0(Math.pow(argAsNumber(0), argAsNumber(1)) + "")));
				break;
			case "sin":
				message$3 = "folding " + member.getNotation$();
				message$0$3 = "[" + $this._identifier + "] " + message$3;
				$this._optimizer._log += message$0$3 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$0(Math.sin(argAsNumber(0)) + "")));
				break;
			case "cos":
				message$4 = "folding " + member.getNotation$();
				message$0$4 = "[" + $this._identifier + "] " + message$4;
				$this._optimizer._log += message$0$4 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$0(Math.cos(argAsNumber(0)) + "")));
				break;
			}
		}
		if (ClassDefinition$classFullName$LClassDefinition$(holderType.getClassDef$()) === "String") {
			switch (propertyExpr._identifierToken._value) {
			case "fromCharCode":
				message$5 = "folding " + member.getNotation$();
				message$0$5 = "[" + $this._identifier + "] " + message$5;
				$this._optimizer._log += message$0$5 + "\n";
				s = "";
				this$0 = callExpr._args;
				for (i$0 in this$0) {
					arg$0 = this$0[i$0];
					s += String.fromCharCode(+arg$0._token._value);
				}
				replaceCb(new StringLiteralExpression(new Token$0(Util$encodeStringLiteral$S(s))));
				break;
			}
		}
	} else {
		if (propertyExpr._expr instanceof StringLiteralExpression) {
			switch (propertyExpr._identifierToken._value) {
			case "charCodeAt":
				message$6 = "folding " + member.getNotation$();
				message$0$6 = "[" + $this._identifier + "] " + message$6;
				$this._optimizer._log += message$0$6 + "\n";
				recvStr = Util$decodeStringLiteral$S(propertyExpr._expr._token._value);
				replaceCb(new NumberLiteralExpression(new Token$0(recvStr.charCodeAt(argAsNumber(0)) + "")));
				break;
			}
		}
	}
};

_FoldConstantCommand._foldCallExpression$L_FoldConstantCommand$LCallExpression$F$LExpression$V$ = _FoldConstantCommand$_foldCallExpression$L_FoldConstantCommand$LCallExpression$F$LExpression$V$;

_FoldConstantCommand.prototype._foldEqualityExpression$LEqualityExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var firstExpr;
	var secondExpr;
	var isEqual;
	var result;
	firstExpr = expr._expr1;
	secondExpr = expr._expr2;
	isEqual = null;
	if (firstExpr instanceof StringLiteralExpression && secondExpr instanceof StringLiteralExpression) {
		isEqual = Util$decodeStringLiteral$S(firstExpr._token._value) === Util$decodeStringLiteral$S(secondExpr._token._value);
	} else {
		if ((firstExpr instanceof NumberLiteralExpression || firstExpr instanceof IntegerLiteralExpression) && (secondExpr instanceof NumberLiteralExpression || secondExpr instanceof IntegerLiteralExpression)) {
			isEqual = +firstExpr._token._value === +secondExpr._token._value;
		}
	}
	if (isEqual != null) {
		result = (expr._token._value === "==" ? isEqual : ! isEqual);
		replaceCb(new BooleanLiteralExpression(new Token$1((result ? "true" : "false"), true)));
	}
};


function _FoldConstantCommand$_foldEqualityExpression$L_FoldConstantCommand$LEqualityExpression$F$LExpression$V$($this, expr, replaceCb) {
	var firstExpr;
	var secondExpr;
	var isEqual;
	var result;
	firstExpr = expr._expr1;
	secondExpr = expr._expr2;
	isEqual = null;
	if (firstExpr instanceof StringLiteralExpression && secondExpr instanceof StringLiteralExpression) {
		isEqual = Util$decodeStringLiteral$S(firstExpr._token._value) === Util$decodeStringLiteral$S(secondExpr._token._value);
	} else {
		if ((firstExpr instanceof NumberLiteralExpression || firstExpr instanceof IntegerLiteralExpression) && (secondExpr instanceof NumberLiteralExpression || secondExpr instanceof IntegerLiteralExpression)) {
			isEqual = +firstExpr._token._value === +secondExpr._token._value;
		}
	}
	if (isEqual != null) {
		result = (expr._token._value === "==" ? isEqual : ! isEqual);
		replaceCb(new BooleanLiteralExpression(new Token$1((result ? "true" : "false"), true)));
	}
};

_FoldConstantCommand._foldEqualityExpression$L_FoldConstantCommand$LEqualityExpression$F$LExpression$V$ = _FoldConstantCommand$_foldEqualityExpression$L_FoldConstantCommand$LEqualityExpression$F$LExpression$V$;

_FoldConstantCommand.prototype._foldNumericBinaryExpression$LBinaryExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var $this = this;
	var exprIsZero;
	var exprIsOne;
	var _isIntegerOrNumberLiteralExpression$expr$0;
	var _isIntegerOrNumberLiteralExpression$expr$1;
	if ((_isIntegerOrNumberLiteralExpression$expr$0 = expr._expr1, _isIntegerOrNumberLiteralExpression$expr$0 instanceof NumberLiteralExpression || _isIntegerOrNumberLiteralExpression$expr$0 instanceof IntegerLiteralExpression) && (_isIntegerOrNumberLiteralExpression$expr$1 = expr._expr2, _isIntegerOrNumberLiteralExpression$expr$1 instanceof NumberLiteralExpression || _isIntegerOrNumberLiteralExpression$expr$1 instanceof IntegerLiteralExpression)) {
		return _FoldConstantCommand$_foldNumericBinaryExpressionOfConstants$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$(this, expr, replaceCb);
	}
	function exprIsZero(expr) {
		return expr instanceof NumberLiteralExpression && +expr._token._value === 0;
	}
	function exprIsOne(expr) {
		return expr instanceof NumberLiteralExpression && +expr._token._value === 1;
	}
	switch (expr._token._value) {
	case "+":
		if (exprIsZero(expr._expr1)) {
			replaceCb(expr._expr2);
			return true;
		} else {
			if (exprIsZero(expr._expr2)) {
				replaceCb(expr._expr1);
				return true;
			}
		}
		break;
	case "-":
		if (exprIsZero(expr._expr1)) {
			replaceCb(new SignExpression(new Token$1("-", false), expr._expr2));
			return true;
		} else {
			if (exprIsZero(expr._expr2)) {
				replaceCb(expr._expr1);
				return true;
			}
		}
		break;
	case "*":
		if (exprIsOne(expr._expr1)) {
			replaceCb(expr._expr2);
			return true;
		} else {
			if (exprIsOne(expr._expr2)) {
				replaceCb(expr._expr1);
				return true;
			}
		}
		break;
	case "/":
		if (exprIsOne(expr._expr2)) {
			replaceCb(expr._expr1);
			return true;
		}
		break;
	}
	return false;
};


function _FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$($this, expr, replaceCb) {
	var exprIsZero;
	var exprIsOne;
	var _isIntegerOrNumberLiteralExpression$expr$0;
	var _isIntegerOrNumberLiteralExpression$expr$1;
	if ((_isIntegerOrNumberLiteralExpression$expr$0 = expr._expr1, _isIntegerOrNumberLiteralExpression$expr$0 instanceof NumberLiteralExpression || _isIntegerOrNumberLiteralExpression$expr$0 instanceof IntegerLiteralExpression) && (_isIntegerOrNumberLiteralExpression$expr$1 = expr._expr2, _isIntegerOrNumberLiteralExpression$expr$1 instanceof NumberLiteralExpression || _isIntegerOrNumberLiteralExpression$expr$1 instanceof IntegerLiteralExpression)) {
		return _FoldConstantCommand$_foldNumericBinaryExpressionOfConstants$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$($this, expr, replaceCb);
	}
	function exprIsZero(expr) {
		return expr instanceof NumberLiteralExpression && +expr._token._value === 0;
	}
	function exprIsOne(expr) {
		return expr instanceof NumberLiteralExpression && +expr._token._value === 1;
	}
	switch (expr._token._value) {
	case "+":
		if (exprIsZero(expr._expr1)) {
			replaceCb(expr._expr2);
			return true;
		} else {
			if (exprIsZero(expr._expr2)) {
				replaceCb(expr._expr1);
				return true;
			}
		}
		break;
	case "-":
		if (exprIsZero(expr._expr1)) {
			replaceCb(new SignExpression(new Token$1("-", false), expr._expr2));
			return true;
		} else {
			if (exprIsZero(expr._expr2)) {
				replaceCb(expr._expr1);
				return true;
			}
		}
		break;
	case "*":
		if (exprIsOne(expr._expr1)) {
			replaceCb(expr._expr2);
			return true;
		} else {
			if (exprIsOne(expr._expr2)) {
				replaceCb(expr._expr1);
				return true;
			}
		}
		break;
	case "/":
		if (exprIsOne(expr._expr2)) {
			replaceCb(expr._expr1);
			return true;
		}
		break;
	}
	return false;
};

_FoldConstantCommand._foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$ = _FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$;

_FoldConstantCommand.prototype._foldNumericBinaryExpressionOfConstants$LBinaryExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var $this = this;
	switch (expr._token._value) {
	case "*":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x * y;
		}));
		break;
	case "+":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x + y;
		}));
		break;
	case "-":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x - y;
		}));
		break;
	case "%":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x % y;
		}));
		break;
	case "/":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x / y;
		}));
		break;
	case ">>>":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x >>> y;
		}));
		break;
	case ">>":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x >> y;
		}));
		break;
	case "<<":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x << y;
		}));
		break;
	case "&":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x & y;
		}));
		break;
	case "|":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x | y;
		}));
		break;
	case "^":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x ^ y;
		}));
		break;
	case "<":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$(this, expr, replaceCb, (function (x, y) {
			return x < y;
		}));
		break;
	case "<=":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$(this, expr, replaceCb, (function (x, y) {
			return x <= y;
		}));
		break;
	case ">":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$(this, expr, replaceCb, (function (x, y) {
			return x > y;
		}));
		break;
	case ">=":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$(this, expr, replaceCb, (function (x, y) {
			return x >= y;
		}));
		break;
	default:
		return false;
	}
	return true;
};


function _FoldConstantCommand$_foldNumericBinaryExpressionOfConstants$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$($this, expr, replaceCb) {
	switch (expr._token._value) {
	case "*":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x * y;
		}));
		break;
	case "+":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x + y;
		}));
		break;
	case "-":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x - y;
		}));
		break;
	case "%":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x % y;
		}));
		break;
	case "/":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x / y;
		}));
		break;
	case ">>>":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x >>> y;
		}));
		break;
	case ">>":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x >> y;
		}));
		break;
	case "<<":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x << y;
		}));
		break;
	case "&":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x & y;
		}));
		break;
	case "|":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x | y;
		}));
		break;
	case "^":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x ^ y;
		}));
		break;
	case "<":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$($this, expr, replaceCb, (function (x, y) {
			return x < y;
		}));
		break;
	case "<=":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$($this, expr, replaceCb, (function (x, y) {
			return x <= y;
		}));
		break;
	case ">":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$($this, expr, replaceCb, (function (x, y) {
			return x > y;
		}));
		break;
	case ">=":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$($this, expr, replaceCb, (function (x, y) {
			return x >= y;
		}));
		break;
	default:
		return false;
	}
	return true;
};

_FoldConstantCommand._foldNumericBinaryExpressionOfConstants$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$ = _FoldConstantCommand$_foldNumericBinaryExpressionOfConstants$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$;

_FoldConstantCommand.prototype._foldNumericBinaryExpressionAsNumeric$LBinaryExpression$F$LExpression$V$F$NNN$ = function (expr, replaceCb, calcCb) {
	if (expr._expr1 instanceof IntegerLiteralExpression && expr._expr2 instanceof IntegerLiteralExpression) {
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, calcCb);
	} else {
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, calcCb);
	}
};


function _FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, calcCb) {
	if (expr._expr1 instanceof IntegerLiteralExpression && expr._expr2 instanceof IntegerLiteralExpression) {
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, calcCb);
	} else {
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, calcCb);
	}
};

_FoldConstantCommand._foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$ = _FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$;

_FoldConstantCommand.prototype._foldNumericBinaryExpressionAsInteger$LBinaryExpression$F$LExpression$V$F$NNN$ = function (expr, replaceCb, calcCb) {
	var value;
	var message$0;
	var message$0$0;
	var getNotation$this$0;
	value = calcCb(+expr._expr1._token._value, +expr._expr2._token._value);
	message$0 = "folding operator " + (getNotation$this$0 = expr._token, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + "")) + " to int: " + (value + "");
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	if (value % 1 !== 0) {
		throw new Error("value is not an integer");
	}
	replaceCb(new IntegerLiteralExpression(new Token$0(value + "")));
};


function _FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, calcCb) {
	var value;
	var message$0;
	var message$0$0;
	var getNotation$this$0;
	value = calcCb(+expr._expr1._token._value, +expr._expr2._token._value);
	message$0 = "folding operator " + (getNotation$this$0 = expr._token, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + "")) + " to int: " + (value + "");
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	$this._optimizer._log += message$0$0 + "\n";
	if (value % 1 !== 0) {
		throw new Error("value is not an integer");
	}
	replaceCb(new IntegerLiteralExpression(new Token$0(value + "")));
};

_FoldConstantCommand._foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$ = _FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$;

_FoldConstantCommand.prototype._foldNumericBinaryExpressionAsNumber$LBinaryExpression$F$LExpression$V$F$NNN$ = function (expr, replaceCb, calcCb) {
	var value;
	var message$0;
	var message$0$0;
	var getNotation$this$0;
	value = calcCb(+expr._expr1._token._value, +expr._expr2._token._value);
	message$0 = "folding operator " + (getNotation$this$0 = expr._token, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + "")) + " to number: " + (value + "");
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	replaceCb(new NumberLiteralExpression(new Token$0(value + "")));
};


function _FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, calcCb) {
	var value;
	var message$0;
	var message$0$0;
	var getNotation$this$0;
	value = calcCb(+expr._expr1._token._value, +expr._expr2._token._value);
	message$0 = "folding operator " + (getNotation$this$0 = expr._token, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + "")) + " to number: " + (value + "");
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	$this._optimizer._log += message$0$0 + "\n";
	replaceCb(new NumberLiteralExpression(new Token$0(value + "")));
};

_FoldConstantCommand._foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$ = _FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$;

_FoldConstantCommand.prototype._foldNumericBinaryExpressionAsBoolean$LBinaryExpression$F$LExpression$V$F$NNB$ = function (expr, replaceCb, calcCb) {
	var value;
	var message$0;
	var message$0$0;
	var getNotation$this$0;
	value = calcCb(+expr._expr1._token._value, +expr._expr2._token._value);
	message$0 = "folding operator " + (getNotation$this$0 = expr._token, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + "")) + " to boolean: " + (value + "");
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	replaceCb(new BooleanLiteralExpression(new Token$0(value + "")));
};


function _FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$($this, expr, replaceCb, calcCb) {
	var value;
	var message$0;
	var message$0$0;
	var getNotation$this$0;
	value = calcCb(+expr._expr1._token._value, +expr._expr2._token._value);
	message$0 = "folding operator " + (getNotation$this$0 = expr._token, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + "")) + " to boolean: " + (value + "");
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	$this._optimizer._log += message$0$0 + "\n";
	replaceCb(new BooleanLiteralExpression(new Token$0(value + "")));
};

_FoldConstantCommand._foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$ = _FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$;

_FoldConstantCommand.prototype._isIntegerOrNumberLiteralExpression$LExpression$ = function (expr) {
	return expr instanceof NumberLiteralExpression || expr instanceof IntegerLiteralExpression;
};


function _FoldConstantCommand$_isIntegerOrNumberLiteralExpression$L_FoldConstantCommand$LExpression$($this, expr) {
	return expr instanceof NumberLiteralExpression || expr instanceof IntegerLiteralExpression;
};

_FoldConstantCommand._isIntegerOrNumberLiteralExpression$L_FoldConstantCommand$LExpression$ = _FoldConstantCommand$_isIntegerOrNumberLiteralExpression$L_FoldConstantCommand$LExpression$;

_FoldConstantCommand.prototype._foldStaticConst$LMemberVariableDefinition$ = function (member) {
	var $this = this;
	var stash;
	var initialValue;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$(this, member);
	if (stash.isOptimized) {
		return;
	}
	stash.isOptimized = true;
	initialValue = member._initialValue;
	if (initialValue != null) {
		_FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$(this, initialValue, (function (expr) {
			member._initialValue = expr;
		}));
	}
};


function _FoldConstantCommand$_foldStaticConst$L_FoldConstantCommand$LMemberVariableDefinition$($this, member) {
	var stash;
	var initialValue;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, member);
	if (stash.isOptimized) {
		return;
	}
	stash.isOptimized = true;
	initialValue = member._initialValue;
	if (initialValue != null) {
		_FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$($this, initialValue, (function (expr) {
			member._initialValue = expr;
		}));
	}
};

_FoldConstantCommand._foldStaticConst$L_FoldConstantCommand$LMemberVariableDefinition$ = _FoldConstantCommand$_foldStaticConst$L_FoldConstantCommand$LMemberVariableDefinition$;

_FoldConstantCommand.prototype._toFoldedExpr$LExpression$LType$ = function (expr, type) {
	if (expr instanceof NullExpression) {
		return expr;
	} else {
		if (expr instanceof BooleanLiteralExpression) {
			return expr;
		} else {
			if (expr instanceof IntegerLiteralExpression) {
				return expr;
			} else {
				if (expr instanceof NumberLiteralExpression) {
					if ((type instanceof NullableType ? type._baseType : type).equals$LType$(Type.integerType)) {
						return new IntegerLiteralExpression(new Token$0((expr._token._value | 0) + ""));
					}
					return expr;
				} else {
					if (expr instanceof StringLiteralExpression) {
						return expr;
					}
				}
			}
		}
	}
	return null;
};


function _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$($this, expr, type) {
	if (expr instanceof NullExpression) {
		return expr;
	} else {
		if (expr instanceof BooleanLiteralExpression) {
			return expr;
		} else {
			if (expr instanceof IntegerLiteralExpression) {
				return expr;
			} else {
				if (expr instanceof NumberLiteralExpression) {
					if ((type instanceof NullableType ? type._baseType : type).equals$LType$(Type.integerType)) {
						return new IntegerLiteralExpression(new Token$0((expr._token._value | 0) + ""));
					}
					return expr;
				} else {
					if (expr instanceof StringLiteralExpression) {
						return expr;
					}
				}
			}
		}
	}
	return null;
};

_FoldConstantCommand._toFoldedExpr$L_FoldConstantCommand$LExpression$LType$ = _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$;

_FoldConstantCommand.prototype._foldAsExpression$LAsExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var baseExpr;
	var message$0$0;
	var message$0$1;
	var message$0$2;
	var message$0$3;
	var message$0$4;
	var message$0$5;
	var message$0$6;
	var message$0$7;
	var message$0$8;
	var message$0$9;
	var message$0$10;
	var message$0$11;
	baseExpr = expr._expr;
	if (expr._type.equals$LType$(Type.stringType)) {
		if (baseExpr.getType$().equals$LType$(Type.stringType)) {
			message$0$0 = "[" + this._identifier + "] " + "folding type cast: string as string";
			this._optimizer._log += message$0$0 + "\n";
			replaceCb(baseExpr);
		} else {
			if (baseExpr instanceof BooleanLiteralExpression || baseExpr instanceof NumberLiteralExpression || baseExpr instanceof IntegerLiteralExpression) {
				message$0$1 = "[" + this._identifier + "] " + "folding type cast: primitive literal as string";
				this._optimizer._log += message$0$1 + "\n";
				replaceCb(new StringLiteralExpression(new Token$1(Util$encodeStringLiteral$S(baseExpr._token._value), false)));
			}
		}
	} else {
		if (expr._type.equals$LType$(Type.numberType)) {
			if (baseExpr.getType$().equals$LType$(Type.numberType)) {
				message$0$2 = "[" + this._identifier + "] " + "folding type cast: number as number";
				this._optimizer._log += message$0$2 + "\n";
				replaceCb(baseExpr);
			} else {
				if (baseExpr instanceof StringLiteralExpression) {
					message$0$3 = "[" + this._identifier + "] " + "folding type cast: string literal as number";
					this._optimizer._log += message$0$3 + "\n";
					replaceCb(new NumberLiteralExpression(new Token$1(+Util$decodeStringLiteral$S(baseExpr._token._value) + "", false)));
				} else {
					if (baseExpr instanceof IntegerLiteralExpression) {
						message$0$4 = "[" + this._identifier + "] " + "folding type cast: int literal as number";
						this._optimizer._log += message$0$4 + "\n";
						replaceCb(new NumberLiteralExpression(new Token$1(+baseExpr._token._value + "", false)));
					}
				}
			}
		} else {
			if (expr._type.equals$LType$(Type.integerType)) {
				if (baseExpr.getType$().equals$LType$(Type.integerType)) {
					message$0$5 = "[" + this._identifier + "] " + "folding type cast: int as int";
					this._optimizer._log += message$0$5 + "\n";
					replaceCb(baseExpr);
				} else {
					if (baseExpr instanceof StringLiteralExpression) {
						message$0$6 = "[" + this._identifier + "] " + "folding type cast: string literal as int";
						this._optimizer._log += message$0$6 + "\n";
						replaceCb(new IntegerLiteralExpression(new Token$1((Util$decodeStringLiteral$S(baseExpr._token._value) | 0) + "", false)));
					} else {
						if (baseExpr instanceof NumberLiteralExpression) {
							message$0$7 = "[" + this._identifier + "] " + "folding type cast: number literal as int";
							this._optimizer._log += message$0$7 + "\n";
							replaceCb(new IntegerLiteralExpression(new Token$1((baseExpr._token._value | 0) + "", false)));
						}
					}
				}
			} else {
				if (expr._type.equals$LType$(Type.booleanType)) {
					if (baseExpr.getType$().equals$LType$(Type.booleanType)) {
						message$0$8 = "[" + this._identifier + "] " + "folding type cast: boolean as boolean";
						this._optimizer._log += message$0$8 + "\n";
						replaceCb(baseExpr);
					} else {
						if (baseExpr instanceof StringLiteralExpression) {
							message$0$9 = "[" + this._identifier + "] " + "folding type cast: string literal as boolean";
							this._optimizer._log += message$0$9 + "\n";
							replaceCb(new BooleanLiteralExpression(new Token$1(!! Util$decodeStringLiteral$S(baseExpr._token._value) + "", false)));
						} else {
							if (baseExpr instanceof NumberLiteralExpression) {
								message$0$10 = "[" + this._identifier + "] " + "folding type cast: number literal as boolean";
								this._optimizer._log += message$0$10 + "\n";
								replaceCb(new BooleanLiteralExpression(new Token$1((+baseExpr._token._value ? "true" : "false"), false)));
							} else {
								if (baseExpr instanceof IntegerLiteralExpression) {
									message$0$11 = "[" + this._identifier + "] " + "folding type cast: integer literal as boolean";
									this._optimizer._log += message$0$11 + "\n";
									replaceCb(new BooleanLiteralExpression(new Token$1((baseExpr._token._value | 0 ? "true" : "false"), false)));
								}
							}
						}
					}
				}
			}
		}
	}
};


function _FoldConstantCommand$_foldAsExpression$L_FoldConstantCommand$LAsExpression$F$LExpression$V$($this, expr, replaceCb) {
	var baseExpr;
	var message$0$0;
	var message$0$1;
	var message$0$2;
	var message$0$3;
	var message$0$4;
	var message$0$5;
	var message$0$6;
	var message$0$7;
	var message$0$8;
	var message$0$9;
	var message$0$10;
	var message$0$11;
	baseExpr = expr._expr;
	if (expr._type.equals$LType$(Type.stringType)) {
		if (baseExpr.getType$().equals$LType$(Type.stringType)) {
			message$0$0 = "[" + $this._identifier + "] " + "folding type cast: string as string";
			$this._optimizer._log += message$0$0 + "\n";
			replaceCb(baseExpr);
		} else {
			if (baseExpr instanceof BooleanLiteralExpression || baseExpr instanceof NumberLiteralExpression || baseExpr instanceof IntegerLiteralExpression) {
				message$0$1 = "[" + $this._identifier + "] " + "folding type cast: primitive literal as string";
				$this._optimizer._log += message$0$1 + "\n";
				replaceCb(new StringLiteralExpression(new Token$1(Util$encodeStringLiteral$S(baseExpr._token._value), false)));
			}
		}
	} else {
		if (expr._type.equals$LType$(Type.numberType)) {
			if (baseExpr.getType$().equals$LType$(Type.numberType)) {
				message$0$2 = "[" + $this._identifier + "] " + "folding type cast: number as number";
				$this._optimizer._log += message$0$2 + "\n";
				replaceCb(baseExpr);
			} else {
				if (baseExpr instanceof StringLiteralExpression) {
					message$0$3 = "[" + $this._identifier + "] " + "folding type cast: string literal as number";
					$this._optimizer._log += message$0$3 + "\n";
					replaceCb(new NumberLiteralExpression(new Token$1(+Util$decodeStringLiteral$S(baseExpr._token._value) + "", false)));
				} else {
					if (baseExpr instanceof IntegerLiteralExpression) {
						message$0$4 = "[" + $this._identifier + "] " + "folding type cast: int literal as number";
						$this._optimizer._log += message$0$4 + "\n";
						replaceCb(new NumberLiteralExpression(new Token$1(+baseExpr._token._value + "", false)));
					}
				}
			}
		} else {
			if (expr._type.equals$LType$(Type.integerType)) {
				if (baseExpr.getType$().equals$LType$(Type.integerType)) {
					message$0$5 = "[" + $this._identifier + "] " + "folding type cast: int as int";
					$this._optimizer._log += message$0$5 + "\n";
					replaceCb(baseExpr);
				} else {
					if (baseExpr instanceof StringLiteralExpression) {
						message$0$6 = "[" + $this._identifier + "] " + "folding type cast: string literal as int";
						$this._optimizer._log += message$0$6 + "\n";
						replaceCb(new IntegerLiteralExpression(new Token$1((Util$decodeStringLiteral$S(baseExpr._token._value) | 0) + "", false)));
					} else {
						if (baseExpr instanceof NumberLiteralExpression) {
							message$0$7 = "[" + $this._identifier + "] " + "folding type cast: number literal as int";
							$this._optimizer._log += message$0$7 + "\n";
							replaceCb(new IntegerLiteralExpression(new Token$1((baseExpr._token._value | 0) + "", false)));
						}
					}
				}
			} else {
				if (expr._type.equals$LType$(Type.booleanType)) {
					if (baseExpr.getType$().equals$LType$(Type.booleanType)) {
						message$0$8 = "[" + $this._identifier + "] " + "folding type cast: boolean as boolean";
						$this._optimizer._log += message$0$8 + "\n";
						replaceCb(baseExpr);
					} else {
						if (baseExpr instanceof StringLiteralExpression) {
							message$0$9 = "[" + $this._identifier + "] " + "folding type cast: string literal as boolean";
							$this._optimizer._log += message$0$9 + "\n";
							replaceCb(new BooleanLiteralExpression(new Token$1(!! Util$decodeStringLiteral$S(baseExpr._token._value) + "", false)));
						} else {
							if (baseExpr instanceof NumberLiteralExpression) {
								message$0$10 = "[" + $this._identifier + "] " + "folding type cast: number literal as boolean";
								$this._optimizer._log += message$0$10 + "\n";
								replaceCb(new BooleanLiteralExpression(new Token$1((+baseExpr._token._value ? "true" : "false"), false)));
							} else {
								if (baseExpr instanceof IntegerLiteralExpression) {
									message$0$11 = "[" + $this._identifier + "] " + "folding type cast: integer literal as boolean";
									$this._optimizer._log += message$0$11 + "\n";
									replaceCb(new BooleanLiteralExpression(new Token$1((baseExpr._token._value | 0 ? "true" : "false"), false)));
								}
							}
						}
					}
				}
			}
		}
	}
};

_FoldConstantCommand._foldAsExpression$L_FoldConstantCommand$LAsExpression$F$LExpression$V$ = _FoldConstantCommand$_foldAsExpression$L_FoldConstantCommand$LAsExpression$F$LExpression$V$;

function _DeadCodeEliminationOptimizeCommand() {
	this._identifier = "dce";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_DeadCodeEliminationOptimizeCommand], _FunctionOptimizeCommand);
_DeadCodeEliminationOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	if (funcDef._statements == null) {
		return true;
	}
	while (_DeadCodeEliminationOptimizeCommand$_optimizeFunction$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$(this, funcDef) || _DeadCodeEliminationOptimizeCommand$_removeExpressionStatementsWithoutSideEffects$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$(this, funcDef)) {
	}
	return true;
};


_DeadCodeEliminationOptimizeCommand.prototype._removeExpressionStatementsWithoutSideEffects$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var shouldRetry;
	shouldRetry = false;
	(function onStatements(statements) {
		var i;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof ExpressionStatement && ! _Util$exprHasSideEffects$LExpression$(statements[i]._expr)) {
				shouldRetry = true;
				statements.splice(i, 1);
			} else {
				if (statements[i] instanceof ExpressionStatement) {
					_DeadCodeEliminationOptimizeCommand$_optimizeExprInVoid$L_DeadCodeEliminationOptimizeCommand$LExpression$F$LExpression$V$($this, statements[i]._expr, (function (expr) {
						statements[i] = new ExpressionStatement(expr);
					}));
				}
				statements[i++].handleStatements$F$ALStatement$B$(onStatements);
			}
		}
		return true;
	})(funcDef._statements);
	return shouldRetry;
};


function _DeadCodeEliminationOptimizeCommand$_removeExpressionStatementsWithoutSideEffects$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var shouldRetry;
	shouldRetry = false;
	(function onStatements(statements) {
		var i;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof ExpressionStatement && ! _Util$exprHasSideEffects$LExpression$(statements[i]._expr)) {
				shouldRetry = true;
				statements.splice(i, 1);
			} else {
				if (statements[i] instanceof ExpressionStatement) {
					_DeadCodeEliminationOptimizeCommand$_optimizeExprInVoid$L_DeadCodeEliminationOptimizeCommand$LExpression$F$LExpression$V$($this, statements[i]._expr, (function (expr) {
						statements[i] = new ExpressionStatement(expr);
					}));
				}
				statements[i++].handleStatements$F$ALStatement$B$(onStatements);
			}
		}
		return true;
	})(funcDef._statements);
	return shouldRetry;
};

_DeadCodeEliminationOptimizeCommand._removeExpressionStatementsWithoutSideEffects$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ = _DeadCodeEliminationOptimizeCommand$_removeExpressionStatementsWithoutSideEffects$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$;

_DeadCodeEliminationOptimizeCommand.prototype._optimizeExprInVoid$LExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var condExpr;
	var ifTrueHasSideEffect;
	var ifFalseHasSideEffect;
	var condAndIfTrue;
	var condOrIfFalse;
	if (expr instanceof ConditionalExpression) {
		condExpr = expr;
		ifTrueHasSideEffect = _Util$exprHasSideEffects$LExpression$(condExpr._ifTrueExpr);
		ifFalseHasSideEffect = _Util$exprHasSideEffects$LExpression$(condExpr._ifFalseExpr);
		if (ifTrueHasSideEffect && ifFalseHasSideEffect) {
		} else {
			if (ifTrueHasSideEffect && ! ifFalseHasSideEffect) {
				condAndIfTrue = new LogicalExpression(new Token$0("&&"), condExpr._condExpr, condExpr._ifTrueExpr);
				replaceCb(condAndIfTrue);
			} else {
				if (! ifTrueHasSideEffect && ifFalseHasSideEffect) {
					condOrIfFalse = new LogicalExpression(new Token$0("||"), condExpr._condExpr, condExpr._ifFalseExpr);
					replaceCb(condOrIfFalse);
				} else {
					replaceCb(condExpr._condExpr);
				}
			}
		}
	} else {
		if (expr instanceof LogicalNotExpression) {
			replaceCb(expr._expr);
		}
	}
};


function _DeadCodeEliminationOptimizeCommand$_optimizeExprInVoid$L_DeadCodeEliminationOptimizeCommand$LExpression$F$LExpression$V$($this, expr, replaceCb) {
	var condExpr;
	var ifTrueHasSideEffect;
	var ifFalseHasSideEffect;
	var condAndIfTrue;
	var condOrIfFalse;
	if (expr instanceof ConditionalExpression) {
		condExpr = expr;
		ifTrueHasSideEffect = _Util$exprHasSideEffects$LExpression$(condExpr._ifTrueExpr);
		ifFalseHasSideEffect = _Util$exprHasSideEffects$LExpression$(condExpr._ifFalseExpr);
		if (ifTrueHasSideEffect && ifFalseHasSideEffect) {
		} else {
			if (ifTrueHasSideEffect && ! ifFalseHasSideEffect) {
				condAndIfTrue = new LogicalExpression(new Token$0("&&"), condExpr._condExpr, condExpr._ifTrueExpr);
				replaceCb(condAndIfTrue);
			} else {
				if (! ifTrueHasSideEffect && ifFalseHasSideEffect) {
					condOrIfFalse = new LogicalExpression(new Token$0("||"), condExpr._condExpr, condExpr._ifFalseExpr);
					replaceCb(condOrIfFalse);
				} else {
					replaceCb(condExpr._condExpr);
				}
			}
		}
	} else {
		if (expr instanceof LogicalNotExpression) {
			replaceCb(expr._expr);
		}
	}
};

_DeadCodeEliminationOptimizeCommand._optimizeExprInVoid$L_DeadCodeEliminationOptimizeCommand$LExpression$F$LExpression$V$ = _DeadCodeEliminationOptimizeCommand$_optimizeExprInVoid$L_DeadCodeEliminationOptimizeCommand$LExpression$F$LExpression$V$;

_DeadCodeEliminationOptimizeCommand.prototype._optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var shouldRetry;
	var locals;
	var localsUsed;
	var localIndex;
	shouldRetry = false;
	_Util$optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$(funcDef, (function (exprs) {
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadStoresToProperties$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_delayAssignmentsBetweenLocals$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadStores$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadConditions$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
	}));
	locals = funcDef._locals;
	localsUsed = new Array(locals.length);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		if (statement instanceof FunctionStatement) {
			this$0 = statement._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			var i;
			if (expr instanceof AssignmentExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr) instanceof LocalExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr).getType$().equals$LType$(BinaryExpression$getSecondExpr$LBinaryExpression$(expr).getType$())) {
				return onExpr(BinaryExpression$getSecondExpr$LBinaryExpression$(expr));
			} else {
				if (expr instanceof LocalExpression) {
					for (i = 0; i < locals.length; ++ i) {
						if (locals[i] == LocalExpression$getLocal$LLocalExpression$(expr)) {
							break;
						}
					}
					if (i !== locals.length) {
						localsUsed[i] = true;
					}
				} else {
					if (expr instanceof FunctionExpression) {
						MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
					}
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}));
		return statement.forEachStatement$F$LStatement$B$(onStatement);
	}), funcDef._statements);
	for (localIndex = localsUsed.length - 1; localIndex >= 0; -- localIndex) {
		if (localsUsed[localIndex]) {
			continue;
		}
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var this$0;
			if (statement instanceof FunctionStatement) {
				this$0 = statement._funcDef;
				Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
			}
			statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				var rhsExpr;
				if (expr instanceof AssignmentExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr) instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(BinaryExpression$getFirstExpr$LBinaryExpression$(expr)) == locals[localIndex]) {
					rhsExpr = BinaryExpression$getSecondExpr$LBinaryExpression$(expr);
					replaceCb(rhsExpr);
					shouldRetry = true;
					return onExpr(rhsExpr, null);
				} else {
					if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == locals[localIndex]) {
						throw new Error("logic flaw, found a variable going to be removed being used");
					} else {
						if (expr instanceof FunctionExpression) {
							MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
						}
					}
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			}));
			return statement.forEachStatement$F$LStatement$B$(onStatement);
		}), funcDef._statements);
		locals.splice(localIndex, 1);
	}
	return shouldRetry;
};


function _DeadCodeEliminationOptimizeCommand$_optimizeFunction$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var shouldRetry;
	var locals;
	var localsUsed;
	var localIndex;
	shouldRetry = false;
	_Util$optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$(funcDef, (function (exprs) {
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadStoresToProperties$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_delayAssignmentsBetweenLocals$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadStores$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadConditions$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
	}));
	locals = funcDef._locals;
	localsUsed = new Array(locals.length);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		if (statement instanceof FunctionStatement) {
			this$0 = statement._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			var i;
			if (expr instanceof AssignmentExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr) instanceof LocalExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr).getType$().equals$LType$(BinaryExpression$getSecondExpr$LBinaryExpression$(expr).getType$())) {
				return onExpr(BinaryExpression$getSecondExpr$LBinaryExpression$(expr));
			} else {
				if (expr instanceof LocalExpression) {
					for (i = 0; i < locals.length; ++ i) {
						if (locals[i] == LocalExpression$getLocal$LLocalExpression$(expr)) {
							break;
						}
					}
					if (i !== locals.length) {
						localsUsed[i] = true;
					}
				} else {
					if (expr instanceof FunctionExpression) {
						MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
					}
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}));
		return statement.forEachStatement$F$LStatement$B$(onStatement);
	}), funcDef._statements);
	for (localIndex = localsUsed.length - 1; localIndex >= 0; -- localIndex) {
		if (localsUsed[localIndex]) {
			continue;
		}
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var this$0;
			if (statement instanceof FunctionStatement) {
				this$0 = statement._funcDef;
				Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
			}
			statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				var rhsExpr;
				if (expr instanceof AssignmentExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr) instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(BinaryExpression$getFirstExpr$LBinaryExpression$(expr)) == locals[localIndex]) {
					rhsExpr = BinaryExpression$getSecondExpr$LBinaryExpression$(expr);
					replaceCb(rhsExpr);
					shouldRetry = true;
					return onExpr(rhsExpr, null);
				} else {
					if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == locals[localIndex]) {
						throw new Error("logic flaw, found a variable going to be removed being used");
					} else {
						if (expr instanceof FunctionExpression) {
							MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
						}
					}
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			}));
			return statement.forEachStatement$F$LStatement$B$(onStatement);
		}), funcDef._statements);
		locals.splice(localIndex, 1);
	}
	return shouldRetry;
};

_DeadCodeEliminationOptimizeCommand._optimizeFunction$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ = _DeadCodeEliminationOptimizeCommand$_optimizeFunction$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$;

_DeadCodeEliminationOptimizeCommand.prototype._delayAssignmentsBetweenLocals$LMemberFunctionDefinition$ALExpression$ = function (funcDef, exprs) {
	var $this = this;
	var localsUntouchable;
	var locals;
	var _onExpr;
	var onExpr;
	localsUntouchable = new TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E();
	locals = new TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E();
	_onExpr = (function (expr) {
		var local;
		var this$0;
		var message$0;
		var message$0$0;
		var this$1;
		var message$1;
		var message$0$1;
		if (expr instanceof AssignmentExpression && expr._token._value !== "=" && expr._expr1 instanceof LocalExpression) {
			this$0 = expr._expr1;
			local = this$0._local;
			message$0 = "local variable " + local._name._value + " cannot be rewritten (has fused op)";
			message$0$0 = "[" + $this._identifier + "] " + message$0;
			$this._optimizer._log += message$0$0 + "\n";
			TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(localsUntouchable, local, true);
		} else {
			if (expr instanceof IncrementExpression && expr._expr instanceof LocalExpression) {
				this$1 = expr._expr;
				local = this$1._local;
				message$1 = "local variable " + local._name._value + " cannot be rewritten (has increment)";
				message$0$1 = "[" + $this._identifier + "] " + message$1;
				$this._optimizer._log += message$0$1 + "\n";
				TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(localsUntouchable, local, true);
			}
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, _onExpr);
	});
	Util$forEachExpression$F$LExpression$B$ALExpression$(_onExpr, exprs);
	onExpr = (function (expr, replaceCb) {
		var assignmentExpr;
		var lhsLocal;
		var rhsExpr;
		var rhsLocal;
		var cachedExpr;
		var callingFuncDef;
		var this$0;
		var message$0;
		var message$0$0;
		var message$1;
		var message$0$1;
		var message$2;
		var message$0$2;
		var _list$0;
		var _list$1;
		if (expr instanceof AssignmentExpression) {
			assignmentExpr = expr;
			if (assignmentExpr._expr1 instanceof LocalExpression) {
				onExpr(assignmentExpr._expr2, (function (expr) {
					BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
				}));
				if (! TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(localsUntouchable, assignmentExpr._expr1._local) && assignmentExpr._expr1._local._type.equals$LType$(assignmentExpr._expr2.getType$())) {
					this$0 = assignmentExpr._expr1;
					lhsLocal = this$0._local;
					message$0 = "resetting cache for: " + lhsLocal._name._value;
					message$0$0 = "[" + $this._identifier + "] " + message$0;
					$this._optimizer._log += message$0$0 + "\n";
					TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$(locals, (function (local, expr) {
						if (local == lhsLocal) {
							_OptimizeCommand$log$L_OptimizeCommand$S($this, "  clearing itself");
							TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, local);
						} else {
							if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == lhsLocal) {
								_OptimizeCommand$log$L_OptimizeCommand$S($this, "  clearing " + Token$getValue$LToken$(LocalVariable$getName$LLocalVariable$(local)));
								TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, local);
							}
						}
						return true;
					}));
					if (assignmentExpr._token._value === "=") {
						rhsExpr = assignmentExpr._expr2;
						if (rhsExpr instanceof LocalExpression) {
							rhsLocal = rhsExpr._local;
							if (lhsLocal != rhsLocal && ! TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(localsUntouchable, rhsLocal)) {
								message$1 = "  set to: " + rhsLocal._name._value;
								message$0$1 = "[" + $this._identifier + "] " + message$1;
								$this._optimizer._log += message$0$1 + "\n";
								TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$(locals, lhsLocal, rhsExpr);
							}
						} else {
							if (rhsExpr instanceof NullExpression || rhsExpr instanceof NumberLiteralExpression || rhsExpr instanceof IntegerLiteralExpression || rhsExpr instanceof StringLiteralExpression) {
								message$2 = "  set to: " + rhsExpr._token._value;
								message$0$2 = "[" + $this._identifier + "] " + message$2;
								$this._optimizer._log += message$0$2 + "\n";
								TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$(locals, lhsLocal, rhsExpr);
							}
						}
					}
				}
				return true;
			}
		} else {
			if (expr instanceof LocalExpression) {
				cachedExpr = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, expr._local);
				if (cachedExpr) {
					replaceCb(cachedExpr.clone$());
					return true;
				}
			} else {
				if (expr instanceof CallExpression) {
					callingFuncDef = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr);
					if (callingFuncDef != null && (callingFuncDef._flags & 2048) !== 0) {
					} else {
						expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
						if (funcDef._parent != null || funcDef._closures.length !== 0) {
							(_list$0 = locals._list).splice(0, _list$0.length);
						}
						return true;
					}
				} else {
					if (expr instanceof NewExpression) {
						Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
						(_list$1 = locals._list).splice(0, _list$1.length);
						return true;
					}
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};


function _DeadCodeEliminationOptimizeCommand$_delayAssignmentsBetweenLocals$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs) {
	var localsUntouchable;
	var locals;
	var _onExpr;
	var onExpr;
	localsUntouchable = new TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E();
	locals = new TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E();
	_onExpr = (function (expr) {
		var local;
		var this$0;
		var message$0;
		var message$0$0;
		var this$1;
		var message$1;
		var message$0$1;
		if (expr instanceof AssignmentExpression && expr._token._value !== "=" && expr._expr1 instanceof LocalExpression) {
			this$0 = expr._expr1;
			local = this$0._local;
			message$0 = "local variable " + local._name._value + " cannot be rewritten (has fused op)";
			message$0$0 = "[" + $this._identifier + "] " + message$0;
			$this._optimizer._log += message$0$0 + "\n";
			TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(localsUntouchable, local, true);
		} else {
			if (expr instanceof IncrementExpression && expr._expr instanceof LocalExpression) {
				this$1 = expr._expr;
				local = this$1._local;
				message$1 = "local variable " + local._name._value + " cannot be rewritten (has increment)";
				message$0$1 = "[" + $this._identifier + "] " + message$1;
				$this._optimizer._log += message$0$1 + "\n";
				TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(localsUntouchable, local, true);
			}
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, _onExpr);
	});
	Util$forEachExpression$F$LExpression$B$ALExpression$(_onExpr, exprs);
	onExpr = (function (expr, replaceCb) {
		var assignmentExpr;
		var lhsLocal;
		var rhsExpr;
		var rhsLocal;
		var cachedExpr;
		var callingFuncDef;
		var this$0;
		var message$0;
		var message$0$0;
		var message$1;
		var message$0$1;
		var message$2;
		var message$0$2;
		var _list$0;
		var _list$1;
		if (expr instanceof AssignmentExpression) {
			assignmentExpr = expr;
			if (assignmentExpr._expr1 instanceof LocalExpression) {
				onExpr(assignmentExpr._expr2, (function (expr) {
					BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
				}));
				if (! TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(localsUntouchable, assignmentExpr._expr1._local) && assignmentExpr._expr1._local._type.equals$LType$(assignmentExpr._expr2.getType$())) {
					this$0 = assignmentExpr._expr1;
					lhsLocal = this$0._local;
					message$0 = "resetting cache for: " + lhsLocal._name._value;
					message$0$0 = "[" + $this._identifier + "] " + message$0;
					$this._optimizer._log += message$0$0 + "\n";
					TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$(locals, (function (local, expr) {
						if (local == lhsLocal) {
							_OptimizeCommand$log$L_OptimizeCommand$S($this, "  clearing itself");
							TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, local);
						} else {
							if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == lhsLocal) {
								_OptimizeCommand$log$L_OptimizeCommand$S($this, "  clearing " + Token$getValue$LToken$(LocalVariable$getName$LLocalVariable$(local)));
								TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, local);
							}
						}
						return true;
					}));
					if (assignmentExpr._token._value === "=") {
						rhsExpr = assignmentExpr._expr2;
						if (rhsExpr instanceof LocalExpression) {
							rhsLocal = rhsExpr._local;
							if (lhsLocal != rhsLocal && ! TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(localsUntouchable, rhsLocal)) {
								message$1 = "  set to: " + rhsLocal._name._value;
								message$0$1 = "[" + $this._identifier + "] " + message$1;
								$this._optimizer._log += message$0$1 + "\n";
								TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$(locals, lhsLocal, rhsExpr);
							}
						} else {
							if (rhsExpr instanceof NullExpression || rhsExpr instanceof NumberLiteralExpression || rhsExpr instanceof IntegerLiteralExpression || rhsExpr instanceof StringLiteralExpression) {
								message$2 = "  set to: " + rhsExpr._token._value;
								message$0$2 = "[" + $this._identifier + "] " + message$2;
								$this._optimizer._log += message$0$2 + "\n";
								TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$(locals, lhsLocal, rhsExpr);
							}
						}
					}
				}
				return true;
			}
		} else {
			if (expr instanceof LocalExpression) {
				cachedExpr = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, expr._local);
				if (cachedExpr) {
					replaceCb(cachedExpr.clone$());
					return true;
				}
			} else {
				if (expr instanceof CallExpression) {
					callingFuncDef = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr);
					if (callingFuncDef != null && (callingFuncDef._flags & 2048) !== 0) {
					} else {
						expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
						if (funcDef._parent != null || funcDef._closures.length !== 0) {
							(_list$0 = locals._list).splice(0, _list$0.length);
						}
						return true;
					}
				} else {
					if (expr instanceof NewExpression) {
						Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
						(_list$1 = locals._list).splice(0, _list$1.length);
						return true;
					}
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};

_DeadCodeEliminationOptimizeCommand._delayAssignmentsBetweenLocals$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$ = _DeadCodeEliminationOptimizeCommand$_delayAssignmentsBetweenLocals$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$;

_DeadCodeEliminationOptimizeCommand.prototype._eliminateDeadStores$LMemberFunctionDefinition$ALExpression$ = function (funcDef, exprs) {
	var $this = this;
	var lastAssignExpr;
	var onExpr;
	lastAssignExpr = new TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E();
	function onExpr(expr, rewriteCb) {
		var assignExpr;
		var lhsLocal;
		var lastAssign;
		var callingFuncDef;
		var this$0;
		var message$0;
		var message$0$0;
		var _list$0;
		var _list$1;
		if (expr instanceof AssignmentExpression) {
			assignExpr = expr;
			if (assignExpr._token._value === "=" && assignExpr._expr1 instanceof LocalExpression) {
				onExpr(assignExpr._expr2, (function (assignExpr) {
					return (function (expr) {
						BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignExpr, expr);
					});
				})(assignExpr));
				this$0 = assignExpr._expr1;
				lhsLocal = this$0._local;
				lastAssign = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$(lastAssignExpr, lhsLocal);
				if (lastAssign) {
					message$0 = "eliminating dead store to: " + lhsLocal._name._value;
					message$0$0 = "[" + $this._identifier + "] " + message$0;
					$this._optimizer._log += message$0$0 + "\n";
					lastAssign.second(lastAssign.first._expr2);
				}
				TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$(lastAssignExpr, lhsLocal, ({first: assignExpr, second: rewriteCb}));
				return true;
			}
		} else {
			if (expr instanceof LocalExpression) {
				TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$(lastAssignExpr, expr._local);
			} else {
				if (expr instanceof CallExpression) {
					onExpr(expr._expr, (function (callExpr) {
						return (function (expr) {
							CallExpression$setExpr$LCallExpression$LExpression$(callExpr, expr);
						});
					})(expr));
					Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
					callingFuncDef = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr);
					if (callingFuncDef != null && (callingFuncDef._flags & 2048) !== 0) {
					} else {
						(_list$0 = lastAssignExpr._list).splice(0, _list$0.length);
					}
					return true;
				} else {
					if (expr instanceof NewExpression) {
						Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
						(_list$1 = lastAssignExpr._list).splice(0, _list$1.length);
						return true;
					} else {
						if (expr instanceof LogicalExpression || expr instanceof ConditionalExpression) {
							expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, rewriteCb) {
								var result;
								result = onExpr(expr, rewriteCb);
								TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$(lastAssignExpr);
								return result;
							}));
							return true;
						}
					}
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};


function _DeadCodeEliminationOptimizeCommand$_eliminateDeadStores$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs) {
	var lastAssignExpr;
	var onExpr;
	lastAssignExpr = new TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E();
	function onExpr(expr, rewriteCb) {
		var assignExpr;
		var lhsLocal;
		var lastAssign;
		var callingFuncDef;
		var this$0;
		var message$0;
		var message$0$0;
		var _list$0;
		var _list$1;
		if (expr instanceof AssignmentExpression) {
			assignExpr = expr;
			if (assignExpr._token._value === "=" && assignExpr._expr1 instanceof LocalExpression) {
				onExpr(assignExpr._expr2, (function (assignExpr) {
					return (function (expr) {
						BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignExpr, expr);
					});
				})(assignExpr));
				this$0 = assignExpr._expr1;
				lhsLocal = this$0._local;
				lastAssign = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$(lastAssignExpr, lhsLocal);
				if (lastAssign) {
					message$0 = "eliminating dead store to: " + lhsLocal._name._value;
					message$0$0 = "[" + $this._identifier + "] " + message$0;
					$this._optimizer._log += message$0$0 + "\n";
					lastAssign.second(lastAssign.first._expr2);
				}
				TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$(lastAssignExpr, lhsLocal, ({first: assignExpr, second: rewriteCb}));
				return true;
			}
		} else {
			if (expr instanceof LocalExpression) {
				TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$(lastAssignExpr, expr._local);
			} else {
				if (expr instanceof CallExpression) {
					onExpr(expr._expr, (function (callExpr) {
						return (function (expr) {
							CallExpression$setExpr$LCallExpression$LExpression$(callExpr, expr);
						});
					})(expr));
					Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
					callingFuncDef = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr);
					if (callingFuncDef != null && (callingFuncDef._flags & 2048) !== 0) {
					} else {
						(_list$0 = lastAssignExpr._list).splice(0, _list$0.length);
					}
					return true;
				} else {
					if (expr instanceof NewExpression) {
						Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
						(_list$1 = lastAssignExpr._list).splice(0, _list$1.length);
						return true;
					} else {
						if (expr instanceof LogicalExpression || expr instanceof ConditionalExpression) {
							expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, rewriteCb) {
								var result;
								result = onExpr(expr, rewriteCb);
								TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$(lastAssignExpr);
								return result;
							}));
							return true;
						}
					}
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};

_DeadCodeEliminationOptimizeCommand._eliminateDeadStores$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$ = _DeadCodeEliminationOptimizeCommand$_eliminateDeadStores$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$;

_DeadCodeEliminationOptimizeCommand.prototype._eliminateDeadStoresToProperties$LMemberFunctionDefinition$ALExpression$ = function (funcDef, exprs) {
	var $this = this;
	var isFirstLevelPropertyAccess;
	var baseExprsAreEqual;
	var lastAssignExpr;
	var onExpr;
	function isFirstLevelPropertyAccess(expr) {
		var baseExpr;
		if (! (expr instanceof PropertyExpression)) {
			return false;
		}
		baseExpr = expr._expr;
		return (baseExpr instanceof LocalExpression || baseExpr instanceof ThisExpression || baseExpr.isClassSpecifier$() ? true : false);
	}
	function baseExprsAreEqual(x, y) {
		if (x instanceof LocalExpression && y instanceof LocalExpression) {
			return x._local == y._local;
		} else {
			if (x instanceof ThisExpression && y instanceof ThisExpression) {
				return true;
			} else {
				if (x.isClassSpecifier$() && y.isClassSpecifier$()) {
					return x._parsedType.equals$LType$(y._parsedType);
				}
			}
		}
		return false;
	}
	lastAssignExpr = {};
	onExpr = (function (expr, rewriteCb) {
		var assignmentExpr;
		var firstExpr;
		var propertyName;
		var k;
		var baseExpr;
		var this$0;
		var this$1;
		var this$2;
		if (expr instanceof AssignmentExpression) {
			assignmentExpr = expr;
			firstExpr = assignmentExpr._expr1;
			if (expr._token._value === "=" && isFirstLevelPropertyAccess(firstExpr) && ! _Util$classIsNative$LClassDefinition$(firstExpr._expr.getType$().getClassDef$())) {
				this$0 = firstExpr._identifierToken;
				propertyName = this$0._value;
				onExpr(assignmentExpr._expr2, null);
				if (lastAssignExpr[propertyName] && lastAssignExpr[propertyName].second != null && baseExprsAreEqual(firstExpr._expr, lastAssignExpr[propertyName].first._expr1._expr)) {
					lastAssignExpr[propertyName].second(lastAssignExpr[propertyName].first._expr2);
				}
				lastAssignExpr[propertyName] = ({first: assignmentExpr, second: rewriteCb});
				return true;
			} else {
				if (assignmentExpr._expr1 instanceof LocalExpression) {
					onExpr(assignmentExpr._expr2, null);
					for (k in lastAssignExpr) {
						this$1 = lastAssignExpr[k].first._expr1;
						baseExpr = this$1._expr;
						if (baseExpr instanceof LocalExpression && baseExpr._local == expr._expr1._local) {
							delete lastAssignExpr[k];
						}
					}
					return true;
				}
			}
		} else {
			if (isFirstLevelPropertyAccess(expr)) {
				this$2 = expr._identifierToken;
				propertyName = this$2._value;
				delete lastAssignExpr[propertyName];
			} else {
				if (expr instanceof CallExpression) {
					onExpr(expr._expr, null);
					Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
					lastAssignExpr = {};
					return true;
				} else {
					if (expr instanceof NewExpression) {
						Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
						lastAssignExpr = {};
						return true;
					}
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};


function _DeadCodeEliminationOptimizeCommand$_eliminateDeadStoresToProperties$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs) {
	var isFirstLevelPropertyAccess;
	var baseExprsAreEqual;
	var lastAssignExpr;
	var onExpr;
	function isFirstLevelPropertyAccess(expr) {
		var baseExpr;
		if (! (expr instanceof PropertyExpression)) {
			return false;
		}
		baseExpr = expr._expr;
		return (baseExpr instanceof LocalExpression || baseExpr instanceof ThisExpression || baseExpr.isClassSpecifier$() ? true : false);
	}
	function baseExprsAreEqual(x, y) {
		if (x instanceof LocalExpression && y instanceof LocalExpression) {
			return x._local == y._local;
		} else {
			if (x instanceof ThisExpression && y instanceof ThisExpression) {
				return true;
			} else {
				if (x.isClassSpecifier$() && y.isClassSpecifier$()) {
					return x._parsedType.equals$LType$(y._parsedType);
				}
			}
		}
		return false;
	}
	lastAssignExpr = {};
	onExpr = (function (expr, rewriteCb) {
		var assignmentExpr;
		var firstExpr;
		var propertyName;
		var k;
		var baseExpr;
		var this$0;
		var this$1;
		var this$2;
		if (expr instanceof AssignmentExpression) {
			assignmentExpr = expr;
			firstExpr = assignmentExpr._expr1;
			if (expr._token._value === "=" && isFirstLevelPropertyAccess(firstExpr) && ! _Util$classIsNative$LClassDefinition$(firstExpr._expr.getType$().getClassDef$())) {
				this$0 = firstExpr._identifierToken;
				propertyName = this$0._value;
				onExpr(assignmentExpr._expr2, null);
				if (lastAssignExpr[propertyName] && lastAssignExpr[propertyName].second != null && baseExprsAreEqual(firstExpr._expr, lastAssignExpr[propertyName].first._expr1._expr)) {
					lastAssignExpr[propertyName].second(lastAssignExpr[propertyName].first._expr2);
				}
				lastAssignExpr[propertyName] = ({first: assignmentExpr, second: rewriteCb});
				return true;
			} else {
				if (assignmentExpr._expr1 instanceof LocalExpression) {
					onExpr(assignmentExpr._expr2, null);
					for (k in lastAssignExpr) {
						this$1 = lastAssignExpr[k].first._expr1;
						baseExpr = this$1._expr;
						if (baseExpr instanceof LocalExpression && baseExpr._local == expr._expr1._local) {
							delete lastAssignExpr[k];
						}
					}
					return true;
				}
			}
		} else {
			if (isFirstLevelPropertyAccess(expr)) {
				this$2 = expr._identifierToken;
				propertyName = this$2._value;
				delete lastAssignExpr[propertyName];
			} else {
				if (expr instanceof CallExpression) {
					onExpr(expr._expr, null);
					Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
					lastAssignExpr = {};
					return true;
				} else {
					if (expr instanceof NewExpression) {
						Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, expr._args);
						lastAssignExpr = {};
						return true;
					}
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};

_DeadCodeEliminationOptimizeCommand._eliminateDeadStoresToProperties$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$ = _DeadCodeEliminationOptimizeCommand$_eliminateDeadStoresToProperties$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$;

_DeadCodeEliminationOptimizeCommand.prototype._eliminateDeadConditions$LMemberFunctionDefinition$ALExpression$ = function (funcDef, exprs) {
	var $this = this;
	var spliceStatements;
	function spliceStatements(dest, index, src) {
		var i;
		dest.splice(index, 1);
		for (i = 0; i < src.length; ++ i) {
			dest.splice(index + i, 0, src[i]);
		}
	}
	(function onStatements(statements) {
		var i;
		var statement;
		var ifStatement;
		var cond;
		for (i = statements.length - 1; i >= 0; -- i) {
			statement = statements[i];
			if (statement instanceof IfStatement) {
				ifStatement = statement;
				cond = _Util$conditionIsConstant$LExpression$(ifStatement._expr);
				if (cond == null) {
				} else {
					if (cond === false && ifStatement._onFalseStatements.length === 0) {
						statements.splice(i, 1);
					} else {
						if (cond === false) {
							spliceStatements(statements, i, ifStatement._onFalseStatements);
						} else {
							if (cond === true) {
								spliceStatements(statements, i, ifStatement._onTrueStatements);
							}
						}
					}
				}
			}
			statement.handleStatements$F$ALStatement$B$(onStatements);
		}
		return true;
	})(funcDef._statements);
};


function _DeadCodeEliminationOptimizeCommand$_eliminateDeadConditions$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs) {
	var spliceStatements;
	function spliceStatements(dest, index, src) {
		var i;
		dest.splice(index, 1);
		for (i = 0; i < src.length; ++ i) {
			dest.splice(index + i, 0, src[i]);
		}
	}
	(function onStatements(statements) {
		var i;
		var statement;
		var ifStatement;
		var cond;
		for (i = statements.length - 1; i >= 0; -- i) {
			statement = statements[i];
			if (statement instanceof IfStatement) {
				ifStatement = statement;
				cond = _Util$conditionIsConstant$LExpression$(ifStatement._expr);
				if (cond == null) {
				} else {
					if (cond === false && ifStatement._onFalseStatements.length === 0) {
						statements.splice(i, 1);
					} else {
						if (cond === false) {
							spliceStatements(statements, i, ifStatement._onFalseStatements);
						} else {
							if (cond === true) {
								spliceStatements(statements, i, ifStatement._onTrueStatements);
							}
						}
					}
				}
			}
			statement.handleStatements$F$ALStatement$B$(onStatements);
		}
		return true;
	})(funcDef._statements);
};

_DeadCodeEliminationOptimizeCommand._eliminateDeadConditions$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$ = _DeadCodeEliminationOptimizeCommand$_eliminateDeadConditions$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$;

function _InlineOptimizeCommand() {
	this._identifier = "inline";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_InlineOptimizeCommand], _FunctionOptimizeCommand);
_InlineOptimizeCommand.prototype._createStash$ = function () {
	return new _InlineOptimizeCommand$x2EStash();
};


_InlineOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var stash;
	var message$0;
	var message$0$0;
	var message$1;
	var message$0$1;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$(this, funcDef);
	if (stash.isOptimized) {
		return true;
	}
	stash.isOptimized = true;
	if (funcDef._statements == null) {
		return true;
	}
	message$0 = "* starting optimization of " + funcDef.getNotation$();
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	while (true) {
		while (true) {
			if (! _InlineOptimizeCommand$_handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$(this, funcDef, funcDef._statements)) {
				break;
			}
			_OptimizeCommand$setupCommand$L_OptimizeCommand$L_OptimizeCommand$(this, new _DetermineCalleeCommand()).optimizeFunction$LMemberFunctionDefinition$(funcDef);
		}
		if (! _OptimizeCommand$setupCommand$L_OptimizeCommand$L_OptimizeCommand$(this, new _ReturnIfOptimizeCommand()).optimizeFunction$LMemberFunctionDefinition$(funcDef)) {
			break;
		}
	}
	message$1 = "* finished optimization of " + funcDef.getNotation$();
	message$0$1 = "[" + this._identifier + "] " + message$1;
	this._optimizer._log += message$0$1 + "\n";
	return true;
};


_InlineOptimizeCommand.prototype._handleStatements$LMemberFunctionDefinition$ALStatement$ = function (funcDef, statements) {
	var altered;
	var i;
	var left;
	altered = false;
	for (i = 0; i < statements.length; ++ i) {
		left = statements.length - i;
		if (_InlineOptimizeCommand$_handleStatement$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$N(this, funcDef, statements, i)) {
			altered = true;
		}
		i = statements.length - left;
	}
	return altered;
};


function _InlineOptimizeCommand$_handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$($this, funcDef, statements) {
	var altered;
	var i;
	var left;
	altered = false;
	for (i = 0; i < statements.length; ++ i) {
		left = statements.length - i;
		if (_InlineOptimizeCommand$_handleStatement$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$N($this, funcDef, statements, i)) {
			altered = true;
		}
		i = statements.length - left;
	}
	return altered;
};

_InlineOptimizeCommand._handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$ = _InlineOptimizeCommand$_handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$;

_InlineOptimizeCommand.prototype._handleStatement$LMemberFunctionDefinition$ALStatement$N = function (funcDef, statements, stmtIndex) {
	var $this = this;
	var altered;
	var statement;
	var callingFuncDef;
	altered = false;
	statement = statements[stmtIndex];
	if (statement instanceof ConstructorInvocationStatement) {
		callingFuncDef = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(statement);
		this.optimizeFunction$LMemberFunctionDefinition$(callingFuncDef);
		if (_InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$(this, callingFuncDef) && _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$B(this, callingFuncDef, statement._args, false)) {
			statements.splice(stmtIndex, 1);
			_InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$(this, funcDef, statements, stmtIndex, callingFuncDef, statement._args.concat([ new ThisExpression(null, funcDef._classDef) ]));
		}
	} else {
		if (statement instanceof ExpressionStatement) {
			if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$(this, funcDef, statements, stmtIndex, statement._expr, (function (stmtIndex) {
				statements.splice(stmtIndex, 1);
			}))) {
				altered = true;
			}
		} else {
			if (statement instanceof ReturnStatement) {
				if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$(this, funcDef, statements, stmtIndex, statement._expr, (function (stmtIndex) {
					statements.splice(stmtIndex, 1);
					statements[stmtIndex - 1] = new ReturnStatement(statement.getToken$(), statements[stmtIndex - 1] instanceof ReturnStatement ? statements[stmtIndex - 1]._expr : statements[stmtIndex - 1]._expr);
				}))) {
					altered = true;
				}
			} else {
				if (statement instanceof IfStatement) {
					if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$(this, funcDef, statements, stmtIndex, statement._expr, (function (stmtIndex) {
						var expr$0;
						expr$0 = (statements[stmtIndex - 1] instanceof ReturnStatement ? statements[stmtIndex - 1]._expr : statements[stmtIndex - 1]._expr);
						statement._expr = expr$0;
						statements.splice(stmtIndex - 1, 1);
					}))) {
						altered = true;
					}
					if (_InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$(this, funcDef, statement)) {
						altered = true;
					}
				} else {
					if (_InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$(this, funcDef, statement)) {
						altered = true;
					}
				}
			}
		}
	}
	statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
		var callExpr;
		var args;
		var callingFuncDef;
		var stmt;
		var argUsed;
		var setupArgs;
		var i;
		var numberOfUsed;
		var argDecl;
		var local;
		var assignToLocal;
		var clonedExpr;
		var message$0;
		var message$0$0;
		expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		if (expr instanceof CallExpression) {
			callExpr = expr;
			args = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$B($this, callExpr, true);
			if (args != null) {
				callingFuncDef = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr);
				message$0 = "expanding " + callingFuncDef.getNotation$() + " as expression";
				message$0$0 = "[" + $this._identifier + "] " + message$0;
				$this._optimizer._log += message$0$0 + "\n";
				stmt = callingFuncDef._statements[0];
				if (stmt instanceof ExpressionStatement) {
					expr = stmt._expr;
				} else {
					if (stmt instanceof ReturnStatement) {
						expr = stmt._expr;
					} else {
						throw new Error('logic flaw');
					}
				}
				argUsed = _InlineOptimizeCommand$_countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, callingFuncDef);
				setupArgs = null;
				for (i = 0; i < args.length; ++ i) {
					if (args[i] instanceof LeafExpression || args[i] == null) {
						continue;
					}
					numberOfUsed = (i < callingFuncDef._args.length ? argUsed[callingFuncDef._args[i]._name._value] : argUsed["this"]);
					if (numberOfUsed === 1 && ! _Util$exprHasSideEffects$LExpression$(args[i])) {
						continue;
					}
					argDecl = callingFuncDef._args[i];
					local = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, args[i].getType$(), (callingFuncDef._nameToken == null ? "$anon" : callingFuncDef._nameToken._value) + "$" + (argDecl != null ? argDecl._name._value : "this"));
					assignToLocal = new AssignmentExpression(new Token$0("="), new LocalExpression(local._name, local), args[i]);
					if (setupArgs == null) {
						setupArgs = assignToLocal;
					} else {
						setupArgs = new CommaExpression(new Token$0(","), assignToLocal, setupArgs);
					}
					args[i] = new LocalExpression(local._name, local);
				}
				clonedExpr = expr.clone$();
				_InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, clonedExpr, (function (expr) {
					clonedExpr = expr;
				}), args, callingFuncDef);
				if (setupArgs != null) {
					clonedExpr = new CommaExpression(new Token$0(","), setupArgs, clonedExpr);
				}
				replaceCb(clonedExpr);
				altered = true;
			}
		}
		return true;
	}));
	return altered;
};


function _InlineOptimizeCommand$_handleStatement$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$N($this, funcDef, statements, stmtIndex) {
	var altered;
	var statement;
	var callingFuncDef;
	altered = false;
	statement = statements[stmtIndex];
	if (statement instanceof ConstructorInvocationStatement) {
		callingFuncDef = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(statement);
		$this.optimizeFunction$LMemberFunctionDefinition$(callingFuncDef);
		if (_InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, callingFuncDef) && _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$B($this, callingFuncDef, statement._args, false)) {
			statements.splice(stmtIndex, 1);
			_InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$($this, funcDef, statements, stmtIndex, callingFuncDef, statement._args.concat([ new ThisExpression(null, funcDef._classDef) ]));
		}
	} else {
		if (statement instanceof ExpressionStatement) {
			if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$($this, funcDef, statements, stmtIndex, statement._expr, (function (stmtIndex) {
				statements.splice(stmtIndex, 1);
			}))) {
				altered = true;
			}
		} else {
			if (statement instanceof ReturnStatement) {
				if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$($this, funcDef, statements, stmtIndex, statement._expr, (function (stmtIndex) {
					statements.splice(stmtIndex, 1);
					statements[stmtIndex - 1] = new ReturnStatement(statement.getToken$(), statements[stmtIndex - 1] instanceof ReturnStatement ? statements[stmtIndex - 1]._expr : statements[stmtIndex - 1]._expr);
				}))) {
					altered = true;
				}
			} else {
				if (statement instanceof IfStatement) {
					if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$($this, funcDef, statements, stmtIndex, statement._expr, (function (stmtIndex) {
						var expr$0;
						expr$0 = (statements[stmtIndex - 1] instanceof ReturnStatement ? statements[stmtIndex - 1]._expr : statements[stmtIndex - 1]._expr);
						statement._expr = expr$0;
						statements.splice(stmtIndex - 1, 1);
					}))) {
						altered = true;
					}
					if (_InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$($this, funcDef, statement)) {
						altered = true;
					}
				} else {
					if (_InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$($this, funcDef, statement)) {
						altered = true;
					}
				}
			}
		}
	}
	statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
		var callExpr;
		var args;
		var callingFuncDef;
		var stmt;
		var argUsed;
		var setupArgs;
		var i;
		var numberOfUsed;
		var argDecl;
		var local;
		var assignToLocal;
		var clonedExpr;
		var message$0;
		var message$0$0;
		expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		if (expr instanceof CallExpression) {
			callExpr = expr;
			args = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$B($this, callExpr, true);
			if (args != null) {
				callingFuncDef = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr);
				message$0 = "expanding " + callingFuncDef.getNotation$() + " as expression";
				message$0$0 = "[" + $this._identifier + "] " + message$0;
				$this._optimizer._log += message$0$0 + "\n";
				stmt = callingFuncDef._statements[0];
				if (stmt instanceof ExpressionStatement) {
					expr = stmt._expr;
				} else {
					if (stmt instanceof ReturnStatement) {
						expr = stmt._expr;
					} else {
						throw new Error('logic flaw');
					}
				}
				argUsed = _InlineOptimizeCommand$_countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, callingFuncDef);
				setupArgs = null;
				for (i = 0; i < args.length; ++ i) {
					if (args[i] instanceof LeafExpression || args[i] == null) {
						continue;
					}
					numberOfUsed = (i < callingFuncDef._args.length ? argUsed[callingFuncDef._args[i]._name._value] : argUsed["this"]);
					if (numberOfUsed === 1 && ! _Util$exprHasSideEffects$LExpression$(args[i])) {
						continue;
					}
					argDecl = callingFuncDef._args[i];
					local = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, args[i].getType$(), (callingFuncDef._nameToken == null ? "$anon" : callingFuncDef._nameToken._value) + "$" + (argDecl != null ? argDecl._name._value : "this"));
					assignToLocal = new AssignmentExpression(new Token$0("="), new LocalExpression(local._name, local), args[i]);
					if (setupArgs == null) {
						setupArgs = assignToLocal;
					} else {
						setupArgs = new CommaExpression(new Token$0(","), assignToLocal, setupArgs);
					}
					args[i] = new LocalExpression(local._name, local);
				}
				clonedExpr = expr.clone$();
				_InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, clonedExpr, (function (expr) {
					clonedExpr = expr;
				}), args, callingFuncDef);
				if (setupArgs != null) {
					clonedExpr = new CommaExpression(new Token$0(","), setupArgs, clonedExpr);
				}
				replaceCb(clonedExpr);
				altered = true;
			}
		}
		return true;
	}));
	return altered;
};

_InlineOptimizeCommand._handleStatement$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$N = _InlineOptimizeCommand$_handleStatement$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$N;

_InlineOptimizeCommand.prototype._countNumberOfArgsUsed$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var formalArgs;
	var map;
	var this$0;
	var i$0;
	var formalArg$0;
	formalArgs = new TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E();
	map = {};
	this$0 = funcDef._args;
	for (i$0 in this$0) {
		formalArg$0 = this$0[i$0];
		TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(formalArgs, formalArg$0, true);
		map[formalArg$0._name._value] = 0;
	}
	map["this"] = 0;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		statement.forEachStatement$F$LStatement$B$(onStatement);
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			if (expr instanceof LocalExpression && TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(formalArgs, LocalExpression$getLocal$LLocalExpression$(expr))) {
				map[Token$getValue$LToken$(LocalVariable$getName$LLocalVariable$(LocalExpression$getLocal$LLocalExpression$(expr)))]++;
			} else {
				if (expr instanceof ThisExpression) {
					map["this"]++;
				}
			}
			return true;
		}));
		return true;
	}), funcDef._statements);
	return map;
};


function _InlineOptimizeCommand$_countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var formalArgs;
	var map;
	var this$0;
	var i$0;
	var formalArg$0;
	formalArgs = new TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E();
	map = {};
	this$0 = funcDef._args;
	for (i$0 in this$0) {
		formalArg$0 = this$0[i$0];
		TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(formalArgs, formalArg$0, true);
		map[formalArg$0._name._value] = 0;
	}
	map["this"] = 0;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		statement.forEachStatement$F$LStatement$B$(onStatement);
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			if (expr instanceof LocalExpression && TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(formalArgs, LocalExpression$getLocal$LLocalExpression$(expr))) {
				map[Token$getValue$LToken$(LocalVariable$getName$LLocalVariable$(LocalExpression$getLocal$LLocalExpression$(expr)))]++;
			} else {
				if (expr instanceof ThisExpression) {
					map["this"]++;
				}
			}
			return true;
		}));
		return true;
	}), funcDef._statements);
	return map;
};

_InlineOptimizeCommand._countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$ = _InlineOptimizeCommand$_countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$;

_InlineOptimizeCommand.prototype._handleSubStatements$LMemberFunctionDefinition$LStatement$ = function (funcDef, statement) {
	var $this = this;
	return _Util$handleSubStatements$F$ALStatement$B$LStatement$((function (statements) {
		return _InlineOptimizeCommand$_handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$($this, funcDef, statements);
	}), statement);
};


function _InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$($this, funcDef, statement) {
	return _Util$handleSubStatements$F$ALStatement$B$LStatement$((function (statements) {
		return _InlineOptimizeCommand$_handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$($this, funcDef, statements);
	}), statement);
};

_InlineOptimizeCommand._handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$ = _InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$;

_InlineOptimizeCommand.prototype._expandStatementExpression$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$ = function (funcDef, statements, stmtIndex, expr, cb) {
	var args;
	var stmt;
	var rhsExpr;
	var lastExpr;
	if (expr instanceof CallExpression) {
		args = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$B(this, expr, false);
		if (args != null) {
			stmtIndex = _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$(this, funcDef, statements, stmtIndex, _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr), args);
			cb(stmtIndex);
			return true;
		}
	} else {
		if (expr instanceof AssignmentExpression && _InlineOptimizeCommand$_lhsHasNoSideEffects$L_InlineOptimizeCommand$LExpression$(this, expr._expr1) && expr._expr2 instanceof CallExpression) {
			args = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$B(this, expr._expr2, false);
			if (args != null) {
				stmtIndex = _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$(this, funcDef, statements, stmtIndex, _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr._expr2), args);
				stmt = statements[stmtIndex - 1];
				if (stmt instanceof ReturnStatement) {
					rhsExpr = stmt._expr;
				} else {
					if (stmt instanceof ExpressionStatement) {
						rhsExpr = stmt._expr;
					} else {
						return false;
					}
				}
				lastExpr = new AssignmentExpression(expr._token, expr._expr1, rhsExpr);
				statements[stmtIndex - 1] = new ExpressionStatement(lastExpr);
				cb(stmtIndex);
				return true;
			}
		}
	}
	return false;
};


function _InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$($this, funcDef, statements, stmtIndex, expr, cb) {
	var args;
	var stmt;
	var rhsExpr;
	var lastExpr;
	if (expr instanceof CallExpression) {
		args = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$B($this, expr, false);
		if (args != null) {
			stmtIndex = _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$($this, funcDef, statements, stmtIndex, _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr), args);
			cb(stmtIndex);
			return true;
		}
	} else {
		if (expr instanceof AssignmentExpression && _InlineOptimizeCommand$_lhsHasNoSideEffects$L_InlineOptimizeCommand$LExpression$($this, expr._expr1) && expr._expr2 instanceof CallExpression) {
			args = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$B($this, expr._expr2, false);
			if (args != null) {
				stmtIndex = _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$($this, funcDef, statements, stmtIndex, _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr._expr2), args);
				stmt = statements[stmtIndex - 1];
				if (stmt instanceof ReturnStatement) {
					rhsExpr = stmt._expr;
				} else {
					if (stmt instanceof ExpressionStatement) {
						rhsExpr = stmt._expr;
					} else {
						return false;
					}
				}
				lastExpr = new AssignmentExpression(expr._token, expr._expr1, rhsExpr);
				statements[stmtIndex - 1] = new ExpressionStatement(lastExpr);
				cb(stmtIndex);
				return true;
			}
		}
	}
	return false;
};

_InlineOptimizeCommand._expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$ = _InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$;

_InlineOptimizeCommand.prototype._lhsHasNoSideEffects$LExpression$ = function (lhsExpr) {
	var holderExpr;
	var arrayExpr;
	var _expr2$0;
	if (lhsExpr instanceof LocalExpression) {
		return true;
	}
	if (lhsExpr instanceof PropertyExpression) {
		holderExpr = lhsExpr._expr;
		if (holderExpr instanceof ThisExpression) {
			return true;
		}
		if (holderExpr instanceof LocalExpression || holderExpr.isClassSpecifier$()) {
			return true;
		}
	} else {
		if (lhsExpr instanceof ArrayExpression) {
			arrayExpr = lhsExpr;
			if (arrayExpr._expr1 instanceof LocalExpression && ((_expr2$0 = arrayExpr._expr2) instanceof NumberLiteralExpression || _expr2$0 instanceof StringLiteralExpression || _expr2$0 instanceof LocalExpression)) {
				return true;
			}
		}
	}
	return false;
};


function _InlineOptimizeCommand$_lhsHasNoSideEffects$L_InlineOptimizeCommand$LExpression$($this, lhsExpr) {
	var holderExpr;
	var arrayExpr;
	var _expr2$0;
	if (lhsExpr instanceof LocalExpression) {
		return true;
	}
	if (lhsExpr instanceof PropertyExpression) {
		holderExpr = lhsExpr._expr;
		if (holderExpr instanceof ThisExpression) {
			return true;
		}
		if (holderExpr instanceof LocalExpression || holderExpr.isClassSpecifier$()) {
			return true;
		}
	} else {
		if (lhsExpr instanceof ArrayExpression) {
			arrayExpr = lhsExpr;
			if (arrayExpr._expr1 instanceof LocalExpression && ((_expr2$0 = arrayExpr._expr2) instanceof NumberLiteralExpression || _expr2$0 instanceof StringLiteralExpression || _expr2$0 instanceof LocalExpression)) {
				return true;
			}
		}
	}
	return false;
};

_InlineOptimizeCommand._lhsHasNoSideEffects$L_InlineOptimizeCommand$LExpression$ = _InlineOptimizeCommand$_lhsHasNoSideEffects$L_InlineOptimizeCommand$LExpression$;

_InlineOptimizeCommand.prototype._getArgsAndThisIfCallExprIsInlineable$LCallExpression$B = function (callExpr, asExpression) {
	var $this = this;
	var callingFuncDef;
	var receiverExpr;
	var calleeExpr;
	var modifiesArgs;
	var argsAndThis;
	callingFuncDef = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(callExpr);
	if (callingFuncDef == null) {
		return null;
	}
	this.optimizeFunction$LMemberFunctionDefinition$(callingFuncDef);
	receiverExpr = null;
	if ((callingFuncDef._flags & 8) === 0) {
		calleeExpr = callExpr._expr;
		if (! (calleeExpr instanceof PropertyExpression)) {
			throw new Error("unexpected type of expression");
		}
		receiverExpr = calleeExpr._expr;
	}
	if (! _InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$(this, callingFuncDef)) {
		return null;
	}
	if (asExpression) {
		if (callingFuncDef._statements.length !== 1) {
			return null;
		}
		if (callingFuncDef._locals.length !== 0) {
			return null;
		}
		modifiesArgs = ! Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var onExpr;
			onExpr = (function onExpr(expr) {
				if (expr instanceof AssignmentExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr) instanceof LocalExpression) {
					return false;
				}
				return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			});
			return Statement$forEachExpression$LStatement$F$LExpression$B$(statement, onExpr);
		}), callingFuncDef._statements);
		if (modifiesArgs) {
			return null;
		}
	}
	if (! _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$B(this, callingFuncDef, callExpr._args, asExpression)) {
		return null;
	}
	argsAndThis = callExpr._args.concat([]);
	if (_InlineOptimizeCommand$_functionHasThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$(this, callingFuncDef)) {
		if (receiverExpr != null) {
			argsAndThis.push(receiverExpr);
		} else {
			argsAndThis.push(new ThisExpression(null, callingFuncDef._classDef));
		}
	} else {
		argsAndThis.push(null);
	}
	return argsAndThis;
};


function _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$B($this, callExpr, asExpression) {
	var callingFuncDef;
	var receiverExpr;
	var calleeExpr;
	var modifiesArgs;
	var argsAndThis;
	callingFuncDef = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(callExpr);
	if (callingFuncDef == null) {
		return null;
	}
	$this.optimizeFunction$LMemberFunctionDefinition$(callingFuncDef);
	receiverExpr = null;
	if ((callingFuncDef._flags & 8) === 0) {
		calleeExpr = callExpr._expr;
		if (! (calleeExpr instanceof PropertyExpression)) {
			throw new Error("unexpected type of expression");
		}
		receiverExpr = calleeExpr._expr;
	}
	if (! _InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, callingFuncDef)) {
		return null;
	}
	if (asExpression) {
		if (callingFuncDef._statements.length !== 1) {
			return null;
		}
		if (callingFuncDef._locals.length !== 0) {
			return null;
		}
		modifiesArgs = ! Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var onExpr;
			onExpr = (function onExpr(expr) {
				if (expr instanceof AssignmentExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr) instanceof LocalExpression) {
					return false;
				}
				return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			});
			return Statement$forEachExpression$LStatement$F$LExpression$B$(statement, onExpr);
		}), callingFuncDef._statements);
		if (modifiesArgs) {
			return null;
		}
	}
	if (! _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$B($this, callingFuncDef, callExpr._args, asExpression)) {
		return null;
	}
	argsAndThis = callExpr._args.concat([]);
	if (_InlineOptimizeCommand$_functionHasThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, callingFuncDef)) {
		if (receiverExpr != null) {
			argsAndThis.push(receiverExpr);
		} else {
			argsAndThis.push(new ThisExpression(null, callingFuncDef._classDef));
		}
	} else {
		argsAndThis.push(null);
	}
	return argsAndThis;
};

_InlineOptimizeCommand._getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$B = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$B;

_InlineOptimizeCommand.prototype._argsAreInlineable$LMemberFunctionDefinition$ALExpression$B = function (callingFuncDef, actualArgs, asExpression) {
	var formalArgsTypes;
	var i;
	var actualArgs$len$0;
	formalArgsTypes = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(callingFuncDef);
	if (actualArgs.length !== formalArgsTypes.length) {
		throw new Error("logic flow, number of arguments mismatch");
	}
	for ((i = 0, actualArgs$len$0 = actualArgs.length); i < actualArgs$len$0; ++ i) {
		if (! _InlineOptimizeCommand$_argIsInlineable$L_InlineOptimizeCommand$LType$LType$(this, actualArgs[i].getType$(), formalArgsTypes[i])) {
			return false;
		}
	}
	return true;
};


function _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$B($this, callingFuncDef, actualArgs, asExpression) {
	var formalArgsTypes;
	var i;
	var actualArgs$len$0;
	formalArgsTypes = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(callingFuncDef);
	if (actualArgs.length !== formalArgsTypes.length) {
		throw new Error("logic flow, number of arguments mismatch");
	}
	for ((i = 0, actualArgs$len$0 = actualArgs.length); i < actualArgs$len$0; ++ i) {
		if (! _InlineOptimizeCommand$_argIsInlineable$L_InlineOptimizeCommand$LType$LType$($this, actualArgs[i].getType$(), formalArgsTypes[i])) {
			return false;
		}
	}
	return true;
};

_InlineOptimizeCommand._argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$B = _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$B;

_InlineOptimizeCommand.prototype._argIsInlineable$LType$LType$ = function (actualType, formalType) {
	if (this._optimizer._enableRunTimeTypeCheck) {
		if (actualType instanceof NullableType && ! (formalType instanceof NullableType)) {
			return false;
		}
	}
	actualType = (actualType instanceof NullableType ? actualType._baseType : actualType);
	formalType = (formalType instanceof NullableType ? formalType._baseType : formalType);
	return (actualType instanceof ObjectType && formalType instanceof ObjectType ? actualType.isConvertibleTo$LType$(formalType) : actualType.equals$LType$(formalType));
};


function _InlineOptimizeCommand$_argIsInlineable$L_InlineOptimizeCommand$LType$LType$($this, actualType, formalType) {
	if ($this._optimizer._enableRunTimeTypeCheck) {
		if (actualType instanceof NullableType && ! (formalType instanceof NullableType)) {
			return false;
		}
	}
	actualType = (actualType instanceof NullableType ? actualType._baseType : actualType);
	formalType = (formalType instanceof NullableType ? formalType._baseType : formalType);
	return (actualType instanceof ObjectType && formalType instanceof ObjectType ? actualType.isConvertibleTo$LType$(formalType) : actualType.equals$LType$(formalType));
};

_InlineOptimizeCommand._argIsInlineable$L_InlineOptimizeCommand$LType$LType$ = _InlineOptimizeCommand$_argIsInlineable$L_InlineOptimizeCommand$LType$LType$;

_InlineOptimizeCommand.prototype._isWorthInline$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var n;
	if (funcDef._nameToken == null) {
		return true;
	}
	n = 0;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var cont;
		cont = Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			if (++ n >= _InlineOptimizeCommand.INLINE_THRESHOLD) {
				return false;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}));
		return (! cont ? false : statement.forEachStatement$F$LStatement$B$(onStatement));
	}), funcDef._statements);
	return n < 30;
};


function _InlineOptimizeCommand$_isWorthInline$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var n;
	if (funcDef._nameToken == null) {
		return true;
	}
	n = 0;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var cont;
		cont = Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			if (++ n >= _InlineOptimizeCommand.INLINE_THRESHOLD) {
				return false;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}));
		return (! cont ? false : statement.forEachStatement$F$LStatement$B$(onStatement));
	}), funcDef._statements);
	return n < 30;
};

_InlineOptimizeCommand._isWorthInline$L_InlineOptimizeCommand$LMemberFunctionDefinition$ = _InlineOptimizeCommand$_isWorthInline$L_InlineOptimizeCommand$LMemberFunctionDefinition$;

_InlineOptimizeCommand.prototype._functionIsInlineable$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var stash;
	var message$0;
	var message$0$0;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$(this, funcDef);
	if (stash.isInlineable == null) {
		stash.isInlineable = (function () {
			var statements;
			var requestsInline;
			statements = funcDef._statements;
			if (statements == null) {
				return false;
			}
			requestsInline = (funcDef._flags & 1024) !== 0;
			if (requestsInline) {
			} else {
				if (! _InlineOptimizeCommand$_isWorthInline$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef)) {
					return false;
				}
			}
			return Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
				if (statement instanceof ExpressionStatement) {
				} else {
					if (requestsInline && (statement instanceof ForStatement || statement instanceof ForInStatement || statement instanceof DoWhileStatement || statement instanceof WhileStatement || statement instanceof IfStatement || statement instanceof SwitchStatement)) {
					} else {
						if (statement instanceof ReturnStatement && statement == MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef)[MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef).length - 1]) {
						} else {
							return false;
						}
					}
				}
				if (! Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
					if (expr instanceof FunctionExpression) {
						return false;
					}
					if (expr instanceof SuperExpression) {
						return false;
					}
					if (expr instanceof LocalExpression) {
						if (MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$(funcDef) != null && MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$(funcDef) == LocalExpression$getLocal$LLocalExpression$(expr)) {
							return false;
						}
					}
					return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
				}))) {
					return false;
				}
				return statement.forEachStatement$F$LStatement$B$(onStatement);
			}), funcDef._statements);
		})();
		message$0 = funcDef.getNotation$() + (stash.isInlineable ? " is" : " is not") + " inlineable";
		message$0$0 = "[" + this._identifier + "] " + message$0;
		this._optimizer._log += message$0$0 + "\n";
	}
	return stash.isInlineable;
};


function _InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var stash;
	var message$0;
	var message$0$0;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, funcDef);
	if (stash.isInlineable == null) {
		stash.isInlineable = (function () {
			var statements;
			var requestsInline;
			statements = funcDef._statements;
			if (statements == null) {
				return false;
			}
			requestsInline = (funcDef._flags & 1024) !== 0;
			if (requestsInline) {
			} else {
				if (! _InlineOptimizeCommand$_isWorthInline$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef)) {
					return false;
				}
			}
			return Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
				if (statement instanceof ExpressionStatement) {
				} else {
					if (requestsInline && (statement instanceof ForStatement || statement instanceof ForInStatement || statement instanceof DoWhileStatement || statement instanceof WhileStatement || statement instanceof IfStatement || statement instanceof SwitchStatement)) {
					} else {
						if (statement instanceof ReturnStatement && statement == MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef)[MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef).length - 1]) {
						} else {
							return false;
						}
					}
				}
				if (! Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
					if (expr instanceof FunctionExpression) {
						return false;
					}
					if (expr instanceof SuperExpression) {
						return false;
					}
					if (expr instanceof LocalExpression) {
						if (MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$(funcDef) != null && MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$(funcDef) == LocalExpression$getLocal$LLocalExpression$(expr)) {
							return false;
						}
					}
					return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
				}))) {
					return false;
				}
				return statement.forEachStatement$F$LStatement$B$(onStatement);
			}), funcDef._statements);
		})();
		message$0 = funcDef.getNotation$() + (stash.isInlineable ? " is" : " is not") + " inlineable";
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		$this._optimizer._log += message$0$0 + "\n";
	}
	return stash.isInlineable;
};

_InlineOptimizeCommand._functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ = _InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$;

_InlineOptimizeCommand.prototype._expandCallingFunction$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$ = function (callerFuncDef, statements, stmtIndex, calleeFuncDef, argsAndThis) {
	var $this = this;
	var argsAndThisAndLocals;
	var calleeStatements;
	var i;
	var statement;
	var onExpr;
	var message$0;
	var message$0$0;
	message$0 = "expanding " + calleeFuncDef.getNotation$();
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	argsAndThisAndLocals = argsAndThis.concat([]);
	stmtIndex = _InlineOptimizeCommand$_createVars$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$(this, callerFuncDef, statements, stmtIndex, calleeFuncDef, argsAndThisAndLocals);
	calleeStatements = calleeFuncDef._statements;
	for (i = 0; i < calleeStatements.length; ++ i) {
		statement = (calleeStatements[i] instanceof ReturnStatement ? new ExpressionStatement(calleeStatements[i]._expr.clone$()) : calleeStatements[i].clone$());
		function onExpr(expr, replaceCb) {
			return _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, expr, replaceCb, argsAndThisAndLocals, calleeFuncDef);
		}
		statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		statement.forEachStatement$F$LStatement$B$((function onStatement(statement) {
			statement.forEachStatement$F$LStatement$B$(onStatement);
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		}));
		statements.splice(stmtIndex++, 0, statement);
	}
	return stmtIndex;
};


function _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$($this, callerFuncDef, statements, stmtIndex, calleeFuncDef, argsAndThis) {
	var argsAndThisAndLocals;
	var calleeStatements;
	var i;
	var statement;
	var onExpr;
	var message$0;
	var message$0$0;
	message$0 = "expanding " + calleeFuncDef.getNotation$();
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	$this._optimizer._log += message$0$0 + "\n";
	argsAndThisAndLocals = argsAndThis.concat([]);
	stmtIndex = _InlineOptimizeCommand$_createVars$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$($this, callerFuncDef, statements, stmtIndex, calleeFuncDef, argsAndThisAndLocals);
	calleeStatements = calleeFuncDef._statements;
	for (i = 0; i < calleeStatements.length; ++ i) {
		statement = (calleeStatements[i] instanceof ReturnStatement ? new ExpressionStatement(calleeStatements[i]._expr.clone$()) : calleeStatements[i].clone$());
		function onExpr(expr, replaceCb) {
			return _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, expr, replaceCb, argsAndThisAndLocals, calleeFuncDef);
		}
		statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		statement.forEachStatement$F$LStatement$B$((function onStatement(statement) {
			statement.forEachStatement$F$LStatement$B$(onStatement);
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		}));
		statements.splice(stmtIndex++, 0, statement);
	}
	return stmtIndex;
};

_InlineOptimizeCommand._expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$ = _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$;

_InlineOptimizeCommand.prototype._createVars$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$ = function (callerFuncDef, statements, stmtIndex, calleeFuncDef, argsAndThisAndLocals) {
	var argUsed;
	var recvExpr;
	var tempExpr;
	var formalArgs;
	var i;
	var locals;
	var tempVar;
	argUsed = _InlineOptimizeCommand$_countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$(this, calleeFuncDef);
	if ((calleeFuncDef._flags & 8) === 0) {
		recvExpr = argsAndThisAndLocals[argsAndThisAndLocals.length - 1];
		if (! (recvExpr instanceof LeafExpression) && (_Util$exprHasSideEffects$LExpression$(recvExpr) || argUsed["this"] > 1)) {
			tempExpr = _InlineOptimizeCommand$_createVarForArgOrThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$LType$S(this, callerFuncDef, statements, stmtIndex, recvExpr, new ObjectType(calleeFuncDef._classDef), "this");
			if (tempExpr != null) {
				argsAndThisAndLocals[argsAndThisAndLocals.length - 1] = tempExpr;
				++ stmtIndex;
			}
		}
	}
	formalArgs = calleeFuncDef._args;
	for (i = 0; i < formalArgs.length; ++ i) {
		if (argsAndThisAndLocals[i] instanceof FunctionExpression && argUsed[formalArgs[i]._name._value] <= 1) {
		} else {
			tempExpr = _InlineOptimizeCommand$_createVarForArgOrThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$LType$S(this, callerFuncDef, statements, stmtIndex, argsAndThisAndLocals[i], formalArgs[i]._type, formalArgs[i]._name._value);
			if (tempExpr != null) {
				argsAndThisAndLocals[i] = tempExpr;
				++ stmtIndex;
			}
		}
	}
	locals = calleeFuncDef._locals;
	for (i = 0; i < locals.length; ++ i) {
		tempVar = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S(this, callerFuncDef, locals[i]._type, locals[i]._name._value);
		argsAndThisAndLocals.push(new LocalExpression(tempVar._name, tempVar));
	}
	return stmtIndex;
};


function _InlineOptimizeCommand$_createVars$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$($this, callerFuncDef, statements, stmtIndex, calleeFuncDef, argsAndThisAndLocals) {
	var argUsed;
	var recvExpr;
	var tempExpr;
	var formalArgs;
	var i;
	var locals;
	var tempVar;
	argUsed = _InlineOptimizeCommand$_countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, calleeFuncDef);
	if ((calleeFuncDef._flags & 8) === 0) {
		recvExpr = argsAndThisAndLocals[argsAndThisAndLocals.length - 1];
		if (! (recvExpr instanceof LeafExpression) && (_Util$exprHasSideEffects$LExpression$(recvExpr) || argUsed["this"] > 1)) {
			tempExpr = _InlineOptimizeCommand$_createVarForArgOrThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$LType$S($this, callerFuncDef, statements, stmtIndex, recvExpr, new ObjectType(calleeFuncDef._classDef), "this");
			if (tempExpr != null) {
				argsAndThisAndLocals[argsAndThisAndLocals.length - 1] = tempExpr;
				++ stmtIndex;
			}
		}
	}
	formalArgs = calleeFuncDef._args;
	for (i = 0; i < formalArgs.length; ++ i) {
		if (argsAndThisAndLocals[i] instanceof FunctionExpression && argUsed[formalArgs[i]._name._value] <= 1) {
		} else {
			tempExpr = _InlineOptimizeCommand$_createVarForArgOrThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$LType$S($this, callerFuncDef, statements, stmtIndex, argsAndThisAndLocals[i], formalArgs[i]._type, formalArgs[i]._name._value);
			if (tempExpr != null) {
				argsAndThisAndLocals[i] = tempExpr;
				++ stmtIndex;
			}
		}
	}
	locals = calleeFuncDef._locals;
	for (i = 0; i < locals.length; ++ i) {
		tempVar = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, callerFuncDef, locals[i]._type, locals[i]._name._value);
		argsAndThisAndLocals.push(new LocalExpression(tempVar._name, tempVar));
	}
	return stmtIndex;
};

_InlineOptimizeCommand._createVars$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$ = _InlineOptimizeCommand$_createVars$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$;

_InlineOptimizeCommand.prototype._createVarForArgOrThis$LMemberFunctionDefinition$ALStatement$NLExpression$LType$S = function (callerFuncDef, statements, stmtIndex, expr, type, baseName) {
	var newLocal;
	if (expr instanceof LeafExpression) {
		return null;
	}
	newLocal = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S(this, callerFuncDef, type, baseName);
	statements.splice(stmtIndex, 0, new ExpressionStatement(new AssignmentExpression(new Token$0("="), new LocalExpression(newLocal._name, newLocal), expr)));
	return new LocalExpression(newLocal._name, newLocal);
};


function _InlineOptimizeCommand$_createVarForArgOrThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$LType$S($this, callerFuncDef, statements, stmtIndex, expr, type, baseName) {
	var newLocal;
	if (expr instanceof LeafExpression) {
		return null;
	}
	newLocal = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, callerFuncDef, type, baseName);
	statements.splice(stmtIndex, 0, new ExpressionStatement(new AssignmentExpression(new Token$0("="), new LocalExpression(newLocal._name, newLocal), expr)));
	return new LocalExpression(newLocal._name, newLocal);
};

_InlineOptimizeCommand._createVarForArgOrThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$LType$S = _InlineOptimizeCommand$_createVarForArgOrThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$LType$S;

_InlineOptimizeCommand.prototype._rewriteExpression$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$ = function (expr, replaceCb, argsAndThisAndLocals, calleeFuncDef) {
	var $this = this;
	var formalArgs;
	var j;
	var locals;
	var k;
	var formalArgs$len$0;
	var locals$len$0;
	formalArgs = calleeFuncDef._args;
	if (expr instanceof LocalExpression) {
		for ((j = 0, formalArgs$len$0 = formalArgs.length); j < formalArgs$len$0; ++ j) {
			if (formalArgs[j]._name._value === expr._token._value) {
				break;
			}
		}
		if (j === formalArgs.length) {
			++ j;
			locals = calleeFuncDef._locals;
			for ((k = 0, locals$len$0 = locals.length); k < locals$len$0; (++ k, ++ j)) {
				if (locals[k]._name._value === expr._token._value) {
					break;
				}
			}
		}
		if (j !== argsAndThisAndLocals.length) {
			if (argsAndThisAndLocals[j] instanceof FunctionExpression) {
				replaceCb(argsAndThisAndLocals[j]);
				argsAndThisAndLocals[j] = null;
			} else {
				replaceCb(argsAndThisAndLocals[j].clone$());
			}
		}
	} else {
		if (expr instanceof ThisExpression) {
			replaceCb(argsAndThisAndLocals[formalArgs.length].clone$());
		}
	}
	expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
		return _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, expr, replaceCb, argsAndThisAndLocals, calleeFuncDef);
	}));
	return true;
};


function _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, expr, replaceCb, argsAndThisAndLocals, calleeFuncDef) {
	var formalArgs;
	var j;
	var locals;
	var k;
	var formalArgs$len$0;
	var locals$len$0;
	formalArgs = calleeFuncDef._args;
	if (expr instanceof LocalExpression) {
		for ((j = 0, formalArgs$len$0 = formalArgs.length); j < formalArgs$len$0; ++ j) {
			if (formalArgs[j]._name._value === expr._token._value) {
				break;
			}
		}
		if (j === formalArgs.length) {
			++ j;
			locals = calleeFuncDef._locals;
			for ((k = 0, locals$len$0 = locals.length); k < locals$len$0; (++ k, ++ j)) {
				if (locals[k]._name._value === expr._token._value) {
					break;
				}
			}
		}
		if (j !== argsAndThisAndLocals.length) {
			if (argsAndThisAndLocals[j] instanceof FunctionExpression) {
				replaceCb(argsAndThisAndLocals[j]);
				argsAndThisAndLocals[j] = null;
			} else {
				replaceCb(argsAndThisAndLocals[j].clone$());
			}
		}
	} else {
		if (expr instanceof ThisExpression) {
			replaceCb(argsAndThisAndLocals[formalArgs.length].clone$());
		}
	}
	expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
		return _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, expr, replaceCb, argsAndThisAndLocals, calleeFuncDef);
	}));
	return true;
};

_InlineOptimizeCommand._rewriteExpression$L_InlineOptimizeCommand$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$ = _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$;

_InlineOptimizeCommand.prototype._functionHasThis$LMemberFunctionDefinition$ = function (funcDef) {
	do {
		if ((funcDef._flags & 8) === 0) {
			return true;
		}
	} while ((funcDef = funcDef._parent) != null);
	return false;
};


function _InlineOptimizeCommand$_functionHasThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	do {
		if ((funcDef._flags & 8) === 0) {
			return true;
		}
	} while ((funcDef = funcDef._parent) != null);
	return false;
};

_InlineOptimizeCommand._functionHasThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$ = _InlineOptimizeCommand$_functionHasThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$;

function _ReturnIfOptimizeCommand() {
	this._identifier = "return-if";
	this._optimizer = null;
	this._excludeNative = false;
	this._altered = false;
};

$__jsx_extend([_ReturnIfOptimizeCommand], _FunctionOptimizeCommand);
_ReturnIfOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var message$0;
	var message$0$0;
	if (funcDef._returnType.equals$LType$(Type.voidType)) {
		return false;
	}
	this._altered = false;
	_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$(this, funcDef._statements);
	message$0 = funcDef.getNotation$() + " " + (this._altered ? "Y" : "N");
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	return this._altered;
};


_ReturnIfOptimizeCommand.prototype._statementsCanBeReturnExpr$ALStatement$ = function (statements) {
	if (statements.length === 1 && statements[0] instanceof ReturnStatement) {
		return true;
	}
	_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$(this, statements);
	return (statements.length === 1 && statements[0] instanceof ReturnStatement ? true : false);
};


function _ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$($this, statements) {
	if (statements.length === 1 && statements[0] instanceof ReturnStatement) {
		return true;
	}
	_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$($this, statements);
	return (statements.length === 1 && statements[0] instanceof ReturnStatement ? true : false);
};

_ReturnIfOptimizeCommand._statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$ = _ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$;

_ReturnIfOptimizeCommand.prototype._optimizeStatements$ALStatement$ = function (statements) {
	var ifStatement;
	var onFalseStatements;
	var _createReturnStatement$falseExpr$0;
	var _createReturnStatement$falseExpr$1;
	if (statements.length >= 1 && statements[statements.length - 1] instanceof IfStatement) {
		ifStatement = statements[statements.length - 1];
		if (_ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$(this, ifStatement._onTrueStatements) && _ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$(this, ifStatement._onFalseStatements)) {
			statements[statements.length - 1] = (_createReturnStatement$falseExpr$0 = ifStatement._onFalseStatements[0]._expr, new ReturnStatement(ifStatement._token, new ConditionalExpression$0(new Token$1("?", false), ifStatement._expr, ifStatement._onTrueStatements[0]._expr, _createReturnStatement$falseExpr$0, _createReturnStatement$falseExpr$0.getType$())));
			this._altered = true;
			_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$(this, statements);
		}
	} else {
		if (statements.length >= 2 && statements[statements.length - 1] instanceof ReturnStatement && statements[statements.length - 2] instanceof IfStatement) {
			ifStatement = statements[statements.length - 2];
			if (_ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$(this, ifStatement._onTrueStatements)) {
				onFalseStatements = ifStatement._onFalseStatements;
				if (onFalseStatements.length === 0) {
					statements.splice(statements.length - 2, 2, (_createReturnStatement$falseExpr$1 = statements[statements.length - 1]._expr, new ReturnStatement(ifStatement._token, new ConditionalExpression$0(new Token$1("?", false), ifStatement._expr, ifStatement._onTrueStatements[0]._expr, _createReturnStatement$falseExpr$1, _createReturnStatement$falseExpr$1.getType$()))));
					this._altered = true;
					_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$(this, statements);
				} else {
					if (onFalseStatements.length === 1 && onFalseStatements[0] instanceof IfStatement && onFalseStatements[0]._onFalseStatements.length === 0) {
						onFalseStatements[0]._onFalseStatements.push(statements[statements.length - 1]);
						statements.pop();
						this._altered = true;
						_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$(this, statements);
					}
				}
			}
		}
	}
};


function _ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$($this, statements) {
	var ifStatement;
	var onFalseStatements;
	var _createReturnStatement$falseExpr$0;
	var _createReturnStatement$falseExpr$1;
	if (statements.length >= 1 && statements[statements.length - 1] instanceof IfStatement) {
		ifStatement = statements[statements.length - 1];
		if (_ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$($this, ifStatement._onTrueStatements) && _ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$($this, ifStatement._onFalseStatements)) {
			statements[statements.length - 1] = (_createReturnStatement$falseExpr$0 = ifStatement._onFalseStatements[0]._expr, new ReturnStatement(ifStatement._token, new ConditionalExpression$0(new Token$1("?", false), ifStatement._expr, ifStatement._onTrueStatements[0]._expr, _createReturnStatement$falseExpr$0, _createReturnStatement$falseExpr$0.getType$())));
			$this._altered = true;
			_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$($this, statements);
		}
	} else {
		if (statements.length >= 2 && statements[statements.length - 1] instanceof ReturnStatement && statements[statements.length - 2] instanceof IfStatement) {
			ifStatement = statements[statements.length - 2];
			if (_ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$($this, ifStatement._onTrueStatements)) {
				onFalseStatements = ifStatement._onFalseStatements;
				if (onFalseStatements.length === 0) {
					statements.splice(statements.length - 2, 2, (_createReturnStatement$falseExpr$1 = statements[statements.length - 1]._expr, new ReturnStatement(ifStatement._token, new ConditionalExpression$0(new Token$1("?", false), ifStatement._expr, ifStatement._onTrueStatements[0]._expr, _createReturnStatement$falseExpr$1, _createReturnStatement$falseExpr$1.getType$()))));
					$this._altered = true;
					_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$($this, statements);
				} else {
					if (onFalseStatements.length === 1 && onFalseStatements[0] instanceof IfStatement && onFalseStatements[0]._onFalseStatements.length === 0) {
						onFalseStatements[0]._onFalseStatements.push(statements[statements.length - 1]);
						statements.pop();
						$this._altered = true;
						_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$($this, statements);
					}
				}
			}
		}
	}
};

_ReturnIfOptimizeCommand._optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$ = _ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$;

_ReturnIfOptimizeCommand.prototype._createReturnStatement$LToken$LExpression$LExpression$LExpression$ = function (token, condExpr, trueExpr, falseExpr) {
	return new ReturnStatement(token, new ConditionalExpression$0(new Token$1("?", false), condExpr, trueExpr, falseExpr, falseExpr.getType$()));
};


function _ReturnIfOptimizeCommand$_createReturnStatement$L_ReturnIfOptimizeCommand$LToken$LExpression$LExpression$LExpression$($this, token, condExpr, trueExpr, falseExpr) {
	return new ReturnStatement(token, new ConditionalExpression$0(new Token$1("?", false), condExpr, trueExpr, falseExpr, falseExpr.getType$()));
};

_ReturnIfOptimizeCommand._createReturnStatement$L_ReturnIfOptimizeCommand$LToken$LExpression$LExpression$LExpression$ = _ReturnIfOptimizeCommand$_createReturnStatement$L_ReturnIfOptimizeCommand$LToken$LExpression$LExpression$LExpression$;

function _LCSECachedExpression(origExpr, replaceCb) {
	this._origExpr = origExpr;
	this._replaceCb = replaceCb;
	this._localExpr = null;
};

$__jsx_extend([_LCSECachedExpression], Object);
function _LCSECachedExpression$getOrigExpr$L_LCSECachedExpression$($this) {
	return $this._origExpr;
};

_LCSECachedExpression.getOrigExpr$L_LCSECachedExpression$ = _LCSECachedExpression$getOrigExpr$L_LCSECachedExpression$;

function _LCSECachedExpression$getLocalExpr$L_LCSECachedExpression$F$LType$SLLocalExpression$$($this, createVarCb) {
	if ($this._localExpr == null) {
		$this._localExpr = createVarCb($this._origExpr.getType$(), $this._origExpr._identifierToken._value);
		$this._replaceCb(new AssignmentExpression(new Token$1("=", false), $this._localExpr, $this._origExpr));
	}
	return $this._localExpr;
};

_LCSECachedExpression.getLocalExpr$L_LCSECachedExpression$F$LType$SLLocalExpression$$ = _LCSECachedExpression$getLocalExpr$L_LCSECachedExpression$F$LType$SLLocalExpression$$;

function _LCSEOptimizeCommand() {
	this._identifier = "lcse";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_LCSEOptimizeCommand], _FunctionOptimizeCommand);
_LCSEOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	_Util$optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$(funcDef, (function (exprs) {
		_LCSEOptimizeCommand$_optimizeExpressions$L_LCSEOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
	}));
	return true;
};


_LCSEOptimizeCommand.prototype._optimizeExpressions$LMemberFunctionDefinition$ALExpression$ = function (funcDef, exprs) {
	var $this = this;
	var cachedExprs;
	var getCacheKey;
	var registerCacheable;
	var clearCacheByLocalName;
	var clearCache;
	var onExpr;
	var message$0$0;
	message$0$0 = "[" + this._identifier + "] " + "optimizing expressions starting";
	this._optimizer._log += message$0$0 + "\n";
	cachedExprs = {};
	getCacheKey = (function (expr) {
		var propertyExpr;
		var receiverType;
		var base;
		var this$0;
		if (expr instanceof PropertyExpression) {
			propertyExpr = expr;
			receiverType = propertyExpr._expr.getType$();
			if (receiverType instanceof ObjectType && _Util$classIsNative$LClassDefinition$(receiverType.getClassDef$())) {
				return null;
			}
			base = getCacheKey(propertyExpr._expr);
			return (base == null ? null : base + "." + propertyExpr._identifierToken._value);
		} else {
			if (expr instanceof LocalExpression) {
				this$0 = expr._local._name;
				return this$0._value;
			} else {
				if (expr instanceof ThisExpression) {
					return "this";
				}
			}
		}
		return null;
	});
	registerCacheable = (function (key, expr, replaceCb) {
		var message$0;
		var message$0$0;
		message$0 = "registering lcse entry for: " + key;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		$this._optimizer._log += message$0$0 + "\n";
		cachedExprs[key] = ({_origExpr: expr, _replaceCb: replaceCb, _localExpr: null});
	});
	clearCacheByLocalName = (function (name) {
		var k;
		var message$0;
		var message$0$0;
		var message$1;
		var message$0$1;
		message$0 = "clearing lcse entry for local name: " + name;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		$this._optimizer._log += message$0$0 + "\n";
		for (k in cachedExprs) {
			if (k.substring(0, name.length + 1) === name + ".") {
				message$1 = "  removing: " + k;
				message$0$1 = "[" + $this._identifier + "] " + message$1;
				$this._optimizer._log += message$0$1 + "\n";
				delete cachedExprs[k];
			}
		}
	});
	clearCache = (function () {
		var message$0$0;
		message$0$0 = "[" + $this._identifier + "] " + "clearing lcse cache";
		$this._optimizer._log += message$0$0 + "\n";
		cachedExprs = {};
	});
	onExpr = (function (expr, replaceCb) {
		var assignmentExpr;
		var lhsExpr;
		var lhsPropertyExpr;
		var cacheKey;
		var incrementExpr;
		var propertyExpr;
		var conditionalExpr;
		var funcExpr;
		var args;
		var i;
		var message$0$0;
		var message$0;
		var message$0$1;
		if (expr instanceof AssignmentExpression) {
			assignmentExpr = expr;
			lhsExpr = assignmentExpr._expr1;
			if (lhsExpr instanceof LocalExpression) {
				onExpr(assignmentExpr._expr2, (function (expr) {
					BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
				}));
				clearCacheByLocalName(lhsExpr._local._name._value);
			} else {
				if (lhsExpr instanceof PropertyExpression) {
					lhsPropertyExpr = lhsExpr;
					onExpr(lhsExpr._expr, (function (expr) {
						UnaryExpression$setExpr$LUnaryExpression$LExpression$(lhsPropertyExpr, expr);
					}));
					onExpr(assignmentExpr._expr2, (function (expr) {
						BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
					}));
					if (lhsPropertyExpr._identifierToken._value === "length") {
					} else {
						cacheKey = getCacheKey(lhsExpr);
						if (cacheKey) {
							registerCacheable(cacheKey, lhsExpr, (function (expr) {
								BinaryExpression$setFirstExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
							}));
						}
					}
				} else {
					clearCache();
				}
			}
			return true;
		} else {
			if (expr instanceof IncrementExpression) {
				incrementExpr = expr;
				if (incrementExpr._expr instanceof PropertyExpression) {
					propertyExpr = incrementExpr._expr;
					onExpr(propertyExpr._expr, (function (expr) {
						UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
					}));
				}
				clearCache();
				return true;
			} else {
				if (expr instanceof ConditionalExpression) {
					conditionalExpr = expr;
					onExpr(conditionalExpr._condExpr, (function (expr) {
						ConditionalExpression$setCondExpr$LConditionalExpression$LExpression$(conditionalExpr, expr);
					}));
					clearCache();
					return true;
				} else {
					if (expr instanceof FunctionExpression) {
						clearCache();
						return true;
					} else {
						if (expr instanceof CallExpression) {
							funcExpr = expr._expr;
							if (funcExpr instanceof LocalExpression) {
							} else {
								if (funcExpr instanceof PropertyExpression) {
									propertyExpr = funcExpr;
									onExpr(propertyExpr._expr, (function (expr) {
										UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
									}));
								} else {
									clearCache();
								}
							}
							args = expr._args;
							for (i = 0; i < args.length; ++ i) {
								onExpr(args[i], (function (args, index) {
									return (function (expr) {
										args[index] = expr;
									});
								})(args, i));
							}
							clearCache();
							return true;
						} else {
							if (expr instanceof NewExpression) {
								message$0$0 = "[" + $this._identifier + "] " + "new expression";
								$this._optimizer._log += message$0$0 + "\n";
								args = expr._args;
								for (i = 0; i < args.length; ++ i) {
									onExpr(args[i], (function (args, index) {
										return (function (expr) {
											args[index] = expr;
										});
									})(args, i));
								}
								clearCache();
								return true;
							}
						}
					}
				}
			}
		}
		if (expr instanceof PropertyExpression) {
			if (expr._identifierToken._value === "length") {
			} else {
				cacheKey = getCacheKey(expr);
				if (cacheKey) {
					message$0 = "rewriting cse for: " + cacheKey;
					message$0$1 = "[" + $this._identifier + "] " + message$0;
					$this._optimizer._log += message$0$1 + "\n";
					if (cachedExprs[cacheKey]) {
						replaceCb(_LCSECachedExpression$getLocalExpr$L_LCSECachedExpression$F$LType$SLLocalExpression$$(cachedExprs[cacheKey], (function (type, baseName) {
							var localVar;
							localVar = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, type, baseName);
							return new LocalExpression(LocalVariable$getName$LLocalVariable$(localVar), localVar);
						})).clone$());
					} else {
						registerCacheable(cacheKey, expr, replaceCb);
					}
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};


function _LCSEOptimizeCommand$_optimizeExpressions$L_LCSEOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs) {
	var cachedExprs;
	var getCacheKey;
	var registerCacheable;
	var clearCacheByLocalName;
	var clearCache;
	var onExpr;
	var message$0$0;
	message$0$0 = "[" + $this._identifier + "] " + "optimizing expressions starting";
	$this._optimizer._log += message$0$0 + "\n";
	cachedExprs = {};
	getCacheKey = (function (expr) {
		var propertyExpr;
		var receiverType;
		var base;
		var this$0;
		if (expr instanceof PropertyExpression) {
			propertyExpr = expr;
			receiverType = propertyExpr._expr.getType$();
			if (receiverType instanceof ObjectType && _Util$classIsNative$LClassDefinition$(receiverType.getClassDef$())) {
				return null;
			}
			base = getCacheKey(propertyExpr._expr);
			return (base == null ? null : base + "." + propertyExpr._identifierToken._value);
		} else {
			if (expr instanceof LocalExpression) {
				this$0 = expr._local._name;
				return this$0._value;
			} else {
				if (expr instanceof ThisExpression) {
					return "this";
				}
			}
		}
		return null;
	});
	registerCacheable = (function (key, expr, replaceCb) {
		var message$0;
		var message$0$0;
		message$0 = "registering lcse entry for: " + key;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		$this._optimizer._log += message$0$0 + "\n";
		cachedExprs[key] = ({_origExpr: expr, _replaceCb: replaceCb, _localExpr: null});
	});
	clearCacheByLocalName = (function (name) {
		var k;
		var message$0;
		var message$0$0;
		var message$1;
		var message$0$1;
		message$0 = "clearing lcse entry for local name: " + name;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		$this._optimizer._log += message$0$0 + "\n";
		for (k in cachedExprs) {
			if (k.substring(0, name.length + 1) === name + ".") {
				message$1 = "  removing: " + k;
				message$0$1 = "[" + $this._identifier + "] " + message$1;
				$this._optimizer._log += message$0$1 + "\n";
				delete cachedExprs[k];
			}
		}
	});
	clearCache = (function () {
		var message$0$0;
		message$0$0 = "[" + $this._identifier + "] " + "clearing lcse cache";
		$this._optimizer._log += message$0$0 + "\n";
		cachedExprs = {};
	});
	onExpr = (function (expr, replaceCb) {
		var assignmentExpr;
		var lhsExpr;
		var lhsPropertyExpr;
		var cacheKey;
		var incrementExpr;
		var propertyExpr;
		var conditionalExpr;
		var funcExpr;
		var args;
		var i;
		var message$0$0;
		var message$0;
		var message$0$1;
		if (expr instanceof AssignmentExpression) {
			assignmentExpr = expr;
			lhsExpr = assignmentExpr._expr1;
			if (lhsExpr instanceof LocalExpression) {
				onExpr(assignmentExpr._expr2, (function (expr) {
					BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
				}));
				clearCacheByLocalName(lhsExpr._local._name._value);
			} else {
				if (lhsExpr instanceof PropertyExpression) {
					lhsPropertyExpr = lhsExpr;
					onExpr(lhsExpr._expr, (function (expr) {
						UnaryExpression$setExpr$LUnaryExpression$LExpression$(lhsPropertyExpr, expr);
					}));
					onExpr(assignmentExpr._expr2, (function (expr) {
						BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
					}));
					if (lhsPropertyExpr._identifierToken._value === "length") {
					} else {
						cacheKey = getCacheKey(lhsExpr);
						if (cacheKey) {
							registerCacheable(cacheKey, lhsExpr, (function (expr) {
								BinaryExpression$setFirstExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
							}));
						}
					}
				} else {
					clearCache();
				}
			}
			return true;
		} else {
			if (expr instanceof IncrementExpression) {
				incrementExpr = expr;
				if (incrementExpr._expr instanceof PropertyExpression) {
					propertyExpr = incrementExpr._expr;
					onExpr(propertyExpr._expr, (function (expr) {
						UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
					}));
				}
				clearCache();
				return true;
			} else {
				if (expr instanceof ConditionalExpression) {
					conditionalExpr = expr;
					onExpr(conditionalExpr._condExpr, (function (expr) {
						ConditionalExpression$setCondExpr$LConditionalExpression$LExpression$(conditionalExpr, expr);
					}));
					clearCache();
					return true;
				} else {
					if (expr instanceof FunctionExpression) {
						clearCache();
						return true;
					} else {
						if (expr instanceof CallExpression) {
							funcExpr = expr._expr;
							if (funcExpr instanceof LocalExpression) {
							} else {
								if (funcExpr instanceof PropertyExpression) {
									propertyExpr = funcExpr;
									onExpr(propertyExpr._expr, (function (expr) {
										UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
									}));
								} else {
									clearCache();
								}
							}
							args = expr._args;
							for (i = 0; i < args.length; ++ i) {
								onExpr(args[i], (function (args, index) {
									return (function (expr) {
										args[index] = expr;
									});
								})(args, i));
							}
							clearCache();
							return true;
						} else {
							if (expr instanceof NewExpression) {
								message$0$0 = "[" + $this._identifier + "] " + "new expression";
								$this._optimizer._log += message$0$0 + "\n";
								args = expr._args;
								for (i = 0; i < args.length; ++ i) {
									onExpr(args[i], (function (args, index) {
										return (function (expr) {
											args[index] = expr;
										});
									})(args, i));
								}
								clearCache();
								return true;
							}
						}
					}
				}
			}
		}
		if (expr instanceof PropertyExpression) {
			if (expr._identifierToken._value === "length") {
			} else {
				cacheKey = getCacheKey(expr);
				if (cacheKey) {
					message$0 = "rewriting cse for: " + cacheKey;
					message$0$1 = "[" + $this._identifier + "] " + message$0;
					$this._optimizer._log += message$0$1 + "\n";
					if (cachedExprs[cacheKey]) {
						replaceCb(_LCSECachedExpression$getLocalExpr$L_LCSECachedExpression$F$LType$SLLocalExpression$$(cachedExprs[cacheKey], (function (type, baseName) {
							var localVar;
							localVar = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, type, baseName);
							return new LocalExpression(LocalVariable$getName$LLocalVariable$(localVar), localVar);
						})).clone$());
					} else {
						registerCacheable(cacheKey, expr, replaceCb);
					}
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};

_LCSEOptimizeCommand._optimizeExpressions$L_LCSEOptimizeCommand$LMemberFunctionDefinition$ALExpression$ = _LCSEOptimizeCommand$_optimizeExpressions$L_LCSEOptimizeCommand$LMemberFunctionDefinition$ALExpression$;

function _UnboxOptimizeCommand() {
	this._identifier = "unbox";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_UnboxOptimizeCommand], _FunctionOptimizeCommand);
_UnboxOptimizeCommand.prototype._createStash$ = function () {
	return new _UnboxOptimizeCommand$x2EStash();
};


_UnboxOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var locals;
	var i;
	var iMax;
	if (funcDef._statements == null) {
		return false;
	}
	locals = funcDef._locals;
	for ((i = 0, iMax = locals.length); i < iMax; ) {
		if (_UnboxOptimizeCommand$_optimizeLocal$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$(this, funcDef, locals[i])) {
			locals.splice(i, 1);
		} else {
			++ i;
		}
	}
	return true;
};


_UnboxOptimizeCommand.prototype._optimizeLocal$LMemberFunctionDefinition$LLocalVariable$ = function (funcDef, local) {
	var $this = this;
	var classDef;
	var foundNew;
	var onStatement;
	var canUnbox;
	if (! (local._type instanceof ObjectType)) {
		return false;
	}
	classDef = local._type.getClassDef$();
	if (_Util$classIsNative$LClassDefinition$(classDef)) {
		return false;
	}
	foundNew = false;
	onStatement = (function (statement) {
		var onExpr;
		var newExpr;
		onExpr = (function (expr) {
			var baseExpr;
			if (expr instanceof PropertyExpression) {
				baseExpr = UnaryExpression$getExpr$LUnaryExpression$(expr);
				if (baseExpr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(baseExpr) == local) {
					if (! expr.getType$().isAssignable$()) {
						return false;
					}
					return true;
				}
			} else {
				if (expr instanceof LocalExpression) {
					if (LocalExpression$getLocal$LLocalExpression$(expr) == local) {
						return false;
					}
				} else {
					if (expr instanceof FunctionExpression) {
						return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
					}
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		});
		newExpr = _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$($this, statement, local);
		if (newExpr != null) {
			if (! newExpr._type.equals$LType$(local._type)) {
				return false;
			}
			if (! _UnboxOptimizeCommand$_newExpressionCanUnbox$L_UnboxOptimizeCommand$LExpression$($this, newExpr)) {
				return false;
			}
			if (! Expression$forEachExpression$LExpression$F$LExpression$B$(newExpr, onExpr)) {
				return false;
			}
			if (! Util$forEachExpression$F$LExpression$B$ALExpression$((function (expr) {
				return ! _Util$exprHasSideEffects$LExpression$(expr);
			}), newExpr._args)) {
				return false;
			}
			foundNew = true;
			return true;
		}
		if (statement instanceof FunctionStatement) {
			if (! Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, statement._funcDef._statements)) {
				return false;
			}
		}
		return (! Statement$forEachExpression$LStatement$F$LExpression$B$(statement, onExpr) ? false : statement.forEachStatement$F$LStatement$B$(onStatement));
	});
	canUnbox = Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, funcDef._statements);
	if (canUnbox && foundNew) {
		_UnboxOptimizeCommand$_unboxVariable$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$(this, funcDef, local);
		return true;
	} else {
		return false;
	}
};


function _UnboxOptimizeCommand$_optimizeLocal$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$($this, funcDef, local) {
	var classDef;
	var foundNew;
	var onStatement;
	var canUnbox;
	if (! (local._type instanceof ObjectType)) {
		return false;
	}
	classDef = local._type.getClassDef$();
	if (_Util$classIsNative$LClassDefinition$(classDef)) {
		return false;
	}
	foundNew = false;
	onStatement = (function (statement) {
		var onExpr;
		var newExpr;
		onExpr = (function (expr) {
			var baseExpr;
			if (expr instanceof PropertyExpression) {
				baseExpr = UnaryExpression$getExpr$LUnaryExpression$(expr);
				if (baseExpr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(baseExpr) == local) {
					if (! expr.getType$().isAssignable$()) {
						return false;
					}
					return true;
				}
			} else {
				if (expr instanceof LocalExpression) {
					if (LocalExpression$getLocal$LLocalExpression$(expr) == local) {
						return false;
					}
				} else {
					if (expr instanceof FunctionExpression) {
						return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
					}
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		});
		newExpr = _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$($this, statement, local);
		if (newExpr != null) {
			if (! newExpr._type.equals$LType$(local._type)) {
				return false;
			}
			if (! _UnboxOptimizeCommand$_newExpressionCanUnbox$L_UnboxOptimizeCommand$LExpression$($this, newExpr)) {
				return false;
			}
			if (! Expression$forEachExpression$LExpression$F$LExpression$B$(newExpr, onExpr)) {
				return false;
			}
			if (! Util$forEachExpression$F$LExpression$B$ALExpression$((function (expr) {
				return ! _Util$exprHasSideEffects$LExpression$(expr);
			}), newExpr._args)) {
				return false;
			}
			foundNew = true;
			return true;
		}
		if (statement instanceof FunctionStatement) {
			if (! Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, statement._funcDef._statements)) {
				return false;
			}
		}
		return (! Statement$forEachExpression$LStatement$F$LExpression$B$(statement, onExpr) ? false : statement.forEachStatement$F$LStatement$B$(onStatement));
	});
	canUnbox = Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, funcDef._statements);
	if (canUnbox && foundNew) {
		_UnboxOptimizeCommand$_unboxVariable$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$($this, funcDef, local);
		return true;
	} else {
		return false;
	}
};

_UnboxOptimizeCommand._optimizeLocal$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$ = _UnboxOptimizeCommand$_optimizeLocal$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$;

_UnboxOptimizeCommand.prototype._newExpressionCanUnbox$LExpression$ = function (newExpr) {
	var $this = this;
	var ctor;
	var stash;
	if ((newExpr.getType$().getClassDef$().flags$() & 16) !== 0) {
		return false;
	}
	ctor = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(newExpr);
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$(this, ctor);
	return (stash.canUnbox != null ? stash.canUnbox : stash.canUnbox = (function () {
		return (ctor._locals.length !== 0 ? false : Util$forEachStatement$F$LStatement$B$ALStatement$((function (statement) {
			var assigned;
			var expr;
			var lhsExpr;
			var propertyName;
			assigned = {};
			if (! (statement instanceof ExpressionStatement)) {
				return false;
			}
			expr = UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement);
			if (! (expr instanceof AssignmentExpression)) {
				return false;
			}
			lhsExpr = BinaryExpression$getFirstExpr$LBinaryExpression$(expr);
			if (! (lhsExpr instanceof PropertyExpression && UnaryExpression$getExpr$LUnaryExpression$(lhsExpr) instanceof ThisExpression)) {
				return false;
			}
			propertyName = Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(lhsExpr));
			if (assigned[propertyName]) {
				return false;
			}
			assigned[propertyName] = true;
			return (function onExpr(expr) {
				if (expr instanceof ThisExpression) {
					return false;
				} else {
					if (expr instanceof FunctionExpression) {
						return false;
					}
				}
				return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			})(BinaryExpression$getSecondExpr$LBinaryExpression$(expr));
		}), ctor._statements));
	})());
};


function _UnboxOptimizeCommand$_newExpressionCanUnbox$L_UnboxOptimizeCommand$LExpression$($this, newExpr) {
	var ctor;
	var stash;
	if ((newExpr.getType$().getClassDef$().flags$() & 16) !== 0) {
		return false;
	}
	ctor = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(newExpr);
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$($this, ctor);
	return (stash.canUnbox != null ? stash.canUnbox : stash.canUnbox = (function () {
		return (ctor._locals.length !== 0 ? false : Util$forEachStatement$F$LStatement$B$ALStatement$((function (statement) {
			var assigned;
			var expr;
			var lhsExpr;
			var propertyName;
			assigned = {};
			if (! (statement instanceof ExpressionStatement)) {
				return false;
			}
			expr = UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement);
			if (! (expr instanceof AssignmentExpression)) {
				return false;
			}
			lhsExpr = BinaryExpression$getFirstExpr$LBinaryExpression$(expr);
			if (! (lhsExpr instanceof PropertyExpression && UnaryExpression$getExpr$LUnaryExpression$(lhsExpr) instanceof ThisExpression)) {
				return false;
			}
			propertyName = Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(lhsExpr));
			if (assigned[propertyName]) {
				return false;
			}
			assigned[propertyName] = true;
			return (function onExpr(expr) {
				if (expr instanceof ThisExpression) {
					return false;
				} else {
					if (expr instanceof FunctionExpression) {
						return false;
					}
				}
				return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			})(BinaryExpression$getSecondExpr$LBinaryExpression$(expr));
		}), ctor._statements));
	})());
};

_UnboxOptimizeCommand._newExpressionCanUnbox$L_UnboxOptimizeCommand$LExpression$ = _UnboxOptimizeCommand$_newExpressionCanUnbox$L_UnboxOptimizeCommand$LExpression$;

_UnboxOptimizeCommand.prototype._unboxVariable$LMemberFunctionDefinition$LLocalVariable$ = function (funcDef, local) {
	var $this = this;
	var variableMap;
	var createLocalExpressionFor;
	var buildConstructingStatements;
	var onStatements;
	var message$0;
	var message$0$0;
	var getNotation$this$0;
	message$0 = "unboxing " + (getNotation$this$0 = local._name, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + ""));
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this._optimizer._log += message$0$0 + "\n";
	variableMap = {};
	ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$(local._type.getClassDef$(), (function (classDef) {
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (member) {
			if ((MemberDefinition$flags$LMemberDefinition$(member) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_ABSTRACT)) === 0) {
				variableMap[MemberDefinition$name$LMemberDefinition$(member)] = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, member.getType$(), Token$getValue$LToken$(LocalVariable$getName$LLocalVariable$(local)) + "$" + MemberDefinition$name$LMemberDefinition$(member));
			}
			return true;
		}));
		return true;
	}));
	createLocalExpressionFor = (function (propertyName) {
		if (! variableMap[propertyName]) {
			throw new Error("could not find local variable for property name: " + propertyName);
		}
		return new LocalExpression(variableMap[propertyName]._name, variableMap[propertyName]);
	});
	buildConstructingStatements = (function (dstStatements, dstStatementIndex, newExpr) {
		var ctor;
		ctor = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(newExpr);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function (statement) {
			var propertyName;
			var rhsExpr;
			var onExpr;
			propertyName = Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(BinaryExpression$getFirstExpr$LBinaryExpression$(UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement))));
			rhsExpr = BinaryExpression$getSecondExpr$LBinaryExpression$(UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement)).clone$();
			onExpr = (function (expr, replaceCb) {
				var argIndex;
				if (expr instanceof LocalExpression) {
					for (argIndex = 0; argIndex < MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor).length; ++ argIndex) {
						if (LocalExpression$getLocal$LLocalExpression$(expr) == MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor)[argIndex]) {
							break;
						}
					}
					if (argIndex === MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor).length) {
						throw new Error("logic flaw, could not find the local in arguments");
					}
					replaceCb(NewExpression$getArguments$LNewExpression$(newExpr)[argIndex].clone$());
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			});
			onExpr(rhsExpr, (function (expr) {
				rhsExpr = expr;
			}));
			dstStatements.splice(dstStatementIndex++, 0, new ExpressionStatement(new AssignmentExpression(new Token$1("=", false), createLocalExpressionFor(propertyName), rhsExpr)));
			return true;
		}), ctor._statements);
		return dstStatementIndex;
	});
	onStatements = (function (statements) {
		var statementIndex;
		var onExpr;
		var newExpr;
		for (statementIndex = 0; statementIndex < statements.length; ) {
			onExpr = (function (expr, replaceCb) {
				if (expr instanceof PropertyExpression && UnaryExpression$getExpr$LUnaryExpression$(expr) instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(UnaryExpression$getExpr$LUnaryExpression$(expr)) == local) {
					replaceCb(createLocalExpressionFor(Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(expr))));
					return true;
				} else {
					if (expr instanceof FunctionExpression) {
						return onStatements(MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(FunctionExpression$getFuncDef$LFunctionExpression$(expr)));
					} else {
						if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == local) {
							throw new Error("logic flaw, unexpected pattern");
						}
					}
				}
				expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
				return true;
			});
			if (statements[statementIndex] instanceof FunctionStatement) {
				onStatements(statements[statementIndex]._funcDef._statements);
				++ statementIndex;
			} else {
				newExpr = _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$($this, statements[statementIndex], local);
				if (newExpr != null) {
					statements.splice(statementIndex, 1);
					statementIndex = buildConstructingStatements(statements, statementIndex, newExpr);
				} else {
					statements[statementIndex].forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
					statements[statementIndex].handleStatements$F$ALStatement$B$(onStatements);
					++ statementIndex;
				}
			}
		}
		return true;
	});
	onStatements(funcDef._statements);
};


function _UnboxOptimizeCommand$_unboxVariable$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$($this, funcDef, local) {
	var variableMap;
	var createLocalExpressionFor;
	var buildConstructingStatements;
	var onStatements;
	var message$0;
	var message$0$0;
	var getNotation$this$0;
	message$0 = "unboxing " + (getNotation$this$0 = local._name, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + ""));
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	$this._optimizer._log += message$0$0 + "\n";
	variableMap = {};
	ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$(local._type.getClassDef$(), (function (classDef) {
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (member) {
			if ((MemberDefinition$flags$LMemberDefinition$(member) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_ABSTRACT)) === 0) {
				variableMap[MemberDefinition$name$LMemberDefinition$(member)] = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, member.getType$(), Token$getValue$LToken$(LocalVariable$getName$LLocalVariable$(local)) + "$" + MemberDefinition$name$LMemberDefinition$(member));
			}
			return true;
		}));
		return true;
	}));
	createLocalExpressionFor = (function (propertyName) {
		if (! variableMap[propertyName]) {
			throw new Error("could not find local variable for property name: " + propertyName);
		}
		return new LocalExpression(variableMap[propertyName]._name, variableMap[propertyName]);
	});
	buildConstructingStatements = (function (dstStatements, dstStatementIndex, newExpr) {
		var ctor;
		ctor = _DetermineCalleeCommand$getCallingFuncDef$LStashable$(newExpr);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function (statement) {
			var propertyName;
			var rhsExpr;
			var onExpr;
			propertyName = Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(BinaryExpression$getFirstExpr$LBinaryExpression$(UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement))));
			rhsExpr = BinaryExpression$getSecondExpr$LBinaryExpression$(UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement)).clone$();
			onExpr = (function (expr, replaceCb) {
				var argIndex;
				if (expr instanceof LocalExpression) {
					for (argIndex = 0; argIndex < MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor).length; ++ argIndex) {
						if (LocalExpression$getLocal$LLocalExpression$(expr) == MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor)[argIndex]) {
							break;
						}
					}
					if (argIndex === MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor).length) {
						throw new Error("logic flaw, could not find the local in arguments");
					}
					replaceCb(NewExpression$getArguments$LNewExpression$(newExpr)[argIndex].clone$());
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			});
			onExpr(rhsExpr, (function (expr) {
				rhsExpr = expr;
			}));
			dstStatements.splice(dstStatementIndex++, 0, new ExpressionStatement(new AssignmentExpression(new Token$1("=", false), createLocalExpressionFor(propertyName), rhsExpr)));
			return true;
		}), ctor._statements);
		return dstStatementIndex;
	});
	onStatements = (function (statements) {
		var statementIndex;
		var onExpr;
		var newExpr;
		for (statementIndex = 0; statementIndex < statements.length; ) {
			onExpr = (function (expr, replaceCb) {
				if (expr instanceof PropertyExpression && UnaryExpression$getExpr$LUnaryExpression$(expr) instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(UnaryExpression$getExpr$LUnaryExpression$(expr)) == local) {
					replaceCb(createLocalExpressionFor(Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(expr))));
					return true;
				} else {
					if (expr instanceof FunctionExpression) {
						return onStatements(MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(FunctionExpression$getFuncDef$LFunctionExpression$(expr)));
					} else {
						if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == local) {
							throw new Error("logic flaw, unexpected pattern");
						}
					}
				}
				expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
				return true;
			});
			if (statements[statementIndex] instanceof FunctionStatement) {
				onStatements(statements[statementIndex]._funcDef._statements);
				++ statementIndex;
			} else {
				newExpr = _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$($this, statements[statementIndex], local);
				if (newExpr != null) {
					statements.splice(statementIndex, 1);
					statementIndex = buildConstructingStatements(statements, statementIndex, newExpr);
				} else {
					statements[statementIndex].forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
					statements[statementIndex].handleStatements$F$ALStatement$B$(onStatements);
					++ statementIndex;
				}
			}
		}
		return true;
	});
	onStatements(funcDef._statements);
};

_UnboxOptimizeCommand._unboxVariable$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$ = _UnboxOptimizeCommand$_unboxVariable$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$;

_UnboxOptimizeCommand.prototype._statementIsConstructingTheLocal$LStatement$LLocalVariable$ = function (statement, local) {
	var expr;
	var lhsExpr;
	var rhsExpr;
	if (! (statement instanceof ExpressionStatement)) {
		return null;
	}
	expr = statement._expr;
	if (! (expr instanceof AssignmentExpression)) {
		return null;
	}
	lhsExpr = expr._expr1;
	if (! (lhsExpr instanceof LocalExpression)) {
		return null;
	}
	if (lhsExpr._local != local) {
		return null;
	}
	rhsExpr = expr._expr2;
	return (! (rhsExpr instanceof NewExpression) ? null : rhsExpr);
};


function _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$($this, statement, local) {
	var expr;
	var lhsExpr;
	var rhsExpr;
	if (! (statement instanceof ExpressionStatement)) {
		return null;
	}
	expr = statement._expr;
	if (! (expr instanceof AssignmentExpression)) {
		return null;
	}
	lhsExpr = expr._expr1;
	if (! (lhsExpr instanceof LocalExpression)) {
		return null;
	}
	if (lhsExpr._local != local) {
		return null;
	}
	rhsExpr = expr._expr2;
	return (! (rhsExpr instanceof NewExpression) ? null : rhsExpr);
};

_UnboxOptimizeCommand._statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$ = _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$;

function _ArrayLengthOptimizeCommand() {
	this._identifier = "array-length";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_ArrayLengthOptimizeCommand], _FunctionOptimizeCommand);
_ArrayLengthOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var condExpr;
		var arrayLocal;
		statement.forEachStatement$F$LStatement$B$(onStatement);
		if (statement instanceof ForStatement) {
			condExpr = statement._condExpr;
			arrayLocal = (condExpr != null ? _ArrayLengthOptimizeCommand$_hasLengthExprOfLocalArray$L_ArrayLengthOptimizeCommand$LExpression$($this, condExpr) : null);
			if (arrayLocal != null) {
				_ArrayLengthOptimizeCommand$_optimizeArrayLength$L_ArrayLengthOptimizeCommand$LMemberFunctionDefinition$LForStatement$LLocalVariable$($this, funcDef, statement, arrayLocal);
			}
		}
		return true;
	}), funcDef._statements);
	return true;
};


_ArrayLengthOptimizeCommand.prototype._optimizeArrayLength$LMemberFunctionDefinition$LForStatement$LLocalVariable$ = function (funcDef, statement, arrayLocal) {
	var $this = this;
	var lengthLocal;
	var assignToLocal;
	var onExpr;
	var message$0;
	var message$0$0;
	var getNotation$this$0;
	var expr$0;
	if (_ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$(this, statement._condExpr) && _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$(this, statement._postExpr) && (! Util$forEachStatement$F$LStatement$B$ALStatement$((function (statement) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$($this, statement);
	}), statement._statements) ? false : true)) {
		message$0 = funcDef.getNotation$() + " optimizing " + (getNotation$this$0 = statement._token, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + ""));
		message$0$0 = "[" + this._identifier + "] " + message$0;
		this._optimizer._log += message$0$0 + "\n";
		lengthLocal = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S(this, funcDef, Type.integerType, arrayLocal._name._value + "$len");
		assignToLocal = new AssignmentExpression(new Token$0("="), new LocalExpression(new Token$1(lengthLocal._name._value, true), lengthLocal), new PropertyExpression$0(new Token$0("."), new LocalExpression(new Token$1(arrayLocal._name._value, true), arrayLocal), new Token$0("length"), [], lengthLocal._type));
		if (statement._initExpr != null) {
			expr$0 = new CommaExpression(new Token$0(","), statement._initExpr, assignToLocal);
			statement._initExpr = expr$0;
		} else {
			statement._initExpr = assignToLocal;
		}
		onExpr = (function (expr, replaceCb) {
			if (expr instanceof PropertyExpression && expr._identifierToken._value === "length" && expr._expr instanceof LocalExpression && expr._expr._local == arrayLocal) {
				replaceCb(new LocalExpression(new Token$1(lengthLocal._name._value, true), lengthLocal));
			} else {
				expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			}
			return true;
		});
		statement._condExpr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		statement._postExpr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement2(statement) {
			statement.forEachStatement$F$LStatement$B$(onStatement2);
			statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			return true;
		}), statement._statements);
	}
};


function _ArrayLengthOptimizeCommand$_optimizeArrayLength$L_ArrayLengthOptimizeCommand$LMemberFunctionDefinition$LForStatement$LLocalVariable$($this, funcDef, statement, arrayLocal) {
	var lengthLocal;
	var assignToLocal;
	var onExpr;
	var message$0;
	var message$0$0;
	var getNotation$this$0;
	var expr$0;
	if (_ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$($this, statement._condExpr) && _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$($this, statement._postExpr) && (! Util$forEachStatement$F$LStatement$B$ALStatement$((function (statement) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$($this, statement);
	}), statement._statements) ? false : true)) {
		message$0 = funcDef.getNotation$() + " optimizing " + (getNotation$this$0 = statement._token, "'" + getNotation$this$0._value + "'" + " at " + (getNotation$this$0._filename || "<<unknown>>") + ":" + (getNotation$this$0._lineNumber + ""));
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		$this._optimizer._log += message$0$0 + "\n";
		lengthLocal = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, Type.integerType, arrayLocal._name._value + "$len");
		assignToLocal = new AssignmentExpression(new Token$0("="), new LocalExpression(new Token$1(lengthLocal._name._value, true), lengthLocal), new PropertyExpression$0(new Token$0("."), new LocalExpression(new Token$1(arrayLocal._name._value, true), arrayLocal), new Token$0("length"), [], lengthLocal._type));
		if (statement._initExpr != null) {
			expr$0 = new CommaExpression(new Token$0(","), statement._initExpr, assignToLocal);
			statement._initExpr = expr$0;
		} else {
			statement._initExpr = assignToLocal;
		}
		onExpr = (function (expr, replaceCb) {
			if (expr instanceof PropertyExpression && expr._identifierToken._value === "length" && expr._expr instanceof LocalExpression && expr._expr._local == arrayLocal) {
				replaceCb(new LocalExpression(new Token$1(lengthLocal._name._value, true), lengthLocal));
			} else {
				expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			}
			return true;
		});
		statement._condExpr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		statement._postExpr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement2(statement) {
			statement.forEachStatement$F$LStatement$B$(onStatement2);
			statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			return true;
		}), statement._statements);
	}
};

_ArrayLengthOptimizeCommand._optimizeArrayLength$L_ArrayLengthOptimizeCommand$LMemberFunctionDefinition$LForStatement$LLocalVariable$ = _ArrayLengthOptimizeCommand$_optimizeArrayLength$L_ArrayLengthOptimizeCommand$LMemberFunctionDefinition$LForStatement$LLocalVariable$;

_ArrayLengthOptimizeCommand.prototype._hasLengthExprOfLocalArray$LExpression$ = function (expr) {
	var $this = this;
	var local;
	local = null;
	Expression$forEachExpression$LExpression$F$LExpression$B$(expr, (function onExpr(expr) {
		var this$0;
		var resolveIfNullable$this$0;
		if (expr instanceof PropertyExpression && expr._identifierToken._value === "length" && expr._expr instanceof LocalExpression && _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$($this, (resolveIfNullable$this$0 = expr._expr.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0))) {
			this$0 = expr._expr;
			local = this$0._local;
			return false;
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}));
	return local;
};


function _ArrayLengthOptimizeCommand$_hasLengthExprOfLocalArray$L_ArrayLengthOptimizeCommand$LExpression$($this, expr) {
	var local;
	local = null;
	Expression$forEachExpression$LExpression$F$LExpression$B$(expr, (function onExpr(expr) {
		var this$0;
		var resolveIfNullable$this$0;
		if (expr instanceof PropertyExpression && expr._identifierToken._value === "length" && expr._expr instanceof LocalExpression && _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$($this, (resolveIfNullable$this$0 = expr._expr.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0))) {
			this$0 = expr._expr;
			local = this$0._local;
			return false;
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}));
	return local;
};

_ArrayLengthOptimizeCommand._hasLengthExprOfLocalArray$L_ArrayLengthOptimizeCommand$LExpression$ = _ArrayLengthOptimizeCommand$_hasLengthExprOfLocalArray$L_ArrayLengthOptimizeCommand$LExpression$;

_ArrayLengthOptimizeCommand.prototype._lengthIsUnmodifiedInStatement$LStatement$ = function (statement) {
	var $this = this;
	return (! statement.forEachStatement$F$LStatement$B$((function (statement) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$($this, statement);
	})) ? false : Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$($this, expr);
	})));
};


function _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$($this, statement) {
	return (! statement.forEachStatement$F$LStatement$B$((function (statement) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$($this, statement);
	})) ? false : Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$($this, expr);
	})));
};

_ArrayLengthOptimizeCommand._lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$ = _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$;

_ArrayLengthOptimizeCommand.prototype._lengthIsUnmodifiedInExpr$LExpression$ = function (expr) {
	if (expr instanceof AssignmentExpression) {
		if (_ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$(this, expr._expr1)) {
			return false;
		}
	} else {
		if (expr instanceof CallExpression || expr instanceof SuperExpression) {
			return false;
		} else {
			if (expr instanceof IncrementExpression) {
				if (_ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$(this, expr._expr)) {
					return false;
				}
			}
		}
	}
	return true;
};


function _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$($this, expr) {
	if (expr instanceof AssignmentExpression) {
		if (_ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$($this, expr._expr1)) {
			return false;
		}
	} else {
		if (expr instanceof CallExpression || expr instanceof SuperExpression) {
			return false;
		} else {
			if (expr instanceof IncrementExpression) {
				if (_ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$($this, expr._expr)) {
					return false;
				}
			}
		}
	}
	return true;
};

_ArrayLengthOptimizeCommand._lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$ = _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$;

_ArrayLengthOptimizeCommand.prototype._lhsMayModifyLength$LExpression$ = function (expr) {
	var exprType;
	var this$0;
	if (expr instanceof PropertyExpression && expr._identifierToken._value === "length") {
		return true;
	}
	if (expr instanceof ArrayExpression) {
		return true;
	}
	this$0 = expr.getType$();
	exprType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	return (exprType.equals$LType$(Type.variantType) ? true : _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$(this, exprType) ? true : false);
};


function _ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$($this, expr) {
	var exprType;
	var this$0;
	if (expr instanceof PropertyExpression && expr._identifierToken._value === "length") {
		return true;
	}
	if (expr instanceof ArrayExpression) {
		return true;
	}
	this$0 = expr.getType$();
	exprType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	return (exprType.equals$LType$(Type.variantType) ? true : _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$($this, exprType) ? true : false);
};

_ArrayLengthOptimizeCommand._lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$ = _ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$;

_ArrayLengthOptimizeCommand.prototype._typeIsArray$LType$ = function (type) {
	var classDef;
	if (! (type instanceof ObjectType)) {
		return false;
	}
	classDef = type.getClassDef$();
	return (! (classDef instanceof InstantiatedClassDefinition) ? false : classDef._templateClassDef._className === "Array");
};


function _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$($this, type) {
	var classDef;
	if (! (type instanceof ObjectType)) {
		return false;
	}
	classDef = type.getClassDef$();
	return (! (classDef instanceof InstantiatedClassDefinition) ? false : classDef._templateClassDef._className === "Array");
};

_ArrayLengthOptimizeCommand._typeIsArray$L_ArrayLengthOptimizeCommand$LType$ = _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$;

function _NoDebugCommand() {
	this._identifier = "no-debug";
	this._optimizer = null;
};

$__jsx_extend([_NoDebugCommand], _OptimizeCommand);
_NoDebugCommand.prototype._createStash$ = function () {
	return new _NoDebugCommand$x2EStash();
};


_NoDebugCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var stash;
	stash = _OptimizeCommand$getStash$L_OptimizeCommand$LStashable$(this, this._optimizer._compiler._emitter);
	stash.debugValue = false;
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._optimizer._compiler, (function (parser, classDef) {
		if (classDef.className$() === "JSX") {
			ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (memberVariable) {
				var falseExpr;
				if (MemberDefinition$name$LMemberDefinition$(memberVariable) === "DEBUG" && (MemberDefinition$flags$LMemberDefinition$(memberVariable) & ClassDefinition.IS_STATIC) !== 0) {
					_OptimizeCommand$log$L_OptimizeCommand$S($this, "set JSX.DEBUG = " + (stash.debugValue + ""));
					falseExpr = new BooleanLiteralExpression(new Token$1(stash.debugValue + "", true));
					MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$(memberVariable, falseExpr);
					return false;
				}
				return true;
			}));
			return false;
		}
		return true;
	}));
};


function _Util$0() {
};

$__jsx_extend([_Util$0], Object);
function _Util$0$getOutputClassName$LClassDefinition$(classDef) {
	var stash;
	stash = classDef.getStash$S("emitter.outputname");
	return stash.outputName;
};

_Util$0.getOutputClassName$LClassDefinition$ = _Util$0$getOutputClassName$LClassDefinition$;

function _Util$0$getOutputConstructorName$LMemberFunctionDefinition$(ctor) {
	var stash;
	if ((ctor._classDef.flags$() & 16) !== 0) {
		return _Util$0$getNameOfNativeConstructor$LClassDefinition$(ctor._classDef);
	}
	stash = ctor.getStash$S("emitter.outputname");
	return stash.outputName;
};

_Util$0.getOutputConstructorName$LMemberFunctionDefinition$ = _Util$0$getOutputConstructorName$LMemberFunctionDefinition$;

function _Util$0$getOutputConstructorName$LClassDefinition$ALType$(classDef, argTypes) {
	var ctor;
	ctor = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, "constructor", argTypes, false);
	return _Util$0$getOutputConstructorName$LMemberFunctionDefinition$(ctor);
};

_Util$0.getOutputConstructorName$LClassDefinition$ALType$ = _Util$0$getOutputConstructorName$LClassDefinition$ALType$;

function _Util$0$getNameOfNativeConstructor$LClassDefinition$(classDef) {
	return (classDef._nativeSource != null || classDef._outerClassDef != null ? _Util$0$getOutputClassName$LClassDefinition$(classDef) : classDef instanceof InstantiatedClassDefinition ? classDef._templateClassDef._nativeSource != null ? _Util$0$getOutputClassName$LClassDefinition$(classDef._templateClassDef) : classDef._templateClassDef._className === "Map" ? "Object" : classDef._templateClassDef._className : classDef.className$());
};

_Util$0.getNameOfNativeConstructor$LClassDefinition$ = _Util$0$getNameOfNativeConstructor$LClassDefinition$;

function _Util$0$setOutputClassNames$ALClassDefinition$(classDefs) {
	var setOutputName;
	var escapeClassName;
	var countByName;
	var newUniqueName;
	var i;
	var classDef;
	var className;
	var ctors;
	var j;
	var exportedCtor;
	var n;
	var instantiated;
	var classFullName$this$0$0;
	function setOutputName(stashable, name) {
		stashable.setStash$SLStash$("emitter.outputname", new _Util$x2EOutputNameStash(name));
	}
	function escapeClassName(name) {
		return name.replace(/[^A-Za-z0-9_\$]/g, (function (matched) {
			return "$x" + matched.charCodeAt(0).toString(16).toUpperCase();
		}));
	}
	countByName = {};
	function newUniqueName(className) {
		var name;
		if (countByName[className]) {
			name = className + "$" + (countByName[className] - 1 + "");
			++ countByName[className];
		} else {
			name = className;
			countByName[className] = 1;
		}
		return escapeClassName(name);
	}
	for (i = 0; i < classDefs.length; ++ i) {
		classDef = classDefs[i];
		if ((classDef.flags$() & 16) !== 0) {
			className = classDef.className$();
			if (! $__jsx_ObjectHasOwnProperty.call(countByName, className)) {
				setOutputName(classDef, escapeClassName(className));
				countByName[className] = 1;
			}
		}
	}
	for (i = 0; i < classDefs.length; ++ i) {
		classDef = classDefs[i];
		if ((classDef.flags$() & 16) === 0) {
			className = (classDef._outerClassDef != null ? (classFullName$this$0$0 = classDef._outerClassDef, classFullName$this$0$0._outerClassDef != null ? ClassDefinition$classFullName$LClassDefinition$(classFullName$this$0$0._outerClassDef) + "." + classFullName$this$0$0._className : classFullName$this$0$0.className$()) + "." + classDef._className : classDef.className$());
			ctors = _Util$0$findFunctions$LClassDefinition$SB(classDef, "constructor", false);
			if (ctors.length !== 0) {
				for (j = 0; j < ctors.length; ++ j) {
					if ((ctors[j]._flags & 16384) !== 0) {
						exportedCtor = ctors[j];
						ctors.splice(j, 1);
						ctors.unshift(exportedCtor);
						break;
					}
				}
				n = newUniqueName(className);
				setOutputName(classDef, n);
				setOutputName(ctors[0], n);
				for (j = 1; j < ctors.length; ++ j) {
					setOutputName(ctors[j], newUniqueName(className));
				}
			} else {
				setOutputName(classDef, newUniqueName(className));
			}
		} else {
			if (classDef._outerClassDef != null) {
				className = _Util$0$getOutputClassName$LClassDefinition$(classDef._outerClassDef) + "." + classDef.className$();
				setOutputName(classDef, className);
			} else {
				if (classDef._nativeSource != null) {
					setOutputName(classDef, newUniqueName(ClassDefinition$classFullName$LClassDefinition$(classDef)));
				} else {
					if (classDef instanceof InstantiatedClassDefinition) {
						instantiated = classDef;
						className = instantiated._templateClassDef._className + newUniqueName(".<" + instantiated._typeArguments.map((function (type) {
							return type.toString();
						})).join(",") + ">");
						setOutputName(classDef, escapeClassName(className));
					} else {
						setOutputName(classDef, escapeClassName(ClassDefinition$classFullName$LClassDefinition$(classDef)));
					}
				}
			}
		}
	}
};

_Util$0.setOutputClassNames$ALClassDefinition$ = _Util$0$setOutputClassNames$ALClassDefinition$;

function _Util$0$encodeObjectLiteralKey$S(s) {
	return (s.length === 0 || s.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/) ? s : Util$encodeStringLiteral$S(s));
};

_Util$0.encodeObjectLiteralKey$S = _Util$0$encodeObjectLiteralKey$S;

function _Util$0$findFunctions$LClassDefinition$SB(classDef, name, isStatic) {
	var functions;
	var members;
	var i;
	var member;
	functions = [];
	members = classDef._members;
	for (i = 0; i < members.length; ++ i) {
		member = members[i];
		if (member instanceof MemberFunctionDefinition && member._nameToken._value === name && (member._flags & 8) === (isStatic ? 8 : 0)) {
			functions.push(member);
		}
	}
	return functions;
};

_Util$0.findFunctions$LClassDefinition$SB = _Util$0$findFunctions$LClassDefinition$SB;

function _Mangler() {
};

$__jsx_extend([_Mangler], Object);
function _Mangler$mangleFunctionName$L_Mangler$SALType$($this, name, argTypes) {
	return name + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this, argTypes);
};

_Mangler.mangleFunctionName$L_Mangler$SALType$ = _Mangler$mangleFunctionName$L_Mangler$SALType$;

function _Mangler$mangleTypeName$L_Mangler$LType$($this, type) {
	var classDef;
	var typeArgs;
	if (type.equals$LType$(Type.voidType)) {
		return "V";
	} else {
		if (type.equals$LType$(Type.booleanType)) {
			return "B";
		} else {
			if (type.equals$LType$(Type.integerType)) {
				return "I";
			} else {
				if (type.equals$LType$(Type.numberType)) {
					return "N";
				} else {
					if (type.equals$LType$(Type.stringType)) {
						return "S";
					} else {
						if (type instanceof ObjectType) {
							classDef = type.getClassDef$();
							if (classDef instanceof InstantiatedClassDefinition) {
								typeArgs = classDef._typeArguments;
								switch (classDef._templateClassDef._className) {
								case "Array":
									return "A" + _Mangler$mangleTypeName$L_Mangler$LType$($this, typeArgs[0]);
								case "Map":
									return "H" + _Mangler$mangleTypeName$L_Mangler$LType$($this, typeArgs[0]);
								default:
								}
							}
							return "L" + _Util$0$getOutputClassName$LClassDefinition$(type.getClassDef$()).replace(/\./g, (function (c) {
								return "$x" + c.charCodeAt(0).toString(16).toUpperCase();
							})) + "$";
						} else {
							if (type instanceof StaticFunctionType) {
								return "F" + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this, type._argTypes) + _Mangler$mangleTypeName$L_Mangler$LType$($this, type._returnType) + "$";
							} else {
								if (type instanceof MemberFunctionType) {
									return "M" + _Mangler$mangleTypeName$L_Mangler$LType$($this, type._objectType) + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this, type._argTypes) + _Mangler$mangleTypeName$L_Mangler$LType$($this, type._returnType) + "$";
								} else {
									if (type instanceof NullableType) {
										return "U" + _Mangler$mangleTypeName$L_Mangler$LType$($this, type._baseType);
									} else {
										if (type.equals$LType$(Type.variantType)) {
											return "X";
										} else {
											throw new Error("FIXME " + type.toString());
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};

_Mangler.mangleTypeName$L_Mangler$LType$ = _Mangler$mangleTypeName$L_Mangler$LType$;

function _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this, argTypes) {
	var s;
	var i;
	var argTypes$len$0;
	s = "$";
	for ((i = 0, argTypes$len$0 = argTypes.length); i < argTypes$len$0; ++ i) {
		s += _Mangler$mangleTypeName$L_Mangler$LType$($this, argTypes[i]);
	}
	return s;
};

_Mangler.mangleFunctionArguments$L_Mangler$ALType$ = _Mangler$mangleFunctionArguments$L_Mangler$ALType$;

function _Mangler$requiresMangling$L_Mangler$LClassDefinition$SALType$B($this, classDef, name, argTypes, isStatic) {
	return ! Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic);
};

_Mangler.requiresMangling$L_Mangler$LClassDefinition$SALType$B = _Mangler$requiresMangling$L_Mangler$LClassDefinition$SALType$B;

function _Mangler$requiresMangling$L_Mangler$LPropertyExpression$($this, expr) {
	return (! Util$isReferringToFunctionDefinition$LPropertyExpression$(expr) ? false : ! Util$propertyRootIsNative$LPropertyExpression$(expr));
};

_Mangler.requiresMangling$L_Mangler$LPropertyExpression$ = _Mangler$requiresMangling$L_Mangler$LPropertyExpression$;

function _Mangler$requiresMangling$L_Mangler$LMemberFunctionDefinition$($this, member) {
	var classDef$0;
	var name$0;
	var argTypes$0;
	var isStatic$0;
	classDef$0 = member._classDef;
	name$0 = member._nameToken._value;
	argTypes$0 = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member);
	isStatic$0 = (member._flags & 8) !== 0;
	return ! Util$memberRootIsNative$LClassDefinition$SALType$B(classDef$0, name$0, argTypes$0, isStatic$0);
};

_Mangler.requiresMangling$L_Mangler$LMemberFunctionDefinition$ = _Mangler$requiresMangling$L_Mangler$LMemberFunctionDefinition$;

function _Namer() {
	this._emitter = null;
	this._catchLevel = -1;
};

$__jsx_extend([_Namer], Object);
_Namer.prototype.setup$LJavaScriptEmitter$ = function (emitter) {
	this._emitter = emitter;
	return this;
};


function _Namer$setup$L_Namer$LJavaScriptEmitter$($this, emitter) {
	$this._emitter = emitter;
	return $this;
};

_Namer.setup$L_Namer$LJavaScriptEmitter$ = _Namer$setup$L_Namer$LJavaScriptEmitter$;

_Namer.prototype.getNameOfProperty$LClassDefinition$S = function (classDef, name) {
	return name;
};


_Namer.prototype.getNameOfMethod$LClassDefinition$SALType$ = function (classDef, name, argTypes) {
	return (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, false) ? name : name + _Mangler$mangleFunctionArguments$L_Mangler$ALType$(this._emitter._mangler, argTypes));
};


_Namer.prototype.getNameOfStaticVariable$LClassDefinition$S = function (classDef, name) {
	return name;
};


_Namer.prototype.getNameOfStaticFunction$LClassDefinition$SALType$ = function (classDef, name, argTypes) {
	var className;
	var stash$0;
	stash$0 = classDef.getStash$S("emitter.outputname");
	className = stash$0.outputName;
	return (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, true) ? className + "." + name : className + "$" + (name + _Mangler$mangleFunctionArguments$L_Mangler$ALType$(this._emitter._mangler, argTypes)));
};


_Namer.prototype.getNameOfConstructor$LClassDefinition$ALType$ = function (classDef, argTypes) {
	var ctor$0;
	ctor$0 = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, "constructor", argTypes, false);
	return _Util$0$getOutputConstructorName$LMemberFunctionDefinition$(ctor$0);
};


_Namer.prototype.getNameOfClass$LClassDefinition$ = function (classDef) {
	var stash$0;
	stash$0 = classDef.getStash$S("emitter.outputname");
	return stash$0.outputName;
};


_Namer.prototype.enterScope$LLocalVariable$F$V$ = function (local, cb) {
	cb();
};


_Namer.prototype.enterFunction$LMemberFunctionDefinition$F$V$ = function (funcDef, cb) {
	cb();
};


_Namer.prototype.enterCatch$LTryStatement$F$F$S$V$ = function (tryStmt, cb) {
	++ this._catchLevel;
	_Namer$_enterCatch$L_Namer$LTryStatement$F$F$S$V$S(this, tryStmt, cb, "$__jsx_catch_" + (this._catchLevel + ""));
	-- this._catchLevel;
};


function _Namer$enterCatch$L_Namer$LTryStatement$F$F$S$V$($this, tryStmt, cb) {
	++ $this._catchLevel;
	_Namer$_enterCatch$L_Namer$LTryStatement$F$F$S$V$S($this, tryStmt, cb, "$__jsx_catch_" + ($this._catchLevel + ""));
	-- $this._catchLevel;
};

_Namer.enterCatch$L_Namer$LTryStatement$F$F$S$V$ = _Namer$enterCatch$L_Namer$LTryStatement$F$F$S$V$;

_Namer.prototype._enterCatch$LTryStatement$F$F$S$V$S = function (tryStmt, cb, catchName) {
	var $this = this;
	var catchStmts;
	var i;
	tryStmt.setStash$SLStash$("namer", new _Namer$x2E_TryStash(catchName));
	catchStmts = tryStmt._catchStatements;
	for (i in catchStmts) {
		catchStmts[i]._local.setStash$SLStash$("namer", new _Namer$x2E_CatchTargetStash(tryStmt));
	}
	cb((function () {
		return tryStmt.getStash$S("namer").catchName;
	}));
};


function _Namer$_enterCatch$L_Namer$LTryStatement$F$F$S$V$S($this, tryStmt, cb, catchName) {
	var catchStmts;
	var i;
	tryStmt.setStash$SLStash$("namer", new _Namer$x2E_TryStash(catchName));
	catchStmts = tryStmt._catchStatements;
	for (i in catchStmts) {
		catchStmts[i]._local.setStash$SLStash$("namer", new _Namer$x2E_CatchTargetStash(tryStmt));
	}
	cb((function () {
		return tryStmt.getStash$S("namer").catchName;
	}));
};

_Namer._enterCatch$L_Namer$LTryStatement$F$F$S$V$S = _Namer$_enterCatch$L_Namer$LTryStatement$F$F$S$V$S;

_Namer.prototype.getNameOfLocalVariable$LLocalVariable$ = function (local) {
	return (local instanceof CaughtVariable ? _Namer$_getCatchName$L_Namer$LCaughtVariable$(this, local) : local._name._value);
};


_Namer.prototype._getCatchName$LCaughtVariable$ = function (caught) {
	var tryStmt$0;
	tryStmt$0 = caught.getStash$S("namer").tryStmt;
	return tryStmt$0.getStash$S("namer").catchName;
};


function _Namer$_getCatchName$L_Namer$LCaughtVariable$($this, caught) {
	var tryStmt$0;
	tryStmt$0 = caught.getStash$S("namer").tryStmt;
	return tryStmt$0.getStash$S("namer").catchName;
};

_Namer._getCatchName$L_Namer$LCaughtVariable$ = _Namer$_getCatchName$L_Namer$LCaughtVariable$;

_Namer.prototype._getCatchName$LTryStatement$ = function (tryStmt) {
	return tryStmt.getStash$S("namer").catchName;
};


function _Namer$_getCatchName$L_Namer$LTryStatement$($this, tryStmt) {
	return tryStmt.getStash$S("namer").catchName;
};

_Namer._getCatchName$L_Namer$LTryStatement$ = _Namer$_getCatchName$L_Namer$LTryStatement$;

function _MinifiedNameGenerator(skipWords) {
	var i;
	this._skipWords = {};
	this._memo = [];
	this._counter = 0;
	for (i in skipWords) {
		this._skipWords[skipWords[i]] = true;
	}
};

$__jsx_extend([_MinifiedNameGenerator], Object);
_MinifiedNameGenerator.prototype.get$N = function (n) {
	var candidate;
	while (this._memo.length <= n) {
		do {
			candidate = _MinifiedNameGenerator$_stringify$N(this._counter++);
		} while ($__jsx_ObjectHasOwnProperty.call(this._skipWords, candidate) || candidate.match(/^[0-9$]/));
		this._memo.push(candidate);
	}
	return this._memo[n];
};


function _MinifiedNameGenerator$get$L_MinifiedNameGenerator$N($this, n) {
	var candidate;
	while ($this._memo.length <= n) {
		do {
			candidate = _MinifiedNameGenerator$_stringify$N($this._counter++);
		} while ($__jsx_ObjectHasOwnProperty.call($this._skipWords, candidate) || candidate.match(/^[0-9$]/));
		$this._memo.push(candidate);
	}
	return $this._memo[n];
};

_MinifiedNameGenerator.get$L_MinifiedNameGenerator$N = _MinifiedNameGenerator$get$L_MinifiedNameGenerator$N;

function _MinifiedNameGenerator$_stringify$N(n) {
	var name;
	var colIndex;
	name = "";
	do {
		colIndex = n % 64;
		name += "$_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(colIndex);
		n = (n - colIndex) / 64;
	} while (n !== 0);
	return name;
};

_MinifiedNameGenerator._stringify$N = _MinifiedNameGenerator$_stringify$N;

function _Minifier(emitter, classDefs) {
	this._propertyUseCount = {};
	this._propertyConversionTable = null;
	this._globalUseCount = {};
	this._globalConversionTable = null;
	this._outerLocals = [];
	this._emitter = emitter;
	this._classDefs = classDefs;
};

$__jsx_extend([_Minifier], Object);
_Minifier.prototype.getCountingNamer$ = function () {
	return _Minifier$x2E_MinifyingNamer$setup$L_Minifier$x2E_MinifyingNamer$L_Minifier$(new _Minifier$x2E_MinifyingNamer(), this);
};


function _Minifier$getCountingNamer$L_Minifier$($this) {
	return _Minifier$x2E_MinifyingNamer$setup$L_Minifier$x2E_MinifyingNamer$L_Minifier$(new _Minifier$x2E_MinifyingNamer(), $this);
};

_Minifier.getCountingNamer$L_Minifier$ = _Minifier$getCountingNamer$L_Minifier$;

_Minifier.prototype.getMinifyingNamer$ = function () {
	_Minifier$_minifyProperties$L_Minifier$(this);
	_Minifier$_minifyStaticVariables$L_Minifier$(this);
	_Minifier$_minifyGlobals$L_Minifier$(this);
	return _Minifier$x2E_MinifyingNamer$setup$L_Minifier$x2E_MinifyingNamer$L_Minifier$(new _Minifier$x2E_MinifyingNamer(), this);
};


function _Minifier$getMinifyingNamer$L_Minifier$($this) {
	_Minifier$_minifyProperties$L_Minifier$($this);
	_Minifier$_minifyStaticVariables$L_Minifier$($this);
	_Minifier$_minifyGlobals$L_Minifier$($this);
	return _Minifier$x2E_MinifyingNamer$setup$L_Minifier$x2E_MinifyingNamer$L_Minifier$(new _Minifier$x2E_MinifyingNamer(), $this);
};

_Minifier.getMinifyingNamer$L_Minifier$ = _Minifier$getMinifyingNamer$L_Minifier$;

_Minifier.prototype._isCounting$ = function () {
	return this._propertyConversionTable == null;
};


function _Minifier$_isCounting$L_Minifier$($this) {
	return $this._propertyConversionTable == null;
};

_Minifier._isCounting$L_Minifier$ = _Minifier$_isCounting$L_Minifier$;

_Minifier.prototype._recordUsedIdentifiers$LStashable$F$V$ = function (stashable, cb) {
	var globalUseCountBackup;
	var k;
	var outerLocalUseCount;
	var i;
	var scopeStash;
	globalUseCountBackup = {};
	for (k in this._globalUseCount) {
		globalUseCountBackup[k] = this._globalUseCount[k];
	}
	outerLocalUseCount = [];
	for (i in this._outerLocals) {
		outerLocalUseCount[i] = _Minifier$_getLocalStash$LLocalVariable$(this._outerLocals[i]).useCount;
	}
	cb();
	scopeStash = _Minifier$_getScopeStash$LStashable$(stashable);
	for (k in this._globalUseCount) {
		if (this._globalUseCount[k] !== globalUseCountBackup[k]) {
			scopeStash.usedGlobals[k] = true;
		}
	}
	for (i in this._outerLocals) {
		if (outerLocalUseCount[i] !== _Minifier$_getLocalStash$LLocalVariable$(this._outerLocals[i]).useCount) {
			scopeStash.usedOuterLocals.push(this._outerLocals[i]);
		}
	}
};


function _Minifier$_recordUsedIdentifiers$L_Minifier$LStashable$F$V$($this, stashable, cb) {
	var globalUseCountBackup;
	var k;
	var outerLocalUseCount;
	var i;
	var scopeStash;
	globalUseCountBackup = {};
	for (k in $this._globalUseCount) {
		globalUseCountBackup[k] = $this._globalUseCount[k];
	}
	outerLocalUseCount = [];
	for (i in $this._outerLocals) {
		outerLocalUseCount[i] = _Minifier$_getLocalStash$LLocalVariable$($this._outerLocals[i]).useCount;
	}
	cb();
	scopeStash = _Minifier$_getScopeStash$LStashable$(stashable);
	for (k in $this._globalUseCount) {
		if ($this._globalUseCount[k] !== globalUseCountBackup[k]) {
			scopeStash.usedGlobals[k] = true;
		}
	}
	for (i in $this._outerLocals) {
		if (outerLocalUseCount[i] !== _Minifier$_getLocalStash$LLocalVariable$($this._outerLocals[i]).useCount) {
			scopeStash.usedOuterLocals.push($this._outerLocals[i]);
		}
	}
};

_Minifier._recordUsedIdentifiers$L_Minifier$LStashable$F$V$ = _Minifier$_recordUsedIdentifiers$L_Minifier$LStashable$F$V$;

_Minifier.prototype._minifyProperties$ = function () {
	var $this = this;
	var k;
	this._propertyConversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(this._propertyUseCount, new _MinifiedNameGenerator(Object.keys(Util._ecma262reserved).concat((function () {
		var nativePropertyNames;
		var this$0;
		var i$0;
		nativePropertyNames = {};
		this$0 = $this._classDefs;
		for (i$0 in this$0) {
			(function (classDef) {
				ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
					if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_STATIC) === 0 && ((MemberDefinition$flags$LMemberDefinition$(member) | classDef.flags$()) & ClassDefinition.IS_NATIVE) !== 0) {
						nativePropertyNames[MemberDefinition$name$LMemberDefinition$(member)] = true;
					}
					return true;
				}));
			})(this$0[i$0]);
		}
		return Object.keys(nativePropertyNames);
	})())));
	for (k in this._propertyConversionTable) {
	}
};


function _Minifier$_minifyProperties$L_Minifier$($this) {
	var k;
	$this._propertyConversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$($this._propertyUseCount, new _MinifiedNameGenerator(Object.keys(Util._ecma262reserved).concat((function () {
		var nativePropertyNames;
		var this$0;
		var i$0;
		nativePropertyNames = {};
		this$0 = $this._classDefs;
		for (i$0 in this$0) {
			(function (classDef) {
				ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
					if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_STATIC) === 0 && ((MemberDefinition$flags$LMemberDefinition$(member) | classDef.flags$()) & ClassDefinition.IS_NATIVE) !== 0) {
						nativePropertyNames[MemberDefinition$name$LMemberDefinition$(member)] = true;
					}
					return true;
				}));
			})(this$0[i$0]);
		}
		return Object.keys(nativePropertyNames);
	})())));
	for (k in $this._propertyConversionTable) {
	}
};

_Minifier._minifyProperties$L_Minifier$ = _Minifier$_minifyProperties$L_Minifier$;

_Minifier.prototype._minifyStaticVariables$ = function () {
	var $this = this;
	var this$0;
	var i$0;
	this$0 = this._classDefs;
	for (i$0 in this$0) {
		(function (classDef) {
			var exportedStaticVarNames;
			var stash;
			if ((classDef.flags$() & 272) === 0) {
				exportedStaticVarNames = [];
				ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (member) {
					if ((MemberDefinition$flags$LMemberDefinition$(member) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_EXPORT)) === (ClassDefinition.IS_STATIC | ClassDefinition.IS_EXPORT)) {
						exportedStaticVarNames.push(MemberDefinition$name$LMemberDefinition$(member));
					}
					return true;
				}));
				stash = _Minifier$_getClassStash$LClassDefinition$(classDef);
				stash.staticVariableConversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(stash.staticVariableUseCount, new _MinifiedNameGenerator(Object.keys(Util._ecma262reserved).concat(exportedStaticVarNames)));
			}
		})(this$0[i$0]);
	}
};


function _Minifier$_minifyStaticVariables$L_Minifier$($this) {
	var this$0;
	var i$0;
	this$0 = $this._classDefs;
	for (i$0 in this$0) {
		(function (classDef) {
			var exportedStaticVarNames;
			var stash;
			if ((classDef.flags$() & 272) === 0) {
				exportedStaticVarNames = [];
				ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (member) {
					if ((MemberDefinition$flags$LMemberDefinition$(member) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_EXPORT)) === (ClassDefinition.IS_STATIC | ClassDefinition.IS_EXPORT)) {
						exportedStaticVarNames.push(MemberDefinition$name$LMemberDefinition$(member));
					}
					return true;
				}));
				stash = _Minifier$_getClassStash$LClassDefinition$(classDef);
				stash.staticVariableConversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(stash.staticVariableUseCount, new _MinifiedNameGenerator(Object.keys(Util._ecma262reserved).concat(exportedStaticVarNames)));
			}
		})(this$0[i$0]);
	}
};

_Minifier._minifyStaticVariables$L_Minifier$ = _Minifier$_minifyStaticVariables$L_Minifier$;

_Minifier.prototype._minifyGlobals$ = function () {
	var $this = this;
	var useCount;
	var k;
	var this$0;
	var i$0;
	useCount = {};
	for (k in this._globalUseCount) {
		useCount[k] = this._globalUseCount[k];
	}
	this$0 = this._classDefs;
	for (i$0 in this$0) {
		(function (classDef) {
			if ((classDef.flags$() & 272) !== 0) {
				delete useCount[classDef.className$()];
			}
		})(this$0[i$0]);
	}
	this._globalConversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(useCount, new _MinifiedNameGenerator(Object.keys(Util._ecma262reserved).concat(_MinifiedNameGenerator.GLOBALS, (function () {
		var nativeClassNames;
		var this$0;
		var i$0;
		nativeClassNames = [];
		this$0 = $this._classDefs;
		for (i$0 in this$0) {
			(function (classDef) {
				if ((classDef.flags$() & ClassDefinition.IS_NATIVE) !== 0) {
					nativeClassNames.push(classDef.className$());
				}
			})(this$0[i$0]);
		}
		return nativeClassNames;
	})())));
	for (k in this._globalConversionTable) {
	}
};


function _Minifier$_minifyGlobals$L_Minifier$($this) {
	var useCount;
	var k;
	var this$0;
	var i$0;
	useCount = {};
	for (k in $this._globalUseCount) {
		useCount[k] = $this._globalUseCount[k];
	}
	this$0 = $this._classDefs;
	for (i$0 in this$0) {
		(function (classDef) {
			if ((classDef.flags$() & 272) !== 0) {
				delete useCount[classDef.className$()];
			}
		})(this$0[i$0]);
	}
	$this._globalConversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(useCount, new _MinifiedNameGenerator(Object.keys(Util._ecma262reserved).concat(_MinifiedNameGenerator.GLOBALS, (function () {
		var nativeClassNames;
		var this$0;
		var i$0;
		nativeClassNames = [];
		this$0 = $this._classDefs;
		for (i$0 in this$0) {
			(function (classDef) {
				if ((classDef.flags$() & ClassDefinition.IS_NATIVE) !== 0) {
					nativeClassNames.push(classDef.className$());
				}
			})(this$0[i$0]);
		}
		return nativeClassNames;
	})())));
	for (k in $this._globalConversionTable) {
	}
};

_Minifier._minifyGlobals$L_Minifier$ = _Minifier$_minifyGlobals$L_Minifier$;

_Minifier.prototype._log$S = function (message) {
};


function _Minifier$_log$L_Minifier$S($this, message) {
};

_Minifier._log$L_Minifier$S = _Minifier$_log$L_Minifier$S;

_Minifier.prototype._buildConversionTable$ALLocalVariable$L_Minifier$x2E_ScopeStash$ = function (locals, scopeStash) {
	var $this = this;
	var useCount;
	var reserved;
	var k;
	var i;
	var conversionTable;
	var i$0;
	var i$1;
	var local$0;
	var local$1;
	useCount = {};
	for (i$0 in locals) {
		local$0 = locals[i$0];
		useCount[local$0._name._value] = _Minifier$_getLocalStash$LLocalVariable$(local$0).useCount;
	}
	reserved = [  ];
	for (k in scopeStash.usedGlobals) {
		reserved.push($__jsx_ObjectHasOwnProperty.call(this._globalConversionTable, k) ? this._globalConversionTable[k] : k);
	}
	for (i in scopeStash.usedOuterLocals) {
		reserved.push(_Minifier$_getLocalStash$LLocalVariable$(scopeStash.usedOuterLocals[i]).minifiedName);
	}
	"local minification, preserving: " + reserved.join(",");
	reserved = reserved.concat(Object.keys(Util._ecma262reserved));
	conversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(useCount, new _MinifiedNameGenerator(reserved));
	for (i$1 in locals) {
		local$1 = locals[i$1];
		_Minifier$_getLocalStash$LLocalVariable$(local$1).minifiedName = conversionTable[local$1._name._value];
	}
};


function _Minifier$_buildConversionTable$L_Minifier$ALLocalVariable$L_Minifier$x2E_ScopeStash$($this, locals, scopeStash) {
	var useCount;
	var reserved;
	var k;
	var i;
	var conversionTable;
	var i$0;
	var i$1;
	var local$0;
	var local$1;
	useCount = {};
	for (i$0 in locals) {
		local$0 = locals[i$0];
		useCount[local$0._name._value] = _Minifier$_getLocalStash$LLocalVariable$(local$0).useCount;
	}
	reserved = [  ];
	for (k in scopeStash.usedGlobals) {
		reserved.push($__jsx_ObjectHasOwnProperty.call($this._globalConversionTable, k) ? $this._globalConversionTable[k] : k);
	}
	for (i in scopeStash.usedOuterLocals) {
		reserved.push(_Minifier$_getLocalStash$LLocalVariable$(scopeStash.usedOuterLocals[i]).minifiedName);
	}
	"local minification, preserving: " + reserved.join(",");
	reserved = reserved.concat(Object.keys(Util._ecma262reserved));
	conversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(useCount, new _MinifiedNameGenerator(reserved));
	for (i$1 in locals) {
		local$1 = locals[i$1];
		_Minifier$_getLocalStash$LLocalVariable$(local$1).minifiedName = conversionTable[local$1._name._value];
	}
};

_Minifier._buildConversionTable$L_Minifier$ALLocalVariable$L_Minifier$x2E_ScopeStash$ = _Minifier$_buildConversionTable$L_Minifier$ALLocalVariable$L_Minifier$x2E_ScopeStash$;

function _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(useCount, nameGenerator) {
	var propertyNames;
	var conversionTable;
	var i;
	propertyNames = Object.keys(useCount).sort((function (x, y) {
		var delta;
		delta = useCount[y] - useCount[x];
		return (delta !== 0 ? delta : x < y ? -1 : 1);
	}));
	conversionTable = {};
	for (i = 0; i < propertyNames.length; ++ i) {
		conversionTable[propertyNames[i]] = _MinifiedNameGenerator$get$L_MinifiedNameGenerator$N(nameGenerator, i);
	}
	return conversionTable;
};

_Minifier._buildConversionTable$HNL_MinifiedNameGenerator$ = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$;

function _Minifier$_getClassStash$LClassDefinition$(classDef) {
	var stash;
	stash = classDef.getStash$S("minifier.class");
	if (stash == null) {
		stash = classDef.setStash$SLStash$("minifier.class", new _Minifier$x2E_ClassStash());
	}
	return stash;
};

_Minifier._getClassStash$LClassDefinition$ = _Minifier$_getClassStash$LClassDefinition$;

function _Minifier$_getScopeStash$LStashable$(stashable) {
	var stash;
	stash = stashable.getStash$S("minifier.scope");
	if (stash == null) {
		stash = stashable.setStash$SLStash$("minifier.scope", new _Minifier$x2E_ScopeStash());
	}
	return stash;
};

_Minifier._getScopeStash$LStashable$ = _Minifier$_getScopeStash$LStashable$;

function _Minifier$_getLocalStash$LLocalVariable$(local) {
	var stash;
	stash = local.getStash$S("minifier.local");
	if (stash == null) {
		stash = local.setStash$SLStash$("minifier.local", new _Minifier$x2E_LocalStash());
	}
	return stash;
};

_Minifier._getLocalStash$LLocalVariable$ = _Minifier$_getLocalStash$LLocalVariable$;

function _Minifier$_incr$HNS(useCount, name) {
	if ($__jsx_ObjectHasOwnProperty.call(useCount, name)) {
		++ useCount[name];
	} else {
		useCount[name] = 1;
	}
};

_Minifier._incr$HNS = _Minifier$_incr$HNS;

function _Minifier$_getArgsAndLocals$LMemberFunctionDefinition$(funcDef) {
	var list;
	var this$0;
	var i$0;
	var a$0;
	list = [];
	this$0 = funcDef._args;
	for (i$0 in this$0) {
		a$0 = this$0[i$0];
		list.push(a$0);
	}
	return list.concat(funcDef._locals);
};

_Minifier._getArgsAndLocals$LMemberFunctionDefinition$ = _Minifier$_getArgsAndLocals$LMemberFunctionDefinition$;

function _Minifier$minifyJavaScript$S(src) {
	var ast;
	ast = esprima$0.parse(src);
	ast = esmangle$0.mangle(ast, ({ destructive: true }));
	return escodegen$0.generate(ast, ({ format: ({ renumber: true, hexadecimal: true, escapeless: true, compact: true, semicolons: false, parentheses: false }), directive: true }));
};

_Minifier.minifyJavaScript$S = _Minifier$minifyJavaScript$S;

var esprima$0 = require('esprima');
var esmangle$0 = require('esmangle');
var escodegen$0 = require('escodegen');
function _StatementEmitter(emitter) {
	this._emitter = emitter;
};

$__jsx_extend([_StatementEmitter], Object);
_StatementEmitter.prototype.emitLabelOfStatement$LLabellableStatement$ = function (statement) {
	var label;
	label = statement._label;
	if (label != null) {
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$(this._emitter);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, label._value + ":\n", label);
		++ this._emitter._indent;
	}
};


function _StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$($this, statement) {
	var label;
	label = statement._label;
	if (label != null) {
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this._emitter);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, label._value + ":\n", label);
		++ $this._emitter._indent;
	}
};

_StatementEmitter.emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$ = _StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$;

function _ConstructorInvocationStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ConstructorInvocationStatementEmitter], _StatementEmitter);
_ConstructorInvocationStatementEmitter.prototype.emit$ = function () {
	var ctorType;
	var argTypes;
	var ctorName;
	var token;
	var _statement$0;
	ctorType = this._statement._ctorFunctionType;
	argTypes = (ctorType != null ? ctorType._argTypes : []);
	ctorName = this._emitter._namer.getNameOfConstructor$LClassDefinition$ALType$(this._statement._ctorClassType.getClassDef$(), argTypes);
	token = (_statement$0 = this._statement)._token;
	if (ctorName === "Error" && _statement$0._args.length === 1) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "Error.call(this);\n", token);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "this.message = ", token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._statement._args[0]).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", token);
	} else {
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, token, ctorName + ".call(this", this._statement._args, argTypes);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", token);
	}
};


function _ExpressionStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ExpressionStatementEmitter], _StatementEmitter);
_ExpressionStatementEmitter.prototype.emit$ = function () {
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._statement._expr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", null);
};


function _FunctionStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_FunctionStatementEmitter], _StatementEmitter);
_FunctionStatementEmitter.prototype.emit$ = function () {
	var $this = this;
	var funcDef;
	var _emitter$0;
	funcDef = this._statement._funcDef;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = this._emitter, "function " + _emitter$0._namer.getNameOfLocalVariable$LLocalVariable$(funcDef._funcLocal) + "(", funcDef._token);
	this._emitter._namer.enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
		var args;
		var i;
		var _emitter$0;
		args = funcDef._args;
		for (i = 0; i < args.length; ++ i) {
			if (i !== 0) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", funcDef._token);
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, _emitter$0._namer.getNameOfLocalVariable$LLocalVariable$(args[i]), funcDef._token);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ") {\n", funcDef._token);
		++ $this._emitter._indent;
		JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this._emitter, funcDef);
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this._emitter);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "}\n", funcDef._token);
	}));
};


function _ReturnStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ReturnStatementEmitter], _StatementEmitter);
_ReturnStatementEmitter.prototype.emit$ = function () {
	var expr;
	var _emitter$0;
	expr = this._statement._expr;
	if (expr != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "return ", null);
		if (this._emitter._enableProfiler) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "$__jsx_profiler.exit(", null);
		}
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(_emitter$0 = this._emitter, this._statement._expr, _emitter$0._emittingFunction._returnType);
		if (this._emitter._enableProfiler) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", null);
	} else {
		if (this._emitter._enableProfiler) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "return $__jsx_profiler.exit();\n", this._statement._token);
		} else {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "return;\n", this._statement._token);
		}
	}
};


function _DeleteStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_DeleteStatementEmitter], _StatementEmitter);
_DeleteStatementEmitter.prototype.emit$ = function () {
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "delete ", this._statement._token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._statement._expr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", null);
};


function _BreakStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_BreakStatementEmitter], _StatementEmitter);
_BreakStatementEmitter.prototype.emit$ = function () {
	var _statement$0;
	if (this._statement._label != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "break " + (_statement$0 = this._statement)._label._value + ";\n", _statement$0._token);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "break;\n", this._statement._token);
	}
};


function _ContinueStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ContinueStatementEmitter], _StatementEmitter);
_ContinueStatementEmitter.prototype.emit$ = function () {
	var _statement$0;
	if (this._statement._label != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "continue " + (_statement$0 = this._statement)._label._value + ";\n", _statement$0._token);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "continue;\n", this._statement._token);
	}
};


function _DoWhileStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_DoWhileStatementEmitter], _StatementEmitter);
_DoWhileStatementEmitter.prototype.emit$ = function () {
	_StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$(this, this._statement);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "do {\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, this._statement.getStatements$());
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "} while (", null);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._statement._expr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ");\n", null);
};


function _ForInStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ForInStatementEmitter], _StatementEmitter);
_ForInStatementEmitter.prototype.emit$ = function () {
	_StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$(this, this._statement);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "for (", null);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._statement._lhsExpr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " in ", null);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._statement._listExpr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") {\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, this._statement._statements);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
};


function _ForStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ForStatementEmitter], _StatementEmitter);
_ForStatementEmitter.prototype.emit$ = function () {
	var initExpr;
	var condExpr;
	var postExpr;
	_StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$(this, this._statement);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "for (", this._statement._token);
	initExpr = this._statement._initExpr;
	if (initExpr != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, initExpr).emit$N(0);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "; ", null);
	condExpr = this._statement._condExpr;
	if (condExpr != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, condExpr).emit$N(0);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "; ", null);
	postExpr = this._statement._postExpr;
	if (postExpr != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, postExpr).emit$N(0);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") {\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, this._statement._statements);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
};


function _IfStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_IfStatementEmitter], _StatementEmitter);
_IfStatementEmitter.prototype.emit$ = function () {
	var ifFalseStatements;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "if (", this._statement._token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._statement._expr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") {\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, this._statement._onTrueStatements);
	ifFalseStatements = this._statement._onFalseStatements;
	if (ifFalseStatements.length !== 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "} else {\n", null);
		JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, ifFalseStatements);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
};


function _SwitchStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_SwitchStatementEmitter], _StatementEmitter);
_SwitchStatementEmitter.prototype.emit$ = function () {
	_StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$(this, this._statement);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "switch (", this._statement._token);
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, this._statement._expr, 0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") {\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, this._statement._statements);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
};


function _CaseStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_CaseStatementEmitter], _StatementEmitter);
_CaseStatementEmitter.prototype.emit$ = function () {
	JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$(this._emitter);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "case ", null);
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, this._statement._expr, 0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ":\n", null);
	++ this._emitter._indent;
};


function _DefaultStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_DefaultStatementEmitter], _StatementEmitter);
_DefaultStatementEmitter.prototype.emit$ = function () {
	JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$(this._emitter);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "default:\n", null);
	++ this._emitter._indent;
};


function _WhileStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_WhileStatementEmitter], _StatementEmitter);
_WhileStatementEmitter.prototype.emit$ = function () {
	_StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$(this, this._statement);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "while (", this._statement._token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._statement._expr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") {\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, this._statement._statements);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
};


function _TryStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_TryStatementEmitter], _StatementEmitter);
_TryStatementEmitter.prototype.emit$ = function () {
	var $this = this;
	var catchStatements;
	var finallyStatements;
	var this$0;
	var tryStmt$0;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "try {\n", this._statement._token);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, this._statement._tryStatements);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}", null);
	catchStatements = this._statement._catchStatements;
	if (catchStatements.length !== 0) {
		this$0 = this._emitter._namer;
		tryStmt$0 = this._statement;
		++ this$0._catchLevel;
		_Namer$_enterCatch$L_Namer$LTryStatement$F$F$S$V$S(this$0, tryStmt$0, (function (getCatchName) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " catch (" + getCatchName() + ") {\n", null);
			if ($this._emitter._enableProfiler) {
				++ $this._emitter._indent;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$__jsx_profiler.resume($__jsx_profiler_ctx);\n", null);
				JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this._emitter);
			}
			JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$($this._emitter, catchStatements.map((function (s) {
				return s;
			})));
			if (! catchStatements[catchStatements.length - 1]._local._type.equals$LType$(Type.variantType)) {
				++ $this._emitter._indent;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "{\n", null);
				++ $this._emitter._indent;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "throw " + getCatchName() + ";\n", null);
				JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this._emitter);
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "}\n", null);
				JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this._emitter);
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "}", null);
		}), "$__jsx_catch_" + (this$0._catchLevel + ""));
		-- this$0._catchLevel;
	}
	finallyStatements = this._statement._finallyStatements;
	if (finallyStatements.length !== 0 || catchStatements.length === 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " finally {\n", null);
		JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, finallyStatements);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}", null);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "\n", null);
};


function _CatchStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_CatchStatementEmitter], _StatementEmitter);
_CatchStatementEmitter.prototype.emit$ = function () {
	var localType;
	var this$0;
	var _emitter$0;
	this$0 = this._statement._local;
	localType = this$0._type;
	if (localType instanceof ObjectType) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = this._emitter, "if (" + _emitter$0._namer.getNameOfLocalVariable$LLocalVariable$(this._statement._local) + " instanceof " + this._emitter._namer.getNameOfClass$LClassDefinition$(localType.getClassDef$()) + ") {\n", this._statement._token);
		JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, this._statement._statements);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "} else ", null);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "{\n", null);
		JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, this._statement._statements);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
	}
};


function _ThrowStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ThrowStatementEmitter], _StatementEmitter);
_ThrowStatementEmitter.prototype.emit$ = function () {
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "throw ", this._statement._token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._statement._expr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", null);
};


function _AssertStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_AssertStatementEmitter], _StatementEmitter);
_AssertStatementEmitter.prototype.emit$ = function () {
	var $this = this;
	var condExpr;
	var _statement$0;
	condExpr = (_statement$0 = this._statement)._expr;
	if (_statement$0._msgExpr != null) {
		JavaScriptEmitter$_emitAssertionWithMsg$LJavaScriptEmitter$F$V$LToken$SLExpression$(this._emitter, (function () {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, condExpr).emit$N(0);
		}), condExpr._token, "assertion failure", this._statement._msgExpr);
	} else {
		JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S(this._emitter, (function () {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, condExpr).emit$N(0);
		}), condExpr._token, "assertion failure");
	}
};


function _LogStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_LogStatementEmitter], _StatementEmitter);
_LogStatementEmitter.prototype.emit$ = function () {
	var exprs;
	var i;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "console.log(", this._statement._token);
	exprs = this._statement._exprs;
	for (i = 0; i < exprs.length; ++ i) {
		if (i !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", null);
		}
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, exprs[i]).emit$N(0);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ");\n", null);
};


function _DebuggerStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_DebuggerStatementEmitter], _StatementEmitter);
_DebuggerStatementEmitter.prototype.emit$ = function () {
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "debugger;\n", this._statement._token);
};


function _ExpressionEmitter(emitter) {
	this._emitter = emitter;
};

$__jsx_extend([_ExpressionEmitter], Object);
_ExpressionEmitter.prototype.emitWithPrecedence$NNF$V$ = function (outerOpPrecedence, precedence, callback) {
	if (precedence > outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "(", null);
		callback();
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", null);
	} else {
		callback();
	}
};


function _ExpressionEmitter$emitWithPrecedence$L_ExpressionEmitter$NNF$V$($this, outerOpPrecedence, precedence, callback) {
	if (precedence > outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "(", null);
		callback();
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ")", null);
	} else {
		callback();
	}
};

_ExpressionEmitter.emitWithPrecedence$L_ExpressionEmitter$NNF$V$ = _ExpressionEmitter$emitWithPrecedence$L_ExpressionEmitter$NNF$V$;

function _LocalExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_LocalExpressionEmitter], _ExpressionEmitter);
_LocalExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var local;
	var _emitter$0;
	local = this._expr._local;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = this._emitter, _emitter$0._namer.getNameOfLocalVariable$LLocalVariable$(local), this._expr._token);
};


function _ClassExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ClassExpressionEmitter], _ExpressionEmitter);
_ClassExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var type;
	var _emitter$0;
	type = this._expr._parsedType;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = this._emitter, _emitter$0._namer.getNameOfClass$LClassDefinition$(type.getClassDef$()), null);
};


function _NullExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_NullExpressionEmitter], _ExpressionEmitter);
_NullExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var token;
	token = this._expr._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "null", token);
};


function _BooleanLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_BooleanLiteralExpressionEmitter], _ExpressionEmitter);
_BooleanLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var token;
	token = this._expr._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, token._value, token);
};


function _IntegerLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_IntegerLiteralExpressionEmitter], _ExpressionEmitter);
_IntegerLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var token;
	token = this._expr._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "" + token._value, token);
};


function _NumberLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_NumberLiteralExpressionEmitter], _ExpressionEmitter);
_NumberLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var token;
	var str;
	token = this._expr._token;
	str = token._value;
	if (outerOpPrecedence === _PropertyExpressionEmitter._operatorPrecedence && str.indexOf(".") === -1) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "(" + str + ")", token);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "" + str, token);
	}
};


function _StringLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_StringLiteralExpressionEmitter], _ExpressionEmitter);
_StringLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var token;
	token = this._expr._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, token._value, token);
};


function _RegExpLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_RegExpLiteralExpressionEmitter], _ExpressionEmitter);
_RegExpLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var token;
	token = this._expr._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, token._value, token);
};


function _ArrayLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ArrayLiteralExpressionEmitter], _ExpressionEmitter);
_ArrayLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var exprs;
	var i;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "[ ", null);
	exprs = this._expr._exprs;
	for (i = 0; i < exprs.length; ++ i) {
		if (i !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", null);
		}
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, exprs[i]).emit$N(0);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " ]", null);
};


function _MapLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_MapLiteralExpressionEmitter], _ExpressionEmitter);
_MapLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var elements;
	var i;
	var element;
	var _key$0;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "({ ", null);
	elements = this._expr._elements;
	for (i = 0; i < elements.length; ++ i) {
		element = elements[i];
		if (i !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, (_key$0 = element._key)._value, _key$0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ": ", null);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, element._expr).emit$N(0);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " })", null);
};


function _ThisExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ThisExpressionEmitter], _ExpressionEmitter);
_ThisExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var emittingFunction;
	emittingFunction = this._emitter._emittingFunction;
	if ((emittingFunction._flags & 8) !== 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "$this", this._expr._token);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "this", this._expr._token);
	}
};


function _AsExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_AsExpressionEmitter], _ExpressionEmitter);
_AsExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var srcType;
	var destType;
	var prec;
	var _expr$0;
	srcType = this._expr._expr.getType$();
	destType = this._expr._type;
	if (srcType instanceof ObjectType || srcType.equals$LType$(Type.variantType)) {
		if (srcType.isConvertibleTo$LType$(destType)) {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._expr).emit$N(outerOpPrecedence);
			return;
		}
		if (destType instanceof ObjectType || destType instanceof FunctionType) {
			new _AsNoConvertExpressionEmitter(this._emitter, new AsNoConvertExpression((_expr$0 = this._expr)._token, _expr$0._expr, _expr$0._type)).emit$N(outerOpPrecedence);
			return;
		}
	}
	if ((srcType instanceof NullableType ? srcType._baseType : srcType).equals$LType$(Type.booleanType)) {
		if (destType.equals$LType$(Type.integerType) || destType.equals$LType$(Type.numberType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["+"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "+", null);
			return;
		}
		if (destType.equals$LType$(Type.stringType)) {
			prec = _AdditiveExpressionEmitter._operatorPrecedence;
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " + \"\"");
			return;
		}
	}
	if ((srcType instanceof NullableType ? srcType._baseType : srcType).equals$LType$(Type.integerType)) {
		if (destType.equals$LType$(Type.booleanType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["!"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "!! ", null);
			return;
		}
		if (destType.equals$LType$(Type.numberType)) {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._expr).emit$N(outerOpPrecedence);
			return;
		}
		if (destType.equals$LType$(Type.stringType)) {
			prec = _AdditiveExpressionEmitter._operatorPrecedence;
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " + \"\"");
			return;
		}
	}
	if ((srcType instanceof NullableType ? srcType._baseType : srcType).equals$LType$(Type.numberType)) {
		if (destType.equals$LType$(Type.booleanType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["!"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "!! ", null);
			return;
		}
		if (destType.equals$LType$(Type.integerType)) {
			prec = _BinaryNumberExpressionEmitter._operatorPrecedence["|"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " | 0");
			return;
		}
		if (destType.equals$LType$(Type.stringType)) {
			prec = _AdditiveExpressionEmitter._operatorPrecedence;
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " + \"\"");
			return;
		}
	}
	if ((srcType instanceof NullableType ? srcType._baseType : srcType).equals$LType$(Type.stringType)) {
		if (destType.equals$LType$(Type.booleanType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["!"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "!! ", null);
			return;
		}
		if (destType.equals$LType$(Type.integerType)) {
			prec = _BinaryNumberExpressionEmitter._operatorPrecedence["|"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " | 0");
			return;
		}
		if (destType.equals$LType$(Type.numberType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["+"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "+", null);
			return;
		}
	}
	if (srcType.equals$LType$(Type.variantType)) {
		if (destType.equals$LType$(Type.booleanType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["!"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "!! ", null);
			return;
		}
		if (destType.equals$LType$(Type.integerType)) {
			prec = _BinaryNumberExpressionEmitter._operatorPrecedence["|"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " | 0");
			return;
		}
		if (destType.equals$LType$(Type.numberType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["+"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "+", null);
			return;
		}
		if (destType.equals$LType$(Type.stringType)) {
			prec = _AdditiveExpressionEmitter._operatorPrecedence;
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " + \"\"");
			return;
		}
	}
	if (srcType.isConvertibleTo$LType$(destType)) {
		if (srcType instanceof NullableType) {
			JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, this._expr._expr, outerOpPrecedence);
		} else {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._expr).emit$N(outerOpPrecedence);
		}
		return;
	}
	throw new Error("explicit conversion logic unknown from " + srcType.toString() + " to " + destType.toString());
};


_AsExpressionEmitter.prototype._emitWithParens$NNNUSUS = function (outerOpPrecedence, opPrecedence, innerOpPrecedence, prefix, postfix) {
	if (opPrecedence >= outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "(", null);
	}
	if (prefix != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, prefix, this._expr._token);
	}
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, this._expr._expr, innerOpPrecedence);
	if (postfix != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, postfix, this._expr._token);
	}
	if (opPrecedence >= outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", null);
	}
};


function _AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS($this, outerOpPrecedence, opPrecedence, innerOpPrecedence, prefix, postfix) {
	if (opPrecedence >= outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "(", null);
	}
	if (prefix != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, prefix, $this._expr._token);
	}
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, $this._expr._expr, innerOpPrecedence);
	if (postfix != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, postfix, $this._expr._token);
	}
	if (opPrecedence >= outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ")", null);
	}
};

_AsExpressionEmitter._emitWithParens$L_AsExpressionEmitter$NNNUSUS = _AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS;

function _AsNoConvertExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_AsNoConvertExpressionEmitter], _ExpressionEmitter);
_AsNoConvertExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var $this = this;
	var emitWithAssertion;
	var srcType;
	var destType;
	var destClassDef;
	if (this._emitter._enableRunTimeTypeCheck) {
		emitWithAssertion = (function (emitCheckExpr, message) {
			var token;
			token = $this._expr._token;
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "(function ($v) {\n", token);
			++ $this._emitter._indent;
			JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S($this._emitter, emitCheckExpr, token, message);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "return $v;\n", token);
			JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this._emitter);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "}(", token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, $this._expr._expr).emit$N(0);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "))", token);
		});
		srcType = this._expr._expr.getType$();
		destType = this._expr._type;
		if (srcType.equals$LType$(destType) || srcType.equals$LType$(destType instanceof NullableType ? destType._baseType : destType)) {
		} else {
			if (destType instanceof VariantType) {
			} else {
				if (srcType instanceof ObjectType && srcType.isConvertibleTo$LType$(destType)) {
				} else {
					if (destType.equals$LType$(Type.booleanType)) {
						emitWithAssertion((function () {
							JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "typeof $v === \"boolean\"", $this._expr._token);
						}), "detected invalid cast, value is not a boolean");
						return;
					} else {
						if ((destType instanceof NullableType ? destType._baseType : destType).equals$LType$(Type.booleanType)) {
							emitWithAssertion((function () {
								JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"boolean\"", $this._expr._token);
							}), "detected invalid cast, value is not a boolean nor null");
							return;
						} else {
							if (destType.equals$LType$(Type.numberType)) {
								emitWithAssertion((function () {
									JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "typeof $v === \"number\"", $this._expr._token);
								}), "detected invalid cast, value is not a number");
								return;
							} else {
								if ((destType instanceof NullableType ? destType._baseType : destType).equals$LType$(Type.numberType)) {
									emitWithAssertion((function () {
										JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"number\"", $this._expr._token);
									}), "detected invalid cast, value is not a number nor nullable");
									return;
								} else {
									if (destType.equals$LType$(Type.integerType)) {
										emitWithAssertion((function () {
											JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "typeof $v === \"number\" && (! $__jsx_isFinite($v) || $v % 1 === 0)", $this._expr._token);
										}), "detected invalid cast, value is not an int");
										return;
									} else {
										if ((destType instanceof NullableType ? destType._baseType : destType).equals$LType$(Type.integerType)) {
											emitWithAssertion((function () {
												JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"number\" && (! $__jsx_isFinite($v) || $v % 1 === 0)", $this._expr._token);
											}), "detected invalid cast, value is not an int nor null");
											return;
										} else {
											if (destType.equals$LType$(Type.stringType)) {
												emitWithAssertion((function () {
													JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "typeof $v === \"string\"", $this._expr._token);
												}), "detected invalid cast, value is not a string");
												return;
											} else {
												if ((destType instanceof NullableType ? destType._baseType : destType).equals$LType$(Type.stringType)) {
													emitWithAssertion((function () {
														JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"string\"", $this._expr._token);
													}), "detected invalid cast, value is not a string nor null");
													return;
												} else {
													if (destType instanceof FunctionType) {
														emitWithAssertion((function () {
															JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"function\"", $this._expr._token);
														}), "detected invalid cast, value is not a function or null");
														return;
													} else {
														if (destType instanceof ObjectType) {
															destClassDef = destType.getClassDef$();
															if ((destClassDef.flags$() & 256) !== 0) {
															} else {
																if (destClassDef instanceof InstantiatedClassDefinition && destClassDef._templateClassDef._className === "Array") {
																	emitWithAssertion((function () {
																		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || $v instanceof Array", $this._expr._token);
																	}), "detected invalid cast, value is not an Array or null");
																	return;
																} else {
																	if (destClassDef instanceof InstantiatedClassDefinition && destClassDef._templateClassDef._className === "Map") {
																		if (srcType.equals$LType$(Type.variantType)) {
																			emitWithAssertion((function () {
																				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"object\" || typeof $v === \"function\"", $this._expr._token);
																			}), "detected invalid cast, value is not a Map or null");
																		} else {
																			emitWithAssertion((function () {
																				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"object\"", $this._expr._token);
																			}), "detected invalid cast, value is not a Map or null");
																		}
																		return;
																	} else {
																		if ((destClassDef.flags$() & 192) === 0) {
																			emitWithAssertion((function () {
																				var _emitter$0;
																				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, "$v == null || $v instanceof " + _emitter$0._namer.getNameOfClass$LClassDefinition$(destClassDef), $this._expr._token);
																			}), "detected invalid cast, value is not an instance of the designated type or null");
																			return;
																		} else {
																			emitWithAssertion((function () {
																				var _emitter$0;
																				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, "$v == null || $v.$__jsx_implements_" + _emitter$0._namer.getNameOfClass$LClassDefinition$(destClassDef), $this._expr._token);
																			}), "detected invalid cast, value is not an instance of the designated type or null");
																			return;
																		}
																	}
																}
															}
														} else {
															throw new Error("Hmm");
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._expr).emit$N(outerOpPrecedence);
	return;
};


function _OperatorExpressionEmitter(emitter) {
	this._emitter = emitter;
};

$__jsx_extend([_OperatorExpressionEmitter], _ExpressionEmitter);
_OperatorExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var $this = this;
	_ExpressionEmitter$emitWithPrecedence$L_ExpressionEmitter$NNF$V$(this, outerOpPrecedence, this._getPrecedence$(), (function () {
		$this._emit$();
	}));
};


_OperatorExpressionEmitter.prototype._emit$ = function () {
};


function _UnaryExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_UnaryExpressionEmitter], _OperatorExpressionEmitter);
_UnaryExpressionEmitter.prototype._emit$ = function () {
	var opToken;
	opToken = this._expr._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, opToken._value + " ", opToken);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._expr).emit$N(this._getPrecedence$());
};


_UnaryExpressionEmitter.prototype._getPrecedence$ = function () {
	return _UnaryExpressionEmitter._operatorPrecedence[this._expr._token._value];
};


function _UnaryExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_UnaryExpressionEmitter._operatorPrecedence[op] = precedence;
};

_UnaryExpressionEmitter._setOperatorPrecedence$SN = _UnaryExpressionEmitter$_setOperatorPrecedence$SN;

function _PostfixExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_PostfixExpressionEmitter], _UnaryExpressionEmitter);
_PostfixExpressionEmitter.prototype._emit$ = function () {
	var opToken;
	var _expr$0;
	opToken = (_expr$0 = this._expr)._token;
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, _expr$0._expr).emit$N(_PostfixExpressionEmitter._operatorPrecedence[this._expr._token._value]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, opToken._value, opToken);
};


_PostfixExpressionEmitter.prototype._getPrecedence$ = function () {
	return _PostfixExpressionEmitter._operatorPrecedence[this._expr._token._value];
};


function _PostfixExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_PostfixExpressionEmitter._operatorPrecedence[op] = precedence;
};

_PostfixExpressionEmitter._setOperatorPrecedence$SN = _PostfixExpressionEmitter$_setOperatorPrecedence$SN;

function _InstanceofExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_InstanceofExpressionEmitter], _ExpressionEmitter);
_InstanceofExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var $this = this;
	var expectedType;
	var getTemplateClassName$this$0;
	var getTemplateClassName$this$1;
	expectedType = this._expr._expectedType;
	if (expectedType.getClassDef$() instanceof InstantiatedClassDefinition && (getTemplateClassName$this$1 = expectedType.getClassDef$(), getTemplateClassName$this$1._templateClassDef._className) === "Array") {
		_ExpressionEmitter$emitWithPrecedence$L_ExpressionEmitter$NNF$V$(this, outerOpPrecedence, _InstanceofExpressionEmitter._operatorPrecedence, (function () {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, $this._expr._expr).emit$N(_InstanceofExpressionEmitter._operatorPrecedence);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " instanceof Array", $this._expr._token);
		}));
	} else {
		if (expectedType.getClassDef$() instanceof InstantiatedClassDefinition && (getTemplateClassName$this$0 = expectedType.getClassDef$(), getTemplateClassName$this$0._templateClassDef._className) === "Map") {
			_ExpressionEmitter$emitWithPrecedence$L_ExpressionEmitter$NNF$V$(this, outerOpPrecedence, _InstanceofExpressionEmitter._operatorPrecedence, (function () {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "(typeof(", $this._expr._token);
				JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, $this._expr._expr).emit$N(_InstanceofExpressionEmitter._operatorPrecedence);
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ") === \"object\")", $this._expr._token);
			}));
		} else {
			if ((expectedType.getClassDef$().flags$() & 192) === 0) {
				_ExpressionEmitter$emitWithPrecedence$L_ExpressionEmitter$NNF$V$(this, outerOpPrecedence, _InstanceofExpressionEmitter._operatorPrecedence, (function () {
					JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, $this._expr._expr).emit$N(_InstanceofExpressionEmitter._operatorPrecedence);
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " instanceof " + _InstanceofExpressionEmitter$getInstanceofNameFromClassDef$L_InstanceofExpressionEmitter$LClassDefinition$($this, expectedType.getClassDef$()), $this._expr._token);
				}));
			} else {
				_ExpressionEmitter$emitWithPrecedence$L_ExpressionEmitter$NNF$V$(this, outerOpPrecedence, _CallExpressionEmitter._operatorPrecedence, (function () {
					var _emitter$0;
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, "(function (o) { return !! (o && o.$__jsx_implements_" + _emitter$0._namer.getNameOfClass$LClassDefinition$(expectedType.getClassDef$()) + "); })(", $this._expr._token);
					JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, $this._expr._expr).emit$N(0);
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ")", $this._expr._token);
				}));
			}
		}
	}
};


_InstanceofExpressionEmitter.prototype.getInstanceofNameFromClassDef$LClassDefinition$ = function (classDef) {
	var name;
	if (classDef instanceof InstantiatedClassDefinition) {
		name = classDef._templateClassDef._className;
		if (name === "Map") {
			name = "Object";
		}
	} else {
		name = this._emitter._namer.getNameOfClass$LClassDefinition$(classDef);
	}
	return name;
};


function _InstanceofExpressionEmitter$getInstanceofNameFromClassDef$L_InstanceofExpressionEmitter$LClassDefinition$($this, classDef) {
	var name;
	if (classDef instanceof InstantiatedClassDefinition) {
		name = classDef._templateClassDef._className;
		if (name === "Map") {
			name = "Object";
		}
	} else {
		name = $this._emitter._namer.getNameOfClass$LClassDefinition$(classDef);
	}
	return name;
};

_InstanceofExpressionEmitter.getInstanceofNameFromClassDef$L_InstanceofExpressionEmitter$LClassDefinition$ = _InstanceofExpressionEmitter$getInstanceofNameFromClassDef$L_InstanceofExpressionEmitter$LClassDefinition$;

function _InstanceofExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_InstanceofExpressionEmitter._operatorPrecedence = precedence;
};

_InstanceofExpressionEmitter._setOperatorPrecedence$SN = _InstanceofExpressionEmitter$_setOperatorPrecedence$SN;

function _PropertyExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_PropertyExpressionEmitter], _UnaryExpressionEmitter);
_PropertyExpressionEmitter.prototype._emit$ = function () {
	var expr;
	var exprType;
	var identifierToken;
	var classDef;
	var name;
	var exprType$0;
	var exprType$1;
	expr = this._expr;
	exprType = expr._type;
	identifierToken = expr._identifierToken;
	if (expr._expr.isClassSpecifier$() && expr._expr.getType$().getClassDef$() == (Type.numberType, NumberType._classDef)) {
		switch (identifierToken._value) {
		case "parseInt":
		case "parseFloat":
		case "isNaN":
		case "isFinite":
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, '$__jsx_' + identifierToken._value, identifierToken);
			return;
		}
	} else {
		if (expr._expr.isClassSpecifier$() && expr._expr.getType$().getClassDef$() == (Type.stringType, StringType._classDef)) {
			switch (identifierToken._value) {
			case "encodeURIComponent":
			case "decodeURIComponent":
			case "encodeURI":
			case "decodeURI":
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, '$__jsx_' + identifierToken._value, identifierToken);
				return;
			}
		}
	}
	classDef = expr.getHolderType$().getClassDef$();
	if (expr._expr.isClassSpecifier$()) {
		name = identifierToken._value;
		exprType$0 = expr._type;
		if (! (exprType$0 instanceof FunctionType) ? false : exprType$0.isAssignable$() ? false : true) {
			name = this._emitter._namer.getNameOfStaticFunction$LClassDefinition$SALType$(classDef, name, exprType._argTypes);
		} else {
			name = this._emitter._namer.getNameOfClass$LClassDefinition$(classDef) + "." + this._emitter._namer.getNameOfStaticVariable$LClassDefinition$S(classDef, name);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, name, identifierToken);
	} else {
		name = identifierToken._value;
		exprType$1 = expr._type;
		if (! (exprType$1 instanceof FunctionType) ? false : exprType$1.isAssignable$() ? false : true) {
			name = this._emitter._namer.getNameOfMethod$LClassDefinition$SALType$(classDef, name, exprType._argTypes);
		} else {
			name = this._emitter._namer.getNameOfProperty$LClassDefinition$S(classDef, name);
		}
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, expr._expr).emit$N(_PropertyExpressionEmitter._operatorPrecedence);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "." + name, identifierToken);
	}
};


_PropertyExpressionEmitter.prototype._getPrecedence$ = function () {
	return _PropertyExpressionEmitter._operatorPrecedence;
};


function _PropertyExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_PropertyExpressionEmitter._operatorPrecedence = precedence;
};

_PropertyExpressionEmitter._setOperatorPrecedence$SN = _PropertyExpressionEmitter$_setOperatorPrecedence$SN;

function _FunctionExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_FunctionExpressionEmitter], _OperatorExpressionEmitter);
_FunctionExpressionEmitter.prototype._emit$ = function () {
	var $this = this;
	var funcDef;
	var funcLocal;
	funcDef = this._expr._funcDef;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "(", funcDef._token);
	funcLocal = funcDef._funcLocal;
	this._emitter._namer.enterScope$LLocalVariable$F$V$(funcLocal, (function () {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "function " + (funcLocal != null ? $this._emitter._namer.getNameOfLocalVariable$LLocalVariable$(funcLocal) : "") + "(", funcDef._token);
		$this._emitter._namer.enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
			var args;
			var i;
			args = MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef);
			for (i = 0; i < args.length; ++ i) {
				if (i !== 0) {
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", MemberDefinition$getToken$LMemberDefinition$(funcDef));
				}
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, JavaScriptEmitter$getNamer$LJavaScriptEmitter$($this._emitter).getNameOfLocalVariable$LLocalVariable$(args[i]), MemberDefinition$getToken$LMemberDefinition$(funcDef));
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ") {\n", MemberDefinition$getToken$LMemberDefinition$(funcDef));
			JavaScriptEmitter$_advanceIndent$LJavaScriptEmitter$($this._emitter);
			JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this._emitter, funcDef);
			JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this._emitter);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "}", MemberDefinition$getToken$LMemberDefinition$(funcDef));
		}));
	}));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", funcDef._token);
};


_FunctionExpressionEmitter.prototype._getPrecedence$ = function () {
	return _FunctionExpressionEmitter._operatorPrecedence;
};


function _FunctionExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_FunctionExpressionEmitter._operatorPrecedence = precedence;
};

_FunctionExpressionEmitter._setOperatorPrecedence$SN = _FunctionExpressionEmitter$_setOperatorPrecedence$SN;

function _AdditiveExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_AdditiveExpressionEmitter], _OperatorExpressionEmitter);
_AdditiveExpressionEmitter.prototype._emit$ = function () {
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, this._expr._expr1, _AdditiveExpressionEmitter._operatorPrecedence);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " + ", this._expr._token);
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, this._expr._expr2, _AdditiveExpressionEmitter._operatorPrecedence - 1);
};


_AdditiveExpressionEmitter.prototype._getPrecedence$ = function () {
	return _AdditiveExpressionEmitter._operatorPrecedence;
};


function _AdditiveExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_AdditiveExpressionEmitter._operatorPrecedence = precedence;
};

_AdditiveExpressionEmitter._setOperatorPrecedence$SN = _AdditiveExpressionEmitter$_setOperatorPrecedence$SN;

function _AssignmentExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_AssignmentExpressionEmitter], _OperatorExpressionEmitter);
_AssignmentExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var resolveIfNullable$this$0;
	var _expr$0;
	if ((_expr$0 = this._expr)._token._value === "/=" && (resolveIfNullable$this$0 = _expr$0._expr1.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0).equals$LType$(Type.integerType)) {
		_AssignmentExpressionEmitter$_emitDivAssignToInt$L_AssignmentExpressionEmitter$N(this, outerOpPrecedence);
		return;
	}
	_OperatorExpressionEmitter.prototype.emit$N.call(this, outerOpPrecedence);
};


_AssignmentExpressionEmitter.prototype._emit$ = function () {
	var op;
	var this$0;
	var _expr$0;
	var _expr$1;
	this$0 = (_expr$0 = this._expr)._token;
	op = this$0._value;
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, _expr$0._expr1).emit$N(_AssignmentExpressionEmitter._operatorPrecedence[op]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " " + op + " ", this._expr._token);
	JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(this._emitter, (_expr$1 = this._expr)._expr2, _expr$1._expr1.getType$());
};


_AssignmentExpressionEmitter.prototype._emitDivAssignToInt$N = function (outerOpPrecedence) {
	var $this = this;
	var firstExpr;
	var secondExpr;
	var propertyExpr;
	var name;
	var classDef;
	var _expr$0;
	firstExpr = (_expr$0 = this._expr)._expr1;
	secondExpr = _expr$0._expr2;
	if (firstExpr instanceof PropertyExpression || firstExpr instanceof ArrayExpression) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "$__jsx_div_assign(", this._expr._token);
		if (firstExpr instanceof PropertyExpression) {
			propertyExpr = firstExpr;
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, propertyExpr._expr).emit$N(0);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", this._expr._token);
			if (propertyExpr._expr.isClassSpecifier$()) {
				classDef = propertyExpr.getHolderType$().getClassDef$();
				name = this._emitter._namer.getNameOfClass$LClassDefinition$(classDef) + "." + this._emitter._namer.getNameOfStaticVariable$LClassDefinition$S(classDef, propertyExpr._identifierToken._value);
			} else {
				name = this._emitter._namer.getNameOfProperty$LClassDefinition$S(propertyExpr.getHolderType$().getClassDef$(), propertyExpr._identifierToken._value);
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, Util$encodeStringLiteral$S(name), propertyExpr._identifierToken);
		} else {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, firstExpr._expr1).emit$N(0);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", this._expr._token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, firstExpr._expr2).emit$N(0);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", this._expr._token);
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, secondExpr, 0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", this._expr._token);
	} else {
		_ExpressionEmitter$emitWithPrecedence$L_ExpressionEmitter$NNF$V$(this, outerOpPrecedence, _AssignmentExpressionEmitter._operatorPrecedence["="], (function () {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, firstExpr).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " = (", $this._expr._token);
			JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, firstExpr, _BinaryNumberExpressionEmitter._operatorPrecedence["/"]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " / ", $this._expr._token);
			JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, secondExpr, _BinaryNumberExpressionEmitter._operatorPrecedence["/"] - 1);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ") | 0", $this._expr._token);
		}));
	}
};


function _AssignmentExpressionEmitter$_emitDivAssignToInt$L_AssignmentExpressionEmitter$N($this, outerOpPrecedence) {
	var firstExpr;
	var secondExpr;
	var propertyExpr;
	var name;
	var classDef;
	var _expr$0;
	firstExpr = (_expr$0 = $this._expr)._expr1;
	secondExpr = _expr$0._expr2;
	if (firstExpr instanceof PropertyExpression || firstExpr instanceof ArrayExpression) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$__jsx_div_assign(", $this._expr._token);
		if (firstExpr instanceof PropertyExpression) {
			propertyExpr = firstExpr;
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, propertyExpr._expr).emit$N(0);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", $this._expr._token);
			if (propertyExpr._expr.isClassSpecifier$()) {
				classDef = propertyExpr.getHolderType$().getClassDef$();
				name = $this._emitter._namer.getNameOfClass$LClassDefinition$(classDef) + "." + $this._emitter._namer.getNameOfStaticVariable$LClassDefinition$S(classDef, propertyExpr._identifierToken._value);
			} else {
				name = $this._emitter._namer.getNameOfProperty$LClassDefinition$S(propertyExpr.getHolderType$().getClassDef$(), propertyExpr._identifierToken._value);
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, Util$encodeStringLiteral$S(name), propertyExpr._identifierToken);
		} else {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, firstExpr._expr1).emit$N(0);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", $this._expr._token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, firstExpr._expr2).emit$N(0);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", $this._expr._token);
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, secondExpr, 0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ")", $this._expr._token);
	} else {
		_ExpressionEmitter$emitWithPrecedence$L_ExpressionEmitter$NNF$V$($this, outerOpPrecedence, _AssignmentExpressionEmitter._operatorPrecedence["="], (function () {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, firstExpr).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " = (", $this._expr._token);
			JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, firstExpr, _BinaryNumberExpressionEmitter._operatorPrecedence["/"]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " / ", $this._expr._token);
			JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, secondExpr, _BinaryNumberExpressionEmitter._operatorPrecedence["/"] - 1);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ") | 0", $this._expr._token);
		}));
	}
};

_AssignmentExpressionEmitter._emitDivAssignToInt$L_AssignmentExpressionEmitter$N = _AssignmentExpressionEmitter$_emitDivAssignToInt$L_AssignmentExpressionEmitter$N;

_AssignmentExpressionEmitter.prototype._getPrecedence$ = function () {
	return _AssignmentExpressionEmitter._operatorPrecedence[this._expr._token._value];
};


function _AssignmentExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_AssignmentExpressionEmitter._operatorPrecedence[op] = precedence;
};

_AssignmentExpressionEmitter._setOperatorPrecedence$SN = _AssignmentExpressionEmitter$_setOperatorPrecedence$SN;

function _EqualityExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_EqualityExpressionEmitter], _OperatorExpressionEmitter);
_EqualityExpressionEmitter.prototype._emit$ = function () {
	var op;
	var emitOp;
	var lhs;
	var rhs;
	var this$0;
	var resolveIfNullable$this$0;
	var resolveIfNullable$this$1;
	var resolveIfNullable$this$2;
	var _expr$0;
	this$0 = (_expr$0 = this._expr)._token;
	op = this$0._value;
	emitOp = op;
	lhs = _expr$0._expr1;
	rhs = _expr$0._expr2;
	if (lhs.getType$() instanceof PrimitiveType && rhs.getType$() instanceof PrimitiveType) {
		emitOp += "=";
	} else {
		if ((resolveIfNullable$this$0 = lhs.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0) instanceof PrimitiveType && (resolveIfNullable$this$1 = lhs.getType$(), resolveIfNullable$this$1 instanceof NullableType ? resolveIfNullable$this$1._baseType : resolveIfNullable$this$1).equals$LType$((resolveIfNullable$this$2 = rhs.getType$(), resolveIfNullable$this$2 instanceof NullableType ? resolveIfNullable$this$2._baseType : resolveIfNullable$this$2))) {
			emitOp += "=";
		}
	}
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, lhs).emit$N(_EqualityExpressionEmitter._operatorPrecedence[op] - 1);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " " + emitOp + " ", this._expr._token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, rhs).emit$N(_EqualityExpressionEmitter._operatorPrecedence[op] - 1);
};


_EqualityExpressionEmitter.prototype._getPrecedence$ = function () {
	return _EqualityExpressionEmitter._operatorPrecedence[this._expr._token._value];
};


function _EqualityExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_EqualityExpressionEmitter._operatorPrecedence[op] = precedence;
};

_EqualityExpressionEmitter._setOperatorPrecedence$SN = _EqualityExpressionEmitter$_setOperatorPrecedence$SN;

function _InExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_InExpressionEmitter], _OperatorExpressionEmitter);
_InExpressionEmitter.prototype._emit$ = function () {
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, this._expr._expr1, _InExpressionEmitter._operatorPrecedence);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " in ", this._expr._token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._expr2).emit$N(_InExpressionEmitter._operatorPrecedence);
};


_InExpressionEmitter.prototype._getPrecedence$ = function () {
	return _InExpressionEmitter._operatorPrecedence;
};


function _InExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_InExpressionEmitter._operatorPrecedence = precedence;
};

_InExpressionEmitter._setOperatorPrecedence$SN = _InExpressionEmitter$_setOperatorPrecedence$SN;

function _LogicalExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_LogicalExpressionEmitter], _OperatorExpressionEmitter);
_LogicalExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var logicalExpr$0;
	logicalExpr$0 = this._expr;
	if (JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$(this._emitter, logicalExpr$0).shouldBooleanize) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "!! (", this._expr._token);
		_OperatorExpressionEmitter.prototype.emit$N.call(this, 0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", this._expr._token);
		return;
	}
	_OperatorExpressionEmitter.prototype.emit$N.call(this, outerOpPrecedence);
};


_LogicalExpressionEmitter.prototype._emit$ = function () {
	var op;
	var this$0;
	var _expr$0;
	this$0 = (_expr$0 = this._expr)._token;
	op = this$0._value;
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, _expr$0._expr1).emit$N(_LogicalExpressionEmitter._operatorPrecedence[op]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " " + op + " ", this._expr._token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._expr2).emit$N(_LogicalExpressionEmitter._operatorPrecedence[op] - 1);
};


_LogicalExpressionEmitter.prototype._getPrecedence$ = function () {
	return _LogicalExpressionEmitter._operatorPrecedence[this._expr._token._value];
};


function _LogicalExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_LogicalExpressionEmitter._operatorPrecedence[op] = precedence;
};

_LogicalExpressionEmitter._setOperatorPrecedence$SN = _LogicalExpressionEmitter$_setOperatorPrecedence$SN;

function _ShiftExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ShiftExpressionEmitter], _OperatorExpressionEmitter);
_ShiftExpressionEmitter.prototype._emit$ = function () {
	var op;
	var this$0;
	var _expr$0;
	this$0 = (_expr$0 = this._expr)._token;
	op = this$0._value;
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, _expr$0._expr1, _ShiftExpressionEmitter._operatorPrecedence[op]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " " + op + " ", this._expr._token);
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, this._expr._expr2, _ShiftExpressionEmitter._operatorPrecedence[op] - 1);
};


_ShiftExpressionEmitter.prototype._getPrecedence$ = function () {
	return _ShiftExpressionEmitter._operatorPrecedence[this._expr._token._value];
};


function _ShiftExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_ShiftExpressionEmitter._operatorPrecedence[op] = precedence;
};

_ShiftExpressionEmitter._setOperatorPrecedence$SN = _ShiftExpressionEmitter$_setOperatorPrecedence$SN;

function _BinaryNumberExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_BinaryNumberExpressionEmitter], _OperatorExpressionEmitter);
_BinaryNumberExpressionEmitter.prototype._emit$ = function () {
	var op;
	var this$0;
	var _expr$0;
	this$0 = (_expr$0 = this._expr)._token;
	op = this$0._value;
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, _expr$0._expr1, _BinaryNumberExpressionEmitter._operatorPrecedence[op]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " " + op + " ", this._expr._token);
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, this._expr._expr2, _BinaryNumberExpressionEmitter._operatorPrecedence[op] - 1);
};


_BinaryNumberExpressionEmitter.prototype._emitIfEitherIs$NF$LExpression$LExpression$LExpression$$ = function (outerOpPrecedence, cb) {
	var outcomeExpr;
	var _expr$0;
	var _expr$1;
	if ((outcomeExpr = cb((_expr$0 = this._expr)._expr1, _expr$0._expr2)) != null || (outcomeExpr = cb((_expr$1 = this._expr)._expr2, _expr$1._expr1)) != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, outcomeExpr).emit$N(outerOpPrecedence);
		return true;
	} else {
		return false;
	}
};


function _BinaryNumberExpressionEmitter$_emitIfEitherIs$L_BinaryNumberExpressionEmitter$NF$LExpression$LExpression$LExpression$$($this, outerOpPrecedence, cb) {
	var outcomeExpr;
	var _expr$0;
	var _expr$1;
	if ((outcomeExpr = cb((_expr$0 = $this._expr)._expr1, _expr$0._expr2)) != null || (outcomeExpr = cb((_expr$1 = $this._expr)._expr2, _expr$1._expr1)) != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, outcomeExpr).emit$N(outerOpPrecedence);
		return true;
	} else {
		return false;
	}
};

_BinaryNumberExpressionEmitter._emitIfEitherIs$L_BinaryNumberExpressionEmitter$NF$LExpression$LExpression$LExpression$$ = _BinaryNumberExpressionEmitter$_emitIfEitherIs$L_BinaryNumberExpressionEmitter$NF$LExpression$LExpression$LExpression$$;

_BinaryNumberExpressionEmitter.prototype._getPrecedence$ = function () {
	return _BinaryNumberExpressionEmitter._operatorPrecedence[this._expr._token._value];
};


function _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_BinaryNumberExpressionEmitter._operatorPrecedence[op] = precedence;
};

_BinaryNumberExpressionEmitter._setOperatorPrecedence$SN = _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN;

function _ArrayExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ArrayExpressionEmitter], _OperatorExpressionEmitter);
_ArrayExpressionEmitter.prototype._emit$ = function () {
	var secondExpr;
	var emitted;
	var propertyName;
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._expr1).emit$N(_ArrayExpressionEmitter._operatorPrecedence);
	secondExpr = this._expr._expr2;
	emitted = false;
	if (secondExpr instanceof StringLiteralExpression) {
		propertyName = Util$decodeStringLiteral$S(secondExpr._token._value);
		if (propertyName.match(/^[\$_A-Za-z][\$_0-9A-Za-z]*$/) != null && ! $__jsx_ObjectHasOwnProperty.call(Util._ecma262reserved, propertyName)) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ".", this._expr._token);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, propertyName, secondExpr._token);
			emitted = true;
		}
	}
	if (! emitted) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "[", this._expr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, secondExpr).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "]", null);
	}
};


_ArrayExpressionEmitter.prototype._getPrecedence$ = function () {
	return _ArrayExpressionEmitter._operatorPrecedence;
};


function _ArrayExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_ArrayExpressionEmitter._operatorPrecedence = precedence;
};

_ArrayExpressionEmitter._setOperatorPrecedence$SN = _ArrayExpressionEmitter$_setOperatorPrecedence$SN;

function _ConditionalExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ConditionalExpressionEmitter], _OperatorExpressionEmitter);
_ConditionalExpressionEmitter.prototype._emit$ = function () {
	var precedence;
	var ifTrueExpr;
	precedence = (this._expr._ifTrueExpr != null ? _ConditionalExpressionEmitter._operatorPrecedence : _LogicalExpressionEmitter._operatorPrecedence["||"]);
	ifTrueExpr = this._expr._ifTrueExpr;
	if (ifTrueExpr != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._condExpr).emit$N(precedence - 1);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " ? ", null);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, ifTrueExpr).emit$N(precedence);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " : ", null);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._ifFalseExpr).emit$N(precedence);
	} else {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._condExpr).emit$N(precedence - 1);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " || ", null);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._ifFalseExpr).emit$N(precedence - 1);
	}
};


_ConditionalExpressionEmitter.prototype._getPrecedence$ = function () {
	return (this._expr._ifTrueExpr != null ? _ConditionalExpressionEmitter._operatorPrecedence : _LogicalExpressionEmitter._operatorPrecedence["||"]);
};


function _ConditionalExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_ConditionalExpressionEmitter._operatorPrecedence = precedence;
};

_ConditionalExpressionEmitter._setOperatorPrecedence$SN = _ConditionalExpressionEmitter$_setOperatorPrecedence$SN;

function _CallExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_CallExpressionEmitter], _OperatorExpressionEmitter);
_CallExpressionEmitter.prototype._emit$ = function () {
	var calleeExpr;
	var resolveIfNullable$this$0;
	var getArgumentTypes$this$0;
	var _expr$0;
	if (_CallExpressionEmitter$_emitSpecial$L_CallExpressionEmitter$(this)) {
		return;
	}
	calleeExpr = this._expr._expr;
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, calleeExpr).emit$N(_CallExpressionEmitter._operatorPrecedence);
	JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, (_expr$0 = this._expr)._token, "(", _expr$0._args, (getArgumentTypes$this$0 = (resolveIfNullable$this$0 = _expr$0._expr.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0), getArgumentTypes$this$0._argTypes));
};


_CallExpressionEmitter.prototype._getPrecedence$ = function () {
	return _CallExpressionEmitter._operatorPrecedence;
};


function _CallExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_CallExpressionEmitter._operatorPrecedence = precedence;
};

_CallExpressionEmitter._setOperatorPrecedence$SN = _CallExpressionEmitter$_setOperatorPrecedence$SN;

_CallExpressionEmitter.prototype._emitSpecial$ = function () {
	var calleeExpr;
	calleeExpr = this._expr._expr;
	return (! (calleeExpr instanceof PropertyExpression) ? false : _CallExpressionEmitter$_emitIfJsInvoke$L_CallExpressionEmitter$LPropertyExpression$(this, calleeExpr) ? true : _CallExpressionEmitter$_emitIfJsEval$L_CallExpressionEmitter$LPropertyExpression$(this, calleeExpr) ? true : _CallExpressionEmitter$_emitCallsToMap$L_CallExpressionEmitter$LPropertyExpression$(this, calleeExpr) ? true : false);
};


function _CallExpressionEmitter$_emitSpecial$L_CallExpressionEmitter$($this) {
	var calleeExpr;
	calleeExpr = $this._expr._expr;
	return (! (calleeExpr instanceof PropertyExpression) ? false : _CallExpressionEmitter$_emitIfJsInvoke$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) ? true : _CallExpressionEmitter$_emitIfJsEval$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) ? true : _CallExpressionEmitter$_emitCallsToMap$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) ? true : false);
};

_CallExpressionEmitter._emitSpecial$L_CallExpressionEmitter$ = _CallExpressionEmitter$_emitSpecial$L_CallExpressionEmitter$;

_CallExpressionEmitter.prototype._emitIfJsEval$LPropertyExpression$ = function (calleeExpr) {
	var classDef;
	var args;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if (calleeExpr._identifierToken._value !== "eval") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$(this._emitter, classDef)) {
		return false;
	}
	args = this._expr._args;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "eval(", calleeExpr._token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[0]).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", calleeExpr._token);
	return true;
};


function _CallExpressionEmitter$_emitIfJsEval$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) {
	var classDef;
	var args;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if (calleeExpr._identifierToken._value !== "eval") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$($this._emitter, classDef)) {
		return false;
	}
	args = $this._expr._args;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "eval(", calleeExpr._token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[0]).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ")", calleeExpr._token);
	return true;
};

_CallExpressionEmitter._emitIfJsEval$L_CallExpressionEmitter$LPropertyExpression$ = _CallExpressionEmitter$_emitIfJsEval$L_CallExpressionEmitter$LPropertyExpression$;

_CallExpressionEmitter.prototype._emitIfJsInvoke$LPropertyExpression$ = function (calleeExpr) {
	var classDef;
	var args;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if (calleeExpr._identifierToken._value !== "invoke") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$(this._emitter, classDef)) {
		return false;
	}
	args = this._expr._args;
	if (args[2] instanceof ArrayLiteralExpression) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[0]).emit$N(_PropertyExpressionEmitter._operatorPrecedence);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "[", calleeExpr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[1]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "]", calleeExpr._token);
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, this._expr._token, "(", args[2]._exprs, null);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "(function (o, p, a) { return o[p].apply(o, a); }(", calleeExpr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[0]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", this._expr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[1]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", this._expr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[2]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "))", this._expr._token);
	}
	return true;
};


function _CallExpressionEmitter$_emitIfJsInvoke$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) {
	var classDef;
	var args;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if (calleeExpr._identifierToken._value !== "invoke") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$($this._emitter, classDef)) {
		return false;
	}
	args = $this._expr._args;
	if (args[2] instanceof ArrayLiteralExpression) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[0]).emit$N(_PropertyExpressionEmitter._operatorPrecedence);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "[", calleeExpr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[1]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "]", calleeExpr._token);
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$($this._emitter, $this._expr._token, "(", args[2]._exprs, null);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "(function (o, p, a) { return o[p].apply(o, a); }(", calleeExpr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[0]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", $this._expr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[1]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", $this._expr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[2]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "))", $this._expr._token);
	}
	return true;
};

_CallExpressionEmitter._emitIfJsInvoke$L_CallExpressionEmitter$LPropertyExpression$ = _CallExpressionEmitter$_emitIfJsInvoke$L_CallExpressionEmitter$LPropertyExpression$;

_CallExpressionEmitter.prototype._emitCallsToMap$LPropertyExpression$ = function (calleeExpr) {
	var classDef;
	if (calleeExpr._type instanceof StaticFunctionType) {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! (classDef instanceof InstantiatedClassDefinition)) {
		return false;
	}
	if (classDef._templateClassDef._className !== "Map") {
		return false;
	}
	switch (calleeExpr._identifierToken._value) {
	case "toString":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, calleeExpr._token, "$__jsx_ObjectToString.call(", [ calleeExpr._expr ], [ new ObjectType(classDef) ]);
		return true;
	case "hasOwnProperty":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, calleeExpr._token, "$__jsx_ObjectHasOwnProperty.call(", [ calleeExpr._expr, this._expr._args[0] ], [ new ObjectType(classDef), Type.stringType ]);
		return true;
	case "keys":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, calleeExpr._token, "Object.keys(", [ calleeExpr._expr ], [ new ObjectType(classDef) ]);
		return true;
	default:
		return false;
	}
};


function _CallExpressionEmitter$_emitCallsToMap$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) {
	var classDef;
	if (calleeExpr._type instanceof StaticFunctionType) {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! (classDef instanceof InstantiatedClassDefinition)) {
		return false;
	}
	if (classDef._templateClassDef._className !== "Map") {
		return false;
	}
	switch (calleeExpr._identifierToken._value) {
	case "toString":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$($this._emitter, calleeExpr._token, "$__jsx_ObjectToString.call(", [ calleeExpr._expr ], [ new ObjectType(classDef) ]);
		return true;
	case "hasOwnProperty":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$($this._emitter, calleeExpr._token, "$__jsx_ObjectHasOwnProperty.call(", [ calleeExpr._expr, $this._expr._args[0] ], [ new ObjectType(classDef), Type.stringType ]);
		return true;
	case "keys":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$($this._emitter, calleeExpr._token, "Object.keys(", [ calleeExpr._expr ], [ new ObjectType(classDef) ]);
		return true;
	default:
		return false;
	}
};

_CallExpressionEmitter._emitCallsToMap$L_CallExpressionEmitter$LPropertyExpression$ = _CallExpressionEmitter$_emitCallsToMap$L_CallExpressionEmitter$LPropertyExpression$;

function _SuperExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_SuperExpressionEmitter], _OperatorExpressionEmitter);
_SuperExpressionEmitter.prototype._emit$ = function () {
	var funcType;
	var classDef;
	var methodName;
	var argTypes;
	var mangledFuncName;
	var this$0;
	var _emitter$0;
	funcType = this._expr._funcType;
	classDef = funcType._objectType.getClassDef$();
	this$0 = this._expr._name;
	methodName = this$0._value;
	argTypes = funcType._argTypes;
	mangledFuncName = this._emitter._namer.getNameOfMethod$LClassDefinition$SALType$(classDef, methodName, argTypes);
	JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(_emitter$0 = this._emitter, this._expr._token, _emitter$0._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype." + mangledFuncName + ".call(this", this._expr._args, argTypes);
};


_SuperExpressionEmitter.prototype._getPrecedence$ = function () {
	return _CallExpressionEmitter._operatorPrecedence;
};


function _SuperExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_SuperExpressionEmitter._operatorPrecedence = precedence;
};

_SuperExpressionEmitter._setOperatorPrecedence$SN = _SuperExpressionEmitter$_setOperatorPrecedence$SN;

function _NewExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_NewExpressionEmitter], _OperatorExpressionEmitter);
_NewExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var $this = this;
	var getInliner;
	var classDef;
	var ctor;
	var argTypes;
	var callingFuncDef;
	var inliner;
	var _emitter$0;
	function getInliner(funcDef) {
		var stash;
		stash = funcDef.getStash$S("unclassify");
		return (stash ? stash.inliner : null);
	}
	classDef = this._expr._type.getClassDef$();
	ctor = this._expr._constructor;
	argTypes = ctor._argTypes;
	callingFuncDef = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, "constructor", argTypes, false);
	if (callingFuncDef == null) {
		throw new Error("logic flaw");
	}
	inliner = getInliner(callingFuncDef);
	if (inliner) {
		_NewExpressionEmitter$_emitAsObjectLiteral$L_NewExpressionEmitter$LClassDefinition$ALExpression$(this, classDef, inliner(this._expr));
	} else {
		if (classDef instanceof InstantiatedClassDefinition && classDef._templateClassDef._className === "Array" && argTypes.length === 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "[]", this._expr._token);
		} else {
			if (classDef instanceof InstantiatedClassDefinition && classDef._templateClassDef._className === "Map") {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "{}", this._expr._token);
			} else {
				JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(_emitter$0 = this._emitter, this._expr._token, "new " + _emitter$0._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, argTypes) + "(", this._expr._args, argTypes);
			}
		}
	}
};


_NewExpressionEmitter.prototype._emitAsObjectLiteral$LClassDefinition$ALExpression$ = function (classDef, propertyExprs) {
	var $this = this;
	var propertyIndex;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "({", this._expr._token);
	propertyIndex = 0;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (member) {
		var _emitter$0;
		if ((member._flags & 8) === 0) {
			if (propertyIndex !== 0) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", $this._expr._token);
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, _emitter$0._namer.getNameOfProperty$LClassDefinition$S(classDef, member._nameToken._value) + ": ", $this._expr._token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, propertyExprs[propertyIndex++]).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
		}
		return true;
	}));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "})", this._expr._token);
};


function _NewExpressionEmitter$_emitAsObjectLiteral$L_NewExpressionEmitter$LClassDefinition$ALExpression$($this, classDef, propertyExprs) {
	var propertyIndex;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "({", $this._expr._token);
	propertyIndex = 0;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (member) {
		var _emitter$0;
		if ((member._flags & 8) === 0) {
			if (propertyIndex !== 0) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", $this._expr._token);
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, _emitter$0._namer.getNameOfProperty$LClassDefinition$S(classDef, member._nameToken._value) + ": ", $this._expr._token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, propertyExprs[propertyIndex++]).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
		}
		return true;
	}));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "})", $this._expr._token);
};

_NewExpressionEmitter._emitAsObjectLiteral$L_NewExpressionEmitter$LClassDefinition$ALExpression$ = _NewExpressionEmitter$_emitAsObjectLiteral$L_NewExpressionEmitter$LClassDefinition$ALExpression$;

_NewExpressionEmitter.prototype._getPrecedence$ = function () {
	return _NewExpressionEmitter._operatorPrecedence;
};


function _NewExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_NewExpressionEmitter._operatorPrecedence = precedence;
};

_NewExpressionEmitter._setOperatorPrecedence$SN = _NewExpressionEmitter$_setOperatorPrecedence$SN;

function _CommaExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_CommaExpressionEmitter], _ExpressionEmitter);
_CommaExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var useBrackets;
	useBrackets = outerOpPrecedence !== _CommaExpressionEmitter._operatorPrecedence;
	if (useBrackets) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "(", null);
	}
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._expr1).emit$N(_CommaExpressionEmitter._operatorPrecedence);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", null);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, this._expr._expr2).emit$N(_CommaExpressionEmitter._operatorPrecedence);
	if (useBrackets) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", null);
	}
};


function _CommaExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_CommaExpressionEmitter._operatorPrecedence = precedence;
};

_CommaExpressionEmitter._setOperatorPrecedence$SN = _CommaExpressionEmitter$_setOperatorPrecedence$SN;

function _BootstrapBuilder() {
	this._emitter = null;
	this._entrySourceFile = "";
	this._executableFor = "";
};

$__jsx_extend([_BootstrapBuilder], Object);
_BootstrapBuilder.prototype.init$LJavaScriptEmitter$SS = function (emitter, entrySourceFile, executableFor) {
	this._emitter = emitter;
	this._entrySourceFile = entrySourceFile;
	this._executableFor = executableFor;
};


function _BootstrapBuilder$init$L_BootstrapBuilder$LJavaScriptEmitter$SS($this, emitter, entrySourceFile, executableFor) {
	$this._emitter = emitter;
	$this._entrySourceFile = entrySourceFile;
	$this._executableFor = executableFor;
};

_BootstrapBuilder.init$L_BootstrapBuilder$LJavaScriptEmitter$SS = _BootstrapBuilder$init$L_BootstrapBuilder$LJavaScriptEmitter$SS;

_BootstrapBuilder.prototype.addBootstrap$S = function (code) {
	var args;
	var callEntryPoint;
	var wrapper$0;
	var _platform$0;
	var _platform$1;
	code += (_platform$0 = this._emitter._platform).load$S(_platform$0.getRoot$() + "/src/js/launcher.js");
	switch (this._executableFor) {
	case "node":
		args = "process.argv.slice(2)";
		break;
	case "commonjs":
		args = "require('system').args.slice(1)";
		break;
	default:
		args = "[]";
		break;
	}
	callEntryPoint = Util$format$SAS("JSX.%1(%2, %3);", [ this._getLauncher$(), JSON.stringify(Platform$encodeFilename$LPlatform$S(this._emitter._platform, this._entrySourceFile)), args ]);
	if (this._executableFor === "web") {
		wrapper$0 = (_platform$1 = this._emitter._platform).load$S(_platform$1.getRoot$() + "/src/js/web-launcher.js");
		callEntryPoint = wrapper$0.replace(/\/\/--CODE--\/\//, callEntryPoint);
	}
	return code + callEntryPoint + "\n";
};


function _BootstrapBuilder$addBootstrap$L_BootstrapBuilder$S($this, code) {
	var args;
	var callEntryPoint;
	var wrapper$0;
	var _platform$0;
	var _platform$1;
	code += (_platform$0 = $this._emitter._platform).load$S(_platform$0.getRoot$() + "/src/js/launcher.js");
	switch ($this._executableFor) {
	case "node":
		args = "process.argv.slice(2)";
		break;
	case "commonjs":
		args = "require('system').args.slice(1)";
		break;
	default:
		args = "[]";
		break;
	}
	callEntryPoint = Util$format$SAS("JSX.%1(%2, %3);", [ $this._getLauncher$(), JSON.stringify(Platform$encodeFilename$LPlatform$S($this._emitter._platform, $this._entrySourceFile)), args ]);
	if ($this._executableFor === "web") {
		wrapper$0 = (_platform$1 = $this._emitter._platform).load$S(_platform$1.getRoot$() + "/src/js/web-launcher.js");
		callEntryPoint = wrapper$0.replace(/\/\/--CODE--\/\//, callEntryPoint);
	}
	return code + callEntryPoint + "\n";
};

_BootstrapBuilder.addBootstrap$L_BootstrapBuilder$S = _BootstrapBuilder$addBootstrap$L_BootstrapBuilder$S;

_BootstrapBuilder.prototype._wrapOnLoad$S = function (code) {
	var wrapper;
	var _platform$0;
	wrapper = (_platform$0 = this._emitter._platform).load$S(_platform$0.getRoot$() + "/src/js/web-launcher.js");
	return wrapper.replace(/\/\/--CODE--\/\//, code);
};


function _BootstrapBuilder$_wrapOnLoad$L_BootstrapBuilder$S($this, code) {
	var wrapper;
	var _platform$0;
	wrapper = (_platform$0 = $this._emitter._platform).load$S(_platform$0.getRoot$() + "/src/js/web-launcher.js");
	return wrapper.replace(/\/\/--CODE--\/\//, code);
};

_BootstrapBuilder._wrapOnLoad$L_BootstrapBuilder$S = _BootstrapBuilder$_wrapOnLoad$L_BootstrapBuilder$S;

function _ExecutableBootstrapBuilder() {
	this._emitter = null;
	this._entrySourceFile = "";
	this._executableFor = "";
};

$__jsx_extend([_ExecutableBootstrapBuilder], _BootstrapBuilder);
_ExecutableBootstrapBuilder.prototype._getLauncher$ = function () {
	return "runMain";
};


function _TestBootstrapBuilder() {
	this._emitter = null;
	this._entrySourceFile = "";
	this._executableFor = "";
};

$__jsx_extend([_TestBootstrapBuilder], _BootstrapBuilder);
_TestBootstrapBuilder.prototype._getLauncher$ = function () {
	return "runTests";
};


function Util() {
};

$__jsx_extend([Util], Object);
function Util$repeat$SN(c, n) {
	var s;
	var i;
	s = "";
	for (i = 0; i < n; ++ i) {
		s += c;
	}
	return s;
};

Util.repeat$SN = Util$repeat$SN;

function Util$format$SAS(fmt, args) {
	return fmt.replace(/%(\d+|%)/g, (function (m) {
		var arg;
		if (m === "%%") {
			return "%";
		} else {
			arg = args[(m.substring(1) | 0) - 1];
			return (arg == null ? "null" : arg);
		}
	}));
};

Util.format$SAS = Util$format$SAS;

function Util$isBuiltInContainer$LType$(type) {
	var classDef;
	var className;
	if (type instanceof ObjectType) {
		classDef = type._classDef;
		if (classDef instanceof InstantiatedClassDefinition) {
			className = classDef._templateClassDef._className;
			return $__jsx_ObjectHasOwnProperty.call(Util._builtInContainer, className);
		} else {
			className = classDef.className$();
			return $__jsx_ObjectHasOwnProperty.call(Util._builtInContainer, className);
		}
	}
	return false;
};

Util.isBuiltInContainer$LType$ = Util$isBuiltInContainer$LType$;

function Util$instantiateTemplate$LAnalysisContext$LToken$SALType$(context, token, className, typeArguments) {
	return Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: token, _className: className, _typeArgs: typeArguments}), context.postInstantiationCallback);
};

Util.instantiateTemplate$LAnalysisContext$LToken$SALType$ = Util$instantiateTemplate$LAnalysisContext$LToken$SALType$;

function Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$AALType$(context, args, parentExpr, expectedTypes) {
	var argTypes;
	var i;
	var funcDef;
	var expectedCallbackType;
	var j;
	var arrayExpr;
	var expectedArrayType;
	var mapExpr;
	var expectedMapType;
	var getTemplateClassName$this$0;
	var getTemplateClassName$this$1;
	var expectedTypes$len$0;
	argTypes = [  ];
	for (i = 0; i < args.length; ++ i) {
		if (args[i] instanceof FunctionExpression && ! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(args[i])) {
			funcDef = args[i]._funcDef;
			expectedCallbackType = null;
			for ((j = 0, expectedTypes$len$0 = expectedTypes.length); j < expectedTypes$len$0; ++ j) {
				if (expectedTypes[j][i] != null && expectedTypes[j][i] instanceof FunctionType && expectedTypes[j][i]._argTypes.length === funcDef._args.length) {
					if (expectedCallbackType == null) {
						expectedCallbackType = expectedTypes[j][i];
					} else {
						if (Util$typesAreEqual$ALType$ALType$(expectedCallbackType._argTypes, expectedTypes[j][i]._argTypes) && expectedCallbackType._returnType.equals$LType$(expectedTypes[j][i]._returnType)) {
						} else {
							break;
						}
					}
				}
			}
			if (j !== expectedTypes.length) {
			} else {
				if (expectedCallbackType != null) {
					if (! (! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$(args[i]._funcDef, context, expectedCallbackType) ? false : true)) {
						return null;
					}
				}
			}
		} else {
			if (args[i] instanceof ArrayLiteralExpression && args[i]._exprs.length === 0 && args[i]._type == null) {
				arrayExpr = args[i];
				expectedArrayType = null;
				for (j = 0; j < expectedTypes.length; ++ j) {
					if (expectedTypes[j][i] != null && expectedTypes[j][i] instanceof ObjectType && expectedTypes[j][i].getClassDef$() instanceof InstantiatedClassDefinition && (getTemplateClassName$this$0 = expectedTypes[j][i].getClassDef$(), getTemplateClassName$this$0._templateClassDef._className) === 'Array') {
						if (expectedArrayType == null) {
							expectedArrayType = expectedTypes[j][i];
						} else {
							if (expectedArrayType.equals$LType$(expectedTypes[j][i])) {
							} else {
								break;
							}
						}
					}
				}
				if (j !== expectedTypes.length) {
				} else {
					if (expectedArrayType != null) {
						arrayExpr._type = expectedArrayType;
					}
				}
			} else {
				if (args[i] instanceof MapLiteralExpression && args[i]._elements.length === 0 && args[i]._type == null) {
					mapExpr = args[i];
					expectedMapType = null;
					for (j = 0; j < expectedTypes.length; ++ j) {
						if (expectedTypes[j][i] != null && expectedTypes[j][i] instanceof ObjectType && expectedTypes[j][i].getClassDef$() instanceof InstantiatedClassDefinition && (getTemplateClassName$this$1 = expectedTypes[j][i].getClassDef$(), getTemplateClassName$this$1._templateClassDef._className) === 'Map') {
							if (expectedMapType == null) {
								expectedMapType = expectedTypes[j][i];
							} else {
								if (expectedMapType.equals$LType$(expectedTypes[j][i])) {
								} else {
									break;
								}
							}
						}
					}
					if (j !== expectedTypes.length) {
					} else {
						if (expectedMapType != null) {
							mapExpr._type = expectedMapType;
						}
					}
				}
			}
		}
		if (! args[i].analyze$LAnalysisContext$LExpression$(context, parentExpr)) {
			return null;
		}
		argTypes[i] = args[i].getType$();
	}
	return argTypes;
};

Util.analyzeArgs$LAnalysisContext$ALExpression$LExpression$AALType$ = Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$AALType$;

function Util$typesAreEqual$ALType$ALType$(x, y) {
	var i;
	var x$len$0;
	if (x.length !== y.length) {
		return false;
	}
	for ((i = 0, x$len$0 = x.length); i < x$len$0; ++ i) {
		if (! x[i].equals$LType$(y[i])) {
			return false;
		}
	}
	return true;
};

Util.typesAreEqual$ALType$ALType$ = Util$typesAreEqual$ALType$ALType$;

function Util$forEachStatement$F$LStatement$B$ALStatement$(cb, statements) {
	var i;
	var statements$len$0;
	if (statements != null) {
		for ((i = 0, statements$len$0 = statements.length); i < statements$len$0; ++ i) {
			if (! cb(statements[i])) {
				return false;
			}
		}
	}
	return true;
};

Util.forEachStatement$F$LStatement$B$ALStatement$ = Util$forEachStatement$F$LStatement$B$ALStatement$;

function Util$forEachExpression$F$LExpression$B$ALExpression$(cb, exprs) {
	return Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$((function (expr, _) {
		return cb(expr);
	}), exprs);
};

Util.forEachExpression$F$LExpression$B$ALExpression$ = Util$forEachExpression$F$LExpression$B$ALExpression$;

function Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, exprs) {
	var i;
	var exprs$len$0;
	if (exprs != null) {
		for ((i = 0, exprs$len$0 = exprs.length); i < exprs$len$0; ++ i) {
			if (! cb(exprs[i], (function (exprs, index) {
				return (function (expr) {
					exprs[index] = expr;
				});
			})(exprs, i))) {
				return false;
			}
		}
	}
	return true;
};

Util.forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$ = Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$;

function Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, funcName, argTypes, isStatic) {
	var found;
	found = null;
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
		if (isStatic === ((funcDef._flags & 8) !== 0) && funcDef._nameToken._value === funcName && Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), argTypes)) {
			found = funcDef;
			return false;
		}
		return true;
	}));
	return found;
};

Util.findFunctionInClass$LClassDefinition$SALType$B = Util$findFunctionInClass$LClassDefinition$SALType$B;

function Util$findVariableInClass$LClassDefinition$SB(classDef, name, isStatic) {
	var found;
	found = null;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (def) {
		if (isStatic === ((def._flags & 8) !== 0) && def._nameToken._value === name) {
			found = def;
			return false;
		}
		return true;
	}));
	return found;
};

Util.findVariableInClass$LClassDefinition$SB = Util$findVariableInClass$LClassDefinition$SB;

function Util$findMemberInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic) {
	return (argTypes != null ? Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic) : Util$findVariableInClass$LClassDefinition$SB(classDef, name, isStatic));
};

Util.findMemberInClass$LClassDefinition$SALType$B = Util$findMemberInClass$LClassDefinition$SALType$B;

function Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic) {
	var rootIsNativeNonStatic;
	if (isStatic) {
		return (classDef.flags$() & 272) !== 0;
	}
	function rootIsNativeNonStatic(classDef, name, argTypes) {
		var found;
		found = (argTypes != null ? Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, false) : Util$findVariableInClass$LClassDefinition$SB(classDef, name, false));
		return (found != null && (found._flags & 32) === 0 ? (classDef.flags$() & 272) !== 0 : classDef._extendType == null ? false : rootIsNativeNonStatic(classDef._extendType._classDef, name, argTypes));
	}
	return rootIsNativeNonStatic(classDef, name, argTypes);
};

Util.memberRootIsNative$LClassDefinition$SALType$B = Util$memberRootIsNative$LClassDefinition$SALType$B;

function Util$propertyRootIsNative$LPropertyExpression$(expr) {
	var baseExpr;
	baseExpr = expr._expr;
	return Util$memberRootIsNative$LClassDefinition$SALType$B(baseExpr.getType$().getClassDef$(), expr._identifierToken._value, Util$isReferringToFunctionDefinition$LPropertyExpression$(expr) ? expr._type._argTypes : null, baseExpr.isClassSpecifier$());
};

Util.propertyRootIsNative$LPropertyExpression$ = Util$propertyRootIsNative$LPropertyExpression$;

function Util$memberIsExported$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic) {
	var found;
	var check;
	if (isStatic) {
		found = (argTypes != null ? Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, true) : Util$findVariableInClass$LClassDefinition$SB(classDef, name, true));
		return (found._flags & 16384) !== 0;
	}
	function check(classDef) {
		var found;
		var isExportedInImpl;
		var this$0;
		var i$0;
		if ((classDef.flags$() & 16) !== 0) {
			return false;
		}
		found = (argTypes != null ? Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, false) : Util$findVariableInClass$LClassDefinition$SB(classDef, name, false));
		if (found != null && (found._flags & 16384) !== 0) {
			return true;
		}
		if (classDef._extendType != null) {
			if (check(classDef._extendType._classDef)) {
				return true;
			}
		}
		isExportedInImpl = false;
		this$0 = classDef._implementTypes;
		for (i$0 in this$0) {
			(function (implType) {
				if (check(implType._classDef)) {
					isExportedInImpl = true;
				}
			})(this$0[i$0]);
		}
		return isExportedInImpl;
	}
	return check(classDef);
};

Util.memberIsExported$LClassDefinition$SALType$B = Util$memberIsExported$LClassDefinition$SALType$B;

function Util$isReferringToFunctionDefinition$LPropertyExpression$(expr) {
	var exprType;
	exprType = expr._type;
	return (! (exprType instanceof FunctionType) ? false : exprType.isAssignable$() ? false : true);
};

Util.isReferringToFunctionDefinition$LPropertyExpression$ = Util$isReferringToFunctionDefinition$LPropertyExpression$;

function Util$encodeStringLiteral$S(str) {
	var escaped;
	escaped = str.replace(/[\0-\x19\\'"\u007f-\uffff]/g, (function (ch) {
		var t;
		if (ch in Util._stringLiteralEncodingMap) {
			return Util._stringLiteralEncodingMap[ch];
		} else {
			t = "000" + ch.charCodeAt(0).toString(16);
			t = t.substring(t.length - 4);
			return "\\u" + t;
		}
	}));
	return "\"" + escaped + "\"";
};

Util.encodeStringLiteral$S = Util$encodeStringLiteral$S;

function Util$decodeStringLiteral$S(literal) {
	var matched;
	var src;
	var decoded;
	var pos;
	var backslashAt;
	var escapeChar;
	matched = literal.match(/^([\'\"]).*([\'\"])$/);
	if (matched == null || matched[1] !== matched[2]) {
		throw new Error("input string is not quoted properly: " + literal);
	}
	src = literal.substring(1, literal.length - 1);
	decoded = "";
	pos = 0;
	while ((backslashAt = src.indexOf("\\", pos)) !== -1) {
		decoded += src.substring(pos, backslashAt);
		pos = backslashAt + 1;
		if (pos === src.length) {
			throw new Error("last character within a string literal cannot be a backslash: " + literal);
		}
		escapeChar = src.charAt(pos++);
		switch (escapeChar) {
		case "'":
		case "\"":
		case "\\":
			decoded += escapeChar;
			break;
		case "b":
			decoded += "\b";
			break;
		case "f":
			decoded += "\f";
			break;
		case "n":
			decoded += "\n";
			break;
		case "r":
			decoded += "\r";
			break;
		case "t":
			decoded += "\t";
			break;
		case "v":
			decoded += "\v";
			break;
		case "u":
			matched = src.substring(pos).match(/^([0-9A-Fa-f]{4})/);
			if (matched == null) {
				throw new Error("expected four hexdigits after \\u: " + literal);
			}
			decoded += String.fromCharCode($__jsx_parseInt(matched[1], 16));
			pos += 4;
			break;
		case "x":
			matched = src.substring(pos).match(/^([0-9A-Fa-f]{2})/);
			if (matched == null) {
				throw new Error("expected two hexdigits after \\x: " + literal);
			}
			decoded += String.fromCharCode($__jsx_parseInt(matched[1], 16));
			pos += 2;
			break;
		case "0":
			if (pos === src.length || src.charAt(pos).match(/[0-9]/) == null) {
				decoded += "\0";
			} else {
				throw new Error("found a digit after '\\0': " + literal);
			}
			break;
		}
	}
	decoded += src.substring(pos);
	return decoded;
};

Util.decodeStringLiteral$S = Util$decodeStringLiteral$S;

function Util$_resolvedPathParts$S(path) {
	var tokens;
	var i;
	tokens = path.split(/[\\\/]+/);
	if (tokens.length === 1) {
		return tokens;
	}
	for (i = 0; i < tokens.length; ) {
		if (tokens[i] === ".") {
			tokens.splice(i, 1);
		} else {
			if (tokens[i] === ".." && i !== 0 && tokens[i - 1] !== "..") {
				tokens.splice(i - 1, 2);
				i -= 1;
			} else {
				i++;
			}
		}
	}
	return tokens;
};

Util._resolvedPathParts$S = Util$_resolvedPathParts$S;

function Util$resolvePath$S(path) {
	return Util$_resolvedPathParts$S(path).join("/");
};

Util.resolvePath$S = Util$resolvePath$S;

function Util$relativePath$SSB(fromPath, toPath, isFile) {
	var f;
	var t;
	var minLen;
	var samePartsIndex;
	var i;
	var pathParts;
	var value1$0;
	var value2$0;
	f = Util$_resolvedPathParts$S(fromPath);
	t = Util$_resolvedPathParts$S(toPath);
	if (isFile) {
		f.pop();
	}
	if (f[0] === "") {
		f.shift();
	}
	if (t[0] === "") {
		t.shift();
	}
	value1$0 = f.length;
	value2$0 = t.length;
	minLen = (value1$0 <= value2$0 ? value1$0 : value2$0);
	samePartsIndex = minLen;
	for (i = 0; i < minLen; ++ i) {
		if (f[i] !== t[i]) {
			samePartsIndex = i;
			break;
		}
	}
	pathParts = [];
	for (i = samePartsIndex; i < f.length; ++ i) {
		pathParts.push("..");
	}
	return pathParts.concat(t.slice(samePartsIndex)).join("/");
};

Util.relativePath$SSB = Util$relativePath$SSB;

function Util$basename$S(path) {
	var parts;
	parts = Util$_resolvedPathParts$S(path);
	return parts.pop();
};

Util.basename$S = Util$basename$S;

function Util$dirname$S(path) {
	var parts;
	parts = Util$_resolvedPathParts$S(path);
	parts.pop();
	return (parts.length !== 0 ? parts.join("/") : ".");
};

Util.dirname$S = Util$dirname$S;

function Util$toOrdinal$N(n) {
	if (10 < n && n < 14) {
		return (n + "") + 'th';
	}
	switch (n % 10) {
	case 1:
		return (n + "") + 'st';
	case 2:
		return (n + "") + 'nd';
	case 3:
		return (n + "") + 'rd';
	default:
		return (n + "") + 'th';
	}
};

Util.toOrdinal$N = Util$toOrdinal$N;

function Util$makeErrorMessage$LPlatform$SUSNNN(platform, message, filename, lineNumber, columnNumber, size) {
	var content;
	var sourceLine;
	var TAB_WIDTH;
	var tabs;
	if (filename == null) {
		return message + "\n";
	}
	content = platform.load$S(filename);
	sourceLine = content.split(/\n/)[lineNumber - 1] + "\n";
	TAB_WIDTH = 4;
	tabs = sourceLine.slice(0, columnNumber).match(/\t/g);
	if (tabs != null) {
		columnNumber += (TAB_WIDTH - 1) * tabs.length;
	}
	sourceLine = sourceLine.replace(/\t/g, Util$repeat$SN(" ", TAB_WIDTH));
	sourceLine += Util$repeat$SN(" ", columnNumber);
	sourceLine += Util$repeat$SN("^", size);
	return Util$format$SAS("[%1:%2:%3] %4\n%5\n", [ filename, lineNumber + "", columnNumber + "", message, sourceLine ]);
};

Util.makeErrorMessage$LPlatform$SUSNNN = Util$makeErrorMessage$LPlatform$SUSNNN;

function Util$isArrayOf$LClassDefinition$LType$(classDef, expectedElementType) {
	var instantiatedClassDef;
	if (! (classDef instanceof InstantiatedClassDefinition)) {
		return false;
	}
	instantiatedClassDef = classDef;
	return (instantiatedClassDef._templateClassDef._className !== "Array" ? false : ! instantiatedClassDef._typeArguments[0].equals$LType$(expectedElementType) ? false : true);
};

Util.isArrayOf$LClassDefinition$LType$ = Util$isArrayOf$LClassDefinition$LType$;

function Util$asSet$AS(array) {
	var set;
	var i;
	set = {};
	for (i = 0; i < array.length; ++ i) {
		set[array[i]] = true;
	}
	return set;
};

Util.asSet$AS = Util$asSet$AS;

function Util$isECMA262Reserved$S(word) {
	return $__jsx_ObjectHasOwnProperty.call(Util._ecma262reserved, word);
};

Util.isECMA262Reserved$S = Util$isECMA262Reserved$S;

function Util$getECMA262ReservedWords$() {
	return Object.keys(Util._ecma262reserved);
};

Util.getECMA262ReservedWords$ = Util$getECMA262ReservedWords$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E() {
	var $this = this;
	this._list = [];
	this._equalsCallback = (function (x, y) {
		return x == y;
	});
};

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$0(equalsCallback) {
	this._list = [];
	this._equalsCallback = equalsCallback;
};

$__jsx_extend([TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E, TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$0], Object);
function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$($this) {
	var x;
	x = ({_list: [], _equalsCallback: $this._equalsCallback});
	x._list = $this._list.concat([  ]);
	return x;
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.clone$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$($this, key) {
	return ! TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$($this, (function (entryKey, entryValue) {
		return ! $this._equalsCallback(key, entryKey);
	}));
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.has$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B($this, key, val) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list[i].second = val;
			return;
		}
	}
	$this._list.push(({first: key, second: val}));
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			return $this._list[i].second;
		}
	}
	return null;
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list.splice(i, 1);
			return;
		}
	}
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.delete$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$($this) {
	var _list$0;
	(_list$0 = $this._list).splice(0, _list$0.length);
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.clear$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$($this, cb) {
	var i;
	var e;
	for (i = 0; i < $this._list.length; ++ i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.forEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$($this, cb) {
	var i;
	var e;
	for (i = $this._list.length - 1; i >= 0; -- i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$;

function Pair$x2E$x3CLocalVariable$x2Cboolean$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CLocalVariable$x2Cboolean$x3E], Object);
function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E() {
	var $this = this;
	this._list = [];
	this._equalsCallback = (function (x, y) {
		return x == y;
	});
};

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$0(equalsCallback) {
	this._list = [];
	this._equalsCallback = equalsCallback;
};

$__jsx_extend([TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E, TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$0], Object);
function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$($this) {
	var x;
	x = ({_list: [], _equalsCallback: $this._equalsCallback});
	x._list = $this._list.concat([  ]);
	return x;
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.clone$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$($this, key) {
	return ! TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$($this, (function (entryKey, entryValue) {
		return ! $this._equalsCallback(key, entryKey);
	}));
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.has$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$($this, key, val) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list[i].second = val;
			return;
		}
	}
	$this._list.push(({first: key, second: val}));
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			return $this._list[i].second;
		}
	}
	return null;
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.get$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list.splice(i, 1);
			return;
		}
	}
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$($this) {
	var _list$0;
	(_list$0 = $this._list).splice(0, _list$0.length);
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.clear$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$($this, cb) {
	var i;
	var e;
	for (i = 0; i < $this._list.length; ++ i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.forEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$($this, cb) {
	var i;
	var e;
	for (i = $this._list.length - 1; i >= 0; -- i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$;

function Pair$x2E$x3CLocalVariable$x2CExpression$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CLocalVariable$x2CExpression$x3E], Object);
function Pair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E], Object);
function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E() {
	var $this = this;
	this._list = [];
	this._equalsCallback = (function (x, y) {
		return x == y;
	});
};

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$0(equalsCallback) {
	this._list = [];
	this._equalsCallback = equalsCallback;
};

$__jsx_extend([TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E, TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$0], Object);
function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$($this) {
	var x;
	x = ({_list: [], _equalsCallback: $this._equalsCallback});
	x._list = $this._list.concat([  ]);
	return x;
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.clone$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$($this, key) {
	return ! TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$($this, (function (entryKey, entryValue) {
		return ! $this._equalsCallback(key, entryKey);
	}));
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.has$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$($this, key, val) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list[i].second = val;
			return;
		}
	}
	$this._list.push(({first: key, second: val}));
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.set$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			return $this._list[i].second;
		}
	}
	return null;
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.get$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list.splice(i, 1);
			return;
		}
	}
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.delete$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$($this) {
	var _list$0;
	(_list$0 = $this._list).splice(0, _list$0.length);
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.clear$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$($this, cb) {
	var i;
	var e;
	for (i = 0; i < $this._list.length; ++ i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.forEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$($this, cb) {
	var i;
	var e;
	for (i = $this._list.length - 1; i >= 0; -- i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$;

function Pair$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E], Object);
function Serializer$x2E$x3CType$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CType$x3E], Object);
function Serializer$x2E$x3CType$x3E$serializeArray$ALType$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		ret[i] = a[i].toString();
	}
	return ret;
};

Serializer$x2E$x3CType$x3E.serializeArray$ALType$ = Serializer$x2E$x3CType$x3E$serializeArray$ALType$;

function Serializer$x2E$x3CType$x3E$serializeNullable$LType$(v) {
	return (v == null ? null : v.toString());
};

Serializer$x2E$x3CType$x3E.serializeNullable$LType$ = Serializer$x2E$x3CType$x3E$serializeNullable$LType$;

function Serializer$x2E$x3CToken$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CToken$x3E], Object);
function Serializer$x2E$x3CToken$x3E$serializeArray$ALToken$(a) {
	var ret;
	var i;
	var this$0;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		this$0 = a[i];
		ret[i] = [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ];
	}
	return ret;
};

Serializer$x2E$x3CToken$x3E.serializeArray$ALToken$ = Serializer$x2E$x3CToken$x3E$serializeArray$ALToken$;

function Serializer$x2E$x3CToken$x3E$serializeNullable$LToken$(v) {
	return (v == null ? null : [ v._value, v._isIdentifier, v._filename, v._lineNumber, v._columnNumber ]);
};

Serializer$x2E$x3CToken$x3E.serializeNullable$LToken$ = Serializer$x2E$x3CToken$x3E$serializeNullable$LToken$;

function Serializer$x2E$x3CImport$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CImport$x3E], Object);
function Serializer$x2E$x3CImport$x3E$serializeArray$ALImport$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		ret[i] = Import$serialize$LImport$(a[i]);
	}
	return ret;
};

Serializer$x2E$x3CImport$x3E.serializeArray$ALImport$ = Serializer$x2E$x3CImport$x3E$serializeArray$ALImport$;

function Serializer$x2E$x3CImport$x3E$serializeNullable$LImport$(v) {
	return (v == null ? null : Import$serialize$LImport$(v));
};

Serializer$x2E$x3CImport$x3E.serializeNullable$LImport$ = Serializer$x2E$x3CImport$x3E$serializeNullable$LImport$;

function Serializer$x2E$x3CParsedObjectType$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CParsedObjectType$x3E], Object);
function Serializer$x2E$x3CParsedObjectType$x3E$serializeArray$ALParsedObjectType$(a) {
	var ret;
	var i;
	var this$0;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		this$0 = a[i];
		ret[i] = (this$0._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(this$0._qualifiedName._token._value, this$0._typeArguments) : this$0._qualifiedName._token._value);
	}
	return ret;
};

Serializer$x2E$x3CParsedObjectType$x3E.serializeArray$ALParsedObjectType$ = Serializer$x2E$x3CParsedObjectType$x3E$serializeArray$ALParsedObjectType$;

function Serializer$x2E$x3CParsedObjectType$x3E$serializeNullable$LParsedObjectType$(v) {
	return (v == null ? null : v._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(v._qualifiedName._token._value, v._typeArguments) : v._qualifiedName._token._value);
};

Serializer$x2E$x3CParsedObjectType$x3E.serializeNullable$LParsedObjectType$ = Serializer$x2E$x3CParsedObjectType$x3E$serializeNullable$LParsedObjectType$;

function Serializer$x2E$x3CMemberDefinition$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CMemberDefinition$x3E], Object);
function Serializer$x2E$x3CMemberDefinition$x3E$serializeArray$ALMemberDefinition$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		ret[i] = a[i].serialize$();
	}
	return ret;
};

Serializer$x2E$x3CMemberDefinition$x3E.serializeArray$ALMemberDefinition$ = Serializer$x2E$x3CMemberDefinition$x3E$serializeArray$ALMemberDefinition$;

function Serializer$x2E$x3CMemberDefinition$x3E$serializeNullable$LMemberDefinition$(v) {
	return (v == null ? null : v.serialize$());
};

Serializer$x2E$x3CMemberDefinition$x3E.serializeNullable$LMemberDefinition$ = Serializer$x2E$x3CMemberDefinition$x3E$serializeNullable$LMemberDefinition$;

function Serializer$x2E$x3CExpression$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CExpression$x3E], Object);
function Serializer$x2E$x3CExpression$x3E$serializeArray$ALExpression$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		ret[i] = a[i].serialize$();
	}
	return ret;
};

Serializer$x2E$x3CExpression$x3E.serializeArray$ALExpression$ = Serializer$x2E$x3CExpression$x3E$serializeArray$ALExpression$;

function Serializer$x2E$x3CExpression$x3E$serializeNullable$LExpression$(v) {
	return (v == null ? null : v.serialize$());
};

Serializer$x2E$x3CExpression$x3E.serializeNullable$LExpression$ = Serializer$x2E$x3CExpression$x3E$serializeNullable$LExpression$;

function Cloner$x2E$x3CStatement$x3E() {
};

$__jsx_extend([Cloner$x2E$x3CStatement$x3E], Object);
function Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(a) {
	var r;
	var i;
	r = [  ];
	for (i = 0; i < a.length; ++ i) {
		r[i] = a[i].clone$();
	}
	return r;
};

Cloner$x2E$x3CStatement$x3E.cloneArray$ALStatement$ = Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$;

function Cloner$x2E$x3CStatement$x3E$cloneNullable$LStatement$(o) {
	return (o == null ? null : o.clone$());
};

Cloner$x2E$x3CStatement$x3E.cloneNullable$LStatement$ = Cloner$x2E$x3CStatement$x3E$cloneNullable$LStatement$;

function Serializer$x2E$x3CArgumentDeclaration$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CArgumentDeclaration$x3E], Object);
function Serializer$x2E$x3CArgumentDeclaration$x3E$serializeArray$ALArgumentDeclaration$(a) {
	var ret;
	var i;
	var this$0;
	var serializeNullable$v$0$0;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		this$0 = a[i];
		ret[i] = [ this$0._name, (serializeNullable$v$0$0 = this$0._type, serializeNullable$v$0$0 == null ? null : serializeNullable$v$0$0.toString()) ];
	}
	return ret;
};

Serializer$x2E$x3CArgumentDeclaration$x3E.serializeArray$ALArgumentDeclaration$ = Serializer$x2E$x3CArgumentDeclaration$x3E$serializeArray$ALArgumentDeclaration$;

function Serializer$x2E$x3CArgumentDeclaration$x3E$serializeNullable$LArgumentDeclaration$(v) {
	return (v == null ? null : LocalVariable$serialize$LLocalVariable$(v));
};

Serializer$x2E$x3CArgumentDeclaration$x3E.serializeNullable$LArgumentDeclaration$ = Serializer$x2E$x3CArgumentDeclaration$x3E$serializeNullable$LArgumentDeclaration$;

function Serializer$x2E$x3CLocalVariable$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CLocalVariable$x3E], Object);
function Serializer$x2E$x3CLocalVariable$x3E$serializeArray$ALLocalVariable$(a) {
	var ret;
	var i;
	var this$0;
	var serializeNullable$v$0$0;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		this$0 = a[i];
		ret[i] = [ this$0._name, (serializeNullable$v$0$0 = this$0._type, serializeNullable$v$0$0 == null ? null : serializeNullable$v$0$0.toString()) ];
	}
	return ret;
};

Serializer$x2E$x3CLocalVariable$x3E.serializeArray$ALLocalVariable$ = Serializer$x2E$x3CLocalVariable$x3E$serializeArray$ALLocalVariable$;

function Serializer$x2E$x3CLocalVariable$x3E$serializeNullable$LLocalVariable$(v) {
	return (v == null ? null : LocalVariable$serialize$LLocalVariable$(v));
};

Serializer$x2E$x3CLocalVariable$x3E.serializeNullable$LLocalVariable$ = Serializer$x2E$x3CLocalVariable$x3E$serializeNullable$LLocalVariable$;

function Serializer$x2E$x3CStatement$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CStatement$x3E], Object);
function Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		ret[i] = a[i].serialize$();
	}
	return ret;
};

Serializer$x2E$x3CStatement$x3E.serializeArray$ALStatement$ = Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$;

function Serializer$x2E$x3CStatement$x3E$serializeNullable$LStatement$(v) {
	return (v == null ? null : v.serialize$());
};

Serializer$x2E$x3CStatement$x3E.serializeNullable$LStatement$ = Serializer$x2E$x3CStatement$x3E$serializeNullable$LStatement$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E() {
	var $this = this;
	this._list = [];
	this._equalsCallback = (function (x, y) {
		return x == y;
	});
};

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$0(equalsCallback) {
	this._list = [];
	this._equalsCallback = equalsCallback;
};

$__jsx_extend([TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E, TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$0], Object);
function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$clone$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$($this) {
	var x;
	x = ({_list: [], _equalsCallback: $this._equalsCallback});
	x._list = $this._list.concat([  ]);
	return x;
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.clone$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$clone$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$has$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$($this, key) {
	return ! TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$forEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$($this, (function (entryKey, entryValue) {
		return ! $this._equalsCallback(key, entryKey);
	}));
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.has$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$has$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$set$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$LMemberFunctionDefinition$($this, key, val) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list[i].second = val;
			return;
		}
	}
	$this._list.push(({first: key, second: val}));
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.set$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$LMemberFunctionDefinition$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$set$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$LMemberFunctionDefinition$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$get$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			return $this._list[i].second;
		}
	}
	return null;
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.get$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$get$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$delete$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list.splice(i, 1);
			return;
		}
	}
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.delete$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$delete$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$clear$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$($this) {
	var _list$0;
	(_list$0 = $this._list).splice(0, _list$0.length);
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.clear$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$clear$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$forEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$($this, cb) {
	var i;
	var e;
	for (i = 0; i < $this._list.length; ++ i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.forEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$forEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$reversedForEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$($this, cb) {
	var i;
	var e;
	for (i = $this._list.length - 1; i >= 0; -- i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.reversedForEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$reversedForEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$;

function Pair$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E], Object);
function Cloner$x2E$x3CExpression$x3E() {
};

$__jsx_extend([Cloner$x2E$x3CExpression$x3E], Object);
function Cloner$x2E$x3CExpression$x3E$cloneArray$ALExpression$(a) {
	var r;
	var i;
	r = [  ];
	for (i = 0; i < a.length; ++ i) {
		r[i] = a[i].clone$();
	}
	return r;
};

Cloner$x2E$x3CExpression$x3E.cloneArray$ALExpression$ = Cloner$x2E$x3CExpression$x3E$cloneArray$ALExpression$;

function Cloner$x2E$x3CExpression$x3E$cloneNullable$LExpression$(o) {
	return (o == null ? null : o.clone$());
};

Cloner$x2E$x3CExpression$x3E.cloneNullable$LExpression$ = Cloner$x2E$x3CExpression$x3E$cloneNullable$LExpression$;

function Serializer$x2E$x3CMapLiteralElement$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CMapLiteralElement$x3E], Object);
function Serializer$x2E$x3CMapLiteralElement$x3E$serializeArray$ALMapLiteralElement$(a) {
	var ret;
	var i;
	var this$0;
	var serialize$this$0$0;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		this$0 = a[i];
		ret[i] = [ (serialize$this$0$0 = this$0._key, [ serialize$this$0$0._value, serialize$this$0$0._isIdentifier, serialize$this$0$0._filename, serialize$this$0$0._lineNumber, serialize$this$0$0._columnNumber ]), this$0._expr.serialize$() ];
	}
	return ret;
};

Serializer$x2E$x3CMapLiteralElement$x3E.serializeArray$ALMapLiteralElement$ = Serializer$x2E$x3CMapLiteralElement$x3E$serializeArray$ALMapLiteralElement$;

function Serializer$x2E$x3CMapLiteralElement$x3E$serializeNullable$LMapLiteralElement$(v) {
	return (v == null ? null : MapLiteralElement$serialize$LMapLiteralElement$(v));
};

Serializer$x2E$x3CMapLiteralElement$x3E.serializeNullable$LMapLiteralElement$ = Serializer$x2E$x3CMapLiteralElement$x3E$serializeNullable$LMapLiteralElement$;

function Serializer$x2E$x3CClassDefinition$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CClassDefinition$x3E], Object);
function Serializer$x2E$x3CClassDefinition$x3E$serializeArray$ALClassDefinition$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		ret[i] = ClassDefinition$serialize$LClassDefinition$(a[i]);
	}
	return ret;
};

Serializer$x2E$x3CClassDefinition$x3E.serializeArray$ALClassDefinition$ = Serializer$x2E$x3CClassDefinition$x3E$serializeArray$ALClassDefinition$;

function Serializer$x2E$x3CClassDefinition$x3E$serializeNullable$LClassDefinition$(v) {
	return (v == null ? null : ClassDefinition$serialize$LClassDefinition$(v));
};

Serializer$x2E$x3CClassDefinition$x3E.serializeNullable$LClassDefinition$ = Serializer$x2E$x3CClassDefinition$x3E$serializeNullable$LClassDefinition$;

function Cloner$x2E$x3CCatchStatement$x3E() {
};

$__jsx_extend([Cloner$x2E$x3CCatchStatement$x3E], Object);
function Cloner$x2E$x3CCatchStatement$x3E$cloneArray$ALCatchStatement$(a) {
	var r;
	var i;
	var clone$this$0;
	r = [  ];
	for (i = 0; i < a.length; ++ i) {
		r[i] = (clone$this$0 = a[i], new CatchStatement(clone$this$0._token, clone$this$0._local, Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(clone$this$0._statements)));
	}
	return r;
};

Cloner$x2E$x3CCatchStatement$x3E.cloneArray$ALCatchStatement$ = Cloner$x2E$x3CCatchStatement$x3E$cloneArray$ALCatchStatement$;

function Cloner$x2E$x3CCatchStatement$x3E$cloneNullable$LCatchStatement$(o) {
	return (o == null ? null : new CatchStatement(o._token, o._local, Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(o._statements)));
};

Cloner$x2E$x3CCatchStatement$x3E.cloneNullable$LCatchStatement$ = Cloner$x2E$x3CCatchStatement$x3E$cloneNullable$LCatchStatement$;

function Serializer$x2E$x3CCatchStatement$x3E() {
};

$__jsx_extend([Serializer$x2E$x3CCatchStatement$x3E], Object);
function Serializer$x2E$x3CCatchStatement$x3E$serializeArray$ALCatchStatement$(a) {
	var ret;
	var i;
	var this$0;
	var serialize$this$0$0;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++ i) {
		this$0 = a[i];
		ret[i] = [ "CatchStatement", (serialize$this$0$0 = this$0._token, [ serialize$this$0$0._value, serialize$this$0$0._isIdentifier, serialize$this$0$0._filename, serialize$this$0$0._lineNumber, serialize$this$0$0._columnNumber ]), LocalVariable$serialize$LLocalVariable$(this$0._local), Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this$0._statements) ];
	}
	return ret;
};

Serializer$x2E$x3CCatchStatement$x3E.serializeArray$ALCatchStatement$ = Serializer$x2E$x3CCatchStatement$x3E$serializeArray$ALCatchStatement$;

function Serializer$x2E$x3CCatchStatement$x3E$serializeNullable$LCatchStatement$(v) {
	return (v == null ? null : v.serialize$());
};

Serializer$x2E$x3CCatchStatement$x3E.serializeNullable$LCatchStatement$ = Serializer$x2E$x3CCatchStatement$x3E$serializeNullable$LCatchStatement$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E() {
	var $this = this;
	this._list = [];
	this._equalsCallback = (function (x, y) {
		return x == y;
	});
};

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$0(equalsCallback) {
	this._list = [];
	this._equalsCallback = equalsCallback;
};

$__jsx_extend([TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E, TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$0], Object);
function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$clone$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$($this) {
	var x;
	x = ({_list: [], _equalsCallback: $this._equalsCallback});
	x._list = $this._list.concat([  ]);
	return x;
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.clone$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$clone$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$has$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$($this, key) {
	return ! TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$forEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$($this, (function (entryKey, entryValue) {
		return ! $this._equalsCallback(key, entryKey);
	}));
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.has$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$has$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$set$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$S($this, key, val) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list[i].second = val;
			return;
		}
	}
	$this._list.push(({first: key, second: val}));
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.set$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$S = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$set$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$S;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$get$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			return $this._list[i].second;
		}
	}
	return null;
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.get$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$get$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$delete$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++ i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list.splice(i, 1);
			return;
		}
	}
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.delete$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$delete$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$clear$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$($this) {
	var _list$0;
	(_list$0 = $this._list).splice(0, _list$0.length);
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.clear$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$clear$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$forEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$($this, cb) {
	var i;
	var e;
	for (i = 0; i < $this._list.length; ++ i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.forEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$forEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$reversedForEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$($this, cb) {
	var i;
	var e;
	for (i = $this._list.length - 1; i >= 0; -- i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.reversedForEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$reversedForEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$;

function Pair$x2E$x3CClassDefinition$x2Cstring$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CClassDefinition$x2Cstring$x3E], Object);
function Platform() {
	this.fileContent = {};
};

$__jsx_extend([Platform], Object);
Platform.prototype.setFileContent$SS = function (name, content) {
	this.fileContent[name] = content;
};


function Platform$setFileContent$LPlatform$SS($this, name, content) {
	$this.fileContent[name] = content;
};

Platform.setFileContent$LPlatform$SS = Platform$setFileContent$LPlatform$SS;

Platform.prototype.log$S = function (s) {
	console.log(s);
};


function Platform$log$LPlatform$S($this, s) {
	console.log(s);
};

Platform.log$LPlatform$S = Platform$log$LPlatform$S;

Platform.prototype.warn$S = function (s) {
	console.warn(s);
};


function Platform$warn$LPlatform$S($this, s) {
	console.warn(s);
};

Platform.warn$LPlatform$S = Platform$warn$LPlatform$S;

Platform.prototype.error$S = function (s) {
	console.error(s);
};


Platform.prototype.encodeFilename$S = function (filename) {
	var rootDir;
	rootDir = this.getRoot$() + "/";
	if (filename.indexOf(rootDir) === 0) {
		filename = "system:" + filename.substring(rootDir.length);
	}
	return filename;
};


function Platform$encodeFilename$LPlatform$S($this, filename) {
	var rootDir;
	rootDir = $this.getRoot$() + "/";
	if (filename.indexOf(rootDir) === 0) {
		filename = "system:" + filename.substring(rootDir.length);
	}
	return filename;
};

Platform.encodeFilename$LPlatform$S = Platform$encodeFilename$LPlatform$S;

function BrowserPlatform() {
	this.fileContent = {};
	this._errors = [];
	this._root = BrowserPlatform$_rootPath$LBrowserPlatform$(this);
	this._prefix = dom.window.location.pathname.replace(/\/[^\/]*$/, "");
	this._tree = JSON.parse(this.load$S(this._root + "/tree.generated.json"));
	BrowserPlatform$debug$LBrowserPlatform$X(this, Util$format$SAS("[D] prefix=%1, root=%2", [ this._prefix, this._root ]));
};

$__jsx_extend([BrowserPlatform], Platform);
BrowserPlatform.prototype._rootPath$ = function () {
	var root;
	var matched;
	root = "..";
	try {
		matched = dom.window.location.pathname.match(/^(.*\/try(?:-on-web)?)\/.*$/);
		root = matched[1];
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			BrowserPlatform$debug$LBrowserPlatform$X(this, $__jsx_catch_0.toString());
		} else {
			throw $__jsx_catch_0;
		}
	}
	return root;
};


function BrowserPlatform$_rootPath$LBrowserPlatform$($this) {
	var root;
	var matched;
	root = "..";
	try {
		matched = dom.window.location.pathname.match(/^(.*\/try(?:-on-web)?)\/.*$/);
		root = matched[1];
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			BrowserPlatform$debug$LBrowserPlatform$X($this, $__jsx_catch_0.toString());
		} else {
			throw $__jsx_catch_0;
		}
	}
	return root;
};

BrowserPlatform._rootPath$LBrowserPlatform$ = BrowserPlatform$_rootPath$LBrowserPlatform$;

BrowserPlatform.prototype.getRoot$ = function () {
	return this._root;
};


BrowserPlatform.prototype._resolvePath$S = function (path) {
	return (path.indexOf(this._root + "/") !== -1 ? path.slice(this._root.length + 1) : path);
};


function BrowserPlatform$_resolvePath$LBrowserPlatform$S($this, path) {
	return (path.indexOf($this._root + "/") !== -1 ? path.slice($this._root.length + 1) : path);
};

BrowserPlatform._resolvePath$LBrowserPlatform$S = BrowserPlatform$_resolvePath$LBrowserPlatform$S;

BrowserPlatform.prototype._findPath$S = function (path) {
	var resolvedPath;
	var parts;
	var cur;
	var t;
	resolvedPath = (path.indexOf(this._root + "/") !== -1 ? path.slice(this._root.length + 1) : path);
	BrowserPlatform$debug$LBrowserPlatform$X(this, Util$format$SAS("[D] find path=%1 (resolvedPath=%2)", [ path, resolvedPath ]));
	parts = resolvedPath.split('/');
	if (parts[0] === "") {
		parts.shift();
	}
	cur = this._tree;
	while (parts.length > 0) {
		t = cur[parts.shift()];
		if (t == null) {
			BrowserPlatform$debug$LBrowserPlatform$X(this, "[D] find path --> (not found)");
			return null;
		}
		cur = t;
	}
	BrowserPlatform$debug$LBrowserPlatform$X(this, Util$format$SAS("[D] find path --> %1", [ JSON.stringify(cur) ]));
	return cur;
};


function BrowserPlatform$_findPath$LBrowserPlatform$S($this, path) {
	var resolvedPath;
	var parts;
	var cur;
	var t;
	resolvedPath = (path.indexOf($this._root + "/") !== -1 ? path.slice($this._root.length + 1) : path);
	BrowserPlatform$debug$LBrowserPlatform$X($this, Util$format$SAS("[D] find path=%1 (resolvedPath=%2)", [ path, resolvedPath ]));
	parts = resolvedPath.split('/');
	if (parts[0] === "") {
		parts.shift();
	}
	cur = $this._tree;
	while (parts.length > 0) {
		t = cur[parts.shift()];
		if (t == null) {
			BrowserPlatform$debug$LBrowserPlatform$X($this, "[D] find path --> (not found)");
			return null;
		}
		cur = t;
	}
	BrowserPlatform$debug$LBrowserPlatform$X($this, Util$format$SAS("[D] find path --> %1", [ JSON.stringify(cur) ]));
	return cur;
};

BrowserPlatform._findPath$LBrowserPlatform$S = BrowserPlatform$_findPath$LBrowserPlatform$S;

BrowserPlatform.prototype.fileExists$S = function (path) {
	return BrowserPlatform$_findPath$LBrowserPlatform$S(this, path) != null;
};


BrowserPlatform.prototype.getFilesInDirectory$S = function (path) {
	var d;
	var a;
	var k;
	d = BrowserPlatform$_findPath$LBrowserPlatform$S(this, path);
	if (typeof d === 'object') {
		a = [];
		for (k in d) {
			if (typeof d[k] === "string") {
				a.push(k);
			}
		}
		return a;
	} else {
		if (d == null) {
			throw new Error("no such file or directory");
		} else {
			throw new Error("not a directory");
		}
	}
};


BrowserPlatform.prototype.load$S = function (name) {
	var content;
	var err;
	var xhr;
	if ($__jsx_ObjectHasOwnProperty.call(this.fileContent, name)) {
		return this.fileContent[name];
	}
	content = "";
	err = "";
	try {
		BrowserPlatform$debug$LBrowserPlatform$X(this, "[D] XHR: " + name);
		xhr = new XMLHttpRequest();
		xhr.open("GET", name, false);
		xhr.send(null);
		if (xhr.status === 200 || xhr.status === 0) {
			content = xhr.responseText;
		} else {
			err = (xhr.status + "") + " " + xhr.statusText + ": " + name;
		}
	} catch ($__jsx_catch_0) {
		{
			err = "XMLHttpRequest failed for " + name + ": " + ($__jsx_catch_0 + "");
		}
	}
	if (err) {
		throw new Error(err);
	}
	return this.fileContent[name] = content;
};


BrowserPlatform.prototype.error$S = function (s) {
	console.error(s);
	this._errors.push(s);
};


BrowserPlatform.prototype.debug$X = function (content) {
	if (BrowserPlatform.debug) {
		console.log(content);
	}
};


function BrowserPlatform$debug$LBrowserPlatform$X($this, content) {
	if (BrowserPlatform.debug) {
		console.log(content);
	}
};

BrowserPlatform.debug$LBrowserPlatform$X = BrowserPlatform$debug$LBrowserPlatform$X;

BrowserPlatform.prototype.getErrors$ = function () {
	return this._errors;
};


function BrowserPlatform$getErrors$LBrowserPlatform$($this) {
	return $this._errors;
};

BrowserPlatform.getErrors$LBrowserPlatform$ = BrowserPlatform$getErrors$LBrowserPlatform$;

BrowserPlatform.prototype.applyClosureCompiler$SSB = function (sourceText, level, minify) {
	var URL;
	var xhr;
	var param;
	var params;
	var key;
	URL = 'http://closure-compiler.appspot.com/compile';
	xhr = new XMLHttpRequest();
	xhr.open("POST", URL, false);
	xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
	param = ({ js_code: sourceText, compilation_level: level, output_format: "text", output_info: "compiled_code" });
	if (! minify) {
		param.formatting = "pretty_print";
	}
	if (level === "ADVANCED_OPTIMIZATIONS") {
		param.js_externs = "";
	}
	params = [];
	for (key in param) {
		params.push($__jsx_encodeURIComponent(key) + "=" + $__jsx_encodeURIComponent(param[key]));
	}
	xhr.send(params.join("&"));
	return xhr.responseText;
};


function BrowserPlatform$applyClosureCompiler$LBrowserPlatform$SSB($this, sourceText, level, minify) {
	var URL;
	var xhr;
	var param;
	var params;
	var key;
	URL = 'http://closure-compiler.appspot.com/compile';
	xhr = new XMLHttpRequest();
	xhr.open("POST", URL, false);
	xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
	param = ({ js_code: sourceText, compilation_level: level, output_format: "text", output_info: "compiled_code" });
	if (! minify) {
		param.formatting = "pretty_print";
	}
	if (level === "ADVANCED_OPTIMIZATIONS") {
		param.js_externs = "";
	}
	params = [];
	for (key in param) {
		params.push($__jsx_encodeURIComponent(key) + "=" + $__jsx_encodeURIComponent(param[key]));
	}
	xhr.send(params.join("&"));
	return xhr.responseText;
};

BrowserPlatform.applyClosureCompiler$LBrowserPlatform$SSB = BrowserPlatform$applyClosureCompiler$LBrowserPlatform$SSB;

BrowserPlatform.prototype.makeFileExecutable$SS = function (file, runEnv) {
	throw new Error('not supported');
};


BrowserPlatform.prototype.execute$USSAS = function (sourceFileName, jsSource, argv) {
	throw new Error('not supported');
};


BrowserPlatform.prototype.mkpath$S = function (path) {
	throw new Error('not supported');
};


BrowserPlatform.prototype.save$USS = function (path, content) {
	throw new Error('not supported');
};


BrowserPlatform.prototype.runCompilationServer$X = function (arg) {
	throw new Error('not supported');
};


BrowserPlatform.prototype.setWorkingDir$S = function (dir) {
	throw new Error('not supported');
};


function InstantiationContext(errors, typemap) {
	var key;
	var type;
	this.errors = errors;
	this.typemap = typemap;
	this.objectTypesUsed = [];
	for (key in typemap) {
		type = typemap[key];
		if (type instanceof ObjectType && type.getClassDef$() == null) {
			throw new Error("logic flow, no definition for " + type.toString());
		}
	}
};

$__jsx_extend([InstantiationContext], Object);
InstantiationContext.prototype.clone$ = function () {
	return new InstantiationContext(this.errors, this.typemap);
};


function InstantiationContext$clone$LInstantiationContext$($this) {
	return new InstantiationContext($this.errors, $this.typemap);
};

InstantiationContext.clone$LInstantiationContext$ = InstantiationContext$clone$LInstantiationContext$;

function TemplateInstantiationRequest(token, className, typeArgs) {
	this._token = token;
	this._className = className;
	this._typeArgs = typeArgs;
};

$__jsx_extend([TemplateInstantiationRequest], Object);
function TemplateInstantiationRequest$getToken$LTemplateInstantiationRequest$($this) {
	return $this._token;
};

TemplateInstantiationRequest.getToken$LTemplateInstantiationRequest$ = TemplateInstantiationRequest$getToken$LTemplateInstantiationRequest$;

function TemplateInstantiationRequest$getClassName$LTemplateInstantiationRequest$($this) {
	return $this._className;
};

TemplateInstantiationRequest.getClassName$LTemplateInstantiationRequest$ = TemplateInstantiationRequest$getClassName$LTemplateInstantiationRequest$;

function TemplateInstantiationRequest$getTypeArguments$LTemplateInstantiationRequest$($this) {
	return $this._typeArgs;
};

TemplateInstantiationRequest.getTypeArguments$LTemplateInstantiationRequest$ = TemplateInstantiationRequest$getTypeArguments$LTemplateInstantiationRequest$;

function Block() {
};

$__jsx_extend([Block], Object);
Block.prototype.$__jsx_implements_Block = true;

function BlockContext(localVariableStatuses, block) {
	this.localVariableStatuses = localVariableStatuses;
	this.block = block;
};

$__jsx_extend([BlockContext], Object);
function AnalysisContext(errors, parser, postInstantiationCallback) {
	this.errors = errors;
	this.parser = parser;
	this.postInstantiationCallback = postInstantiationCallback;
	this.funcDef = null;
	this.blockStack = null;
	this.statement = null;
};

$__jsx_extend([AnalysisContext], Object);
function AnalysisContext$clone$LAnalysisContext$($this) {
	var this$0;
	var funcDef$0;
	this$0 = ({errors: $this.errors, parser: $this.parser, postInstantiationCallback: $this.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
	funcDef$0 = $this.funcDef;
	this$0.funcDef = funcDef$0;
	return this$0;
};

AnalysisContext.clone$LAnalysisContext$ = AnalysisContext$clone$LAnalysisContext$;

function AnalysisContext$setFuncDef$LAnalysisContext$LMemberFunctionDefinition$($this, funcDef) {
	$this.funcDef = funcDef;
	return $this;
};

AnalysisContext.setFuncDef$LAnalysisContext$LMemberFunctionDefinition$ = AnalysisContext$setFuncDef$LAnalysisContext$LMemberFunctionDefinition$;

function AnalysisContext$setBlockStack$LAnalysisContext$ALBlockContext$($this, stack) {
	$this.blockStack = stack;
	return $this;
};

AnalysisContext.setBlockStack$LAnalysisContext$ALBlockContext$ = AnalysisContext$setBlockStack$LAnalysisContext$ALBlockContext$;

function AnalysisContext$getTopBlock$LAnalysisContext$($this) {
	var blockStack$0;
	return (blockStack$0 = $this.blockStack)[blockStack$0.length - 1];
};

AnalysisContext.getTopBlock$LAnalysisContext$ = AnalysisContext$getTopBlock$LAnalysisContext$;

function Stash() {
};

$__jsx_extend([Stash], Object);
function _JSEmitterStash() {
	this.shouldBooleanize = false;
	this.returnsBoolean = false;
};

$__jsx_extend([_JSEmitterStash], Stash);
_JSEmitterStash.prototype.clone$ = function () {
	throw new Error("logic flaw");
};


function Stashable() {
	this._stash = {};
};

$__jsx_extend([Stashable], Object);
Stashable.prototype.$__jsx_implements_Stashable = true;

Stashable.prototype.setStash$SLStash$ = function (id, stash) {
	return this._stash[id] = stash;
};


Stashable.prototype.getStash$S = function (id) {
	return this._stash[id];
};


function Emitter() {
	this._stash = {};
};

$__jsx_extend([Emitter], Object);
$__jsx_merge_interface(Emitter, Stashable);

Emitter.prototype.$__jsx_implements_Emitter = true;

function JavaScriptEmitter(platform) {
	this._stash = {};
	this._fileHeader = "var JSX = {};\n(function (JSX) {\n";
	this._fileFooter = "})(JSX);\n";
	this._runenv = "";
	this._output = "";
	this._outputEndsWithReturn = false;
	this._outputFile = null;
	this._indent = 0;
	this._emittingClass = null;
	this._emittingFunction = null;
	this._enableProfiler = false;
	this._enableMinifier = false;
	this._enableRunTimeTypeCheck = true;
	this._bootstrapBuilder = null;
	this._sourceMapper = null;
	this._mangler = ({});
	this._namer = null;
	JavaScriptEmitter$_initialize$();
	this._platform = platform;
};

$__jsx_extend([JavaScriptEmitter], Object);
$__jsx_merge_interface(JavaScriptEmitter, Emitter);

JavaScriptEmitter.prototype.isJsModule$LClassDefinition$ = function (classDef) {
	var getFilename$this$0;
	var resolvePath$path$0;
	return classDef.className$() === "js" && (getFilename$this$0 = classDef.getToken$(), getFilename$this$0._filename) === (resolvePath$path$0 = this._platform.getRoot$() + "/lib/js/js.jsx", Util$_resolvedPathParts$S(resolvePath$path$0).join("/"));
};


function JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$($this, classDef) {
	var getFilename$this$0;
	var resolvePath$path$0;
	return classDef.className$() === "js" && (getFilename$this$0 = classDef.getToken$(), getFilename$this$0._filename) === (resolvePath$path$0 = $this._platform.getRoot$() + "/lib/js/js.jsx", Util$_resolvedPathParts$S(resolvePath$path$0).join("/"));
};

JavaScriptEmitter.isJsModule$LJavaScriptEmitter$LClassDefinition$ = JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$;

JavaScriptEmitter.prototype.setRunEnv$S = function (runenv) {
	this._runenv = runenv;
};


JavaScriptEmitter.prototype.getSearchPaths$ = function () {
	return [ this._platform.getRoot$() + "/lib/js" ];
};


JavaScriptEmitter.prototype.setOutputFile$US = function (name) {
	if (name == null) {
		return;
	}
	this._outputFile = Util$_resolvedPathParts$S(name).join("/");
};


JavaScriptEmitter.prototype.getSourceMappingFiles$ = function () {
	var $this = this;
	var files;
	var sourceMapper;
	var this$0;
	var i$0;
	files = {};
	sourceMapper = this._sourceMapper;
	if (sourceMapper != null && this._outputFile != null) {
		this$0 = Object.keys(sourceMapper._sourceFiles);
		for (i$0 in this$0) {
			(function (filename) {
				var sourceContent$0;
				try {
					sourceContent$0 = $this._platform.load$S(filename);
					sourceMapper._impl.setSourceContent(filename, sourceContent$0);
				} catch ($__jsx_catch_0) {
					if ($__jsx_catch_0 instanceof Error) {
					} else {
						throw $__jsx_catch_0;
					}
				}
			})(this$0[i$0]);
		}
		files[sourceMapper._outputFile + ".mapping"] = sourceMapper._impl.toString();
	}
	return files;
};


JavaScriptEmitter.prototype.getMangler$ = function () {
	return this._mangler;
};


function JavaScriptEmitter$getMangler$LJavaScriptEmitter$($this) {
	return $this._mangler;
};

JavaScriptEmitter.getMangler$LJavaScriptEmitter$ = JavaScriptEmitter$getMangler$LJavaScriptEmitter$;

JavaScriptEmitter.prototype.getNamer$ = function () {
	return this._namer;
};


function JavaScriptEmitter$getNamer$LJavaScriptEmitter$($this) {
	return $this._namer;
};

JavaScriptEmitter.getNamer$LJavaScriptEmitter$ = JavaScriptEmitter$getNamer$LJavaScriptEmitter$;

JavaScriptEmitter.prototype.setEnableRunTimeTypeCheck$B = function (enable) {
	this._enableRunTimeTypeCheck = enable;
};


JavaScriptEmitter.prototype.getEnableSourceMap$ = function () {
	return this._sourceMapper != null;
};


JavaScriptEmitter.prototype.setEnableSourceMap$B = function (enable) {
	this._sourceMapper = (enable ? new SourceMapper(this._platform.getRoot$(), this._outputFile, this._runenv) : null);
};


JavaScriptEmitter.prototype.setEnableProfiler$B = function (enable) {
	this._enableProfiler = enable;
};


JavaScriptEmitter.prototype.getEnableMinifier$ = function () {
	return this._enableMinifier;
};


JavaScriptEmitter.prototype.setEnableMinifier$B = function (enable) {
	this._enableMinifier = enable;
};


JavaScriptEmitter.prototype.emit$ALClassDefinition$ = function (classDefs) {
	var minifier;
	var this$0;
	_Util$0$setOutputClassNames$ALClassDefinition$(classDefs);
	if (this._enableMinifier) {
		minifier = new _Minifier(this, classDefs);
		this._namer = _Minifier$x2E_MinifyingNamer$setup$L_Minifier$x2E_MinifyingNamer$L_Minifier$(new _Minifier$x2E_MinifyingNamer(), minifier);
		JavaScriptEmitter$_emitInit$LJavaScriptEmitter$(this);
		JavaScriptEmitter$_emitCore$LJavaScriptEmitter$ALClassDefinition$(this, classDefs);
		_Minifier$_minifyProperties$L_Minifier$(minifier);
		_Minifier$_minifyStaticVariables$L_Minifier$(minifier);
		_Minifier$_minifyGlobals$L_Minifier$(minifier);
		this._namer = _Minifier$x2E_MinifyingNamer$setup$L_Minifier$x2E_MinifyingNamer$L_Minifier$(new _Minifier$x2E_MinifyingNamer(), minifier);
		JavaScriptEmitter$_emitInit$LJavaScriptEmitter$(this);
		JavaScriptEmitter$_emitCore$LJavaScriptEmitter$ALClassDefinition$(this, classDefs);
	} else {
		this$0 = new _Namer();
		this$0._emitter = this;
		this._namer = this$0;
		JavaScriptEmitter$_emitInit$LJavaScriptEmitter$(this);
		JavaScriptEmitter$_emitCore$LJavaScriptEmitter$ALClassDefinition$(this, classDefs);
	}
	JavaScriptEmitter$_emitClassMap$LJavaScriptEmitter$ALClassDefinition$(this, classDefs);
};


JavaScriptEmitter.prototype._emitInit$ = function () {
	var stash;
	var _platform$0;
	this._output = "";
	this._outputEndsWithReturn = true;
	this._indent = 0;
	this._emittingClass = null;
	this._emittingFunction = null;
	this._output += "// generatedy by JSX compiler " + Meta.IDENTIFIER + "\n";
	this._output += this._fileHeader;
	this._output += (_platform$0 = this._platform).load$S(_platform$0.getRoot$() + "/src/js/bootstrap.js");
	stash = this.getStash$S("no-debug");
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "JSX.DEBUG = " + (stash == null || stash.debugValue ? "true" : "false") + ";\n", null);
};


function JavaScriptEmitter$_emitInit$LJavaScriptEmitter$($this) {
	var stash;
	var _platform$0;
	$this._output = "";
	$this._outputEndsWithReturn = true;
	$this._indent = 0;
	$this._emittingClass = null;
	$this._emittingFunction = null;
	$this._output += "// generatedy by JSX compiler " + Meta.IDENTIFIER + "\n";
	$this._output += $this._fileHeader;
	$this._output += (_platform$0 = $this._platform).load$S(_platform$0.getRoot$() + "/src/js/bootstrap.js");
	stash = $this.getStash$S("no-debug");
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "JSX.DEBUG = " + (stash == null || stash.debugValue ? "true" : "false") + ";\n", null);
};

JavaScriptEmitter._emitInit$LJavaScriptEmitter$ = JavaScriptEmitter$_emitInit$LJavaScriptEmitter$;

JavaScriptEmitter.prototype._emitCore$ALClassDefinition$ = function (classDefs) {
	var $this = this;
	var i;
	var onFuncDef;
	for (i = 0; i < classDefs.length; ++ i) {
		function onFuncDef(funcDef) {
			MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFuncDef);
			JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
			return true;
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDefs[i], onFuncDef);
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDefs[i], (function (varDef) {
			if ((varDef._flags & 8) !== 0 && varDef._initialValue != null) {
				JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$($this, varDef._initialValue);
			}
			return true;
		}));
	}
	for (i = 0; i < classDefs.length; ++ i) {
		JavaScriptEmitter$_emitClassDefinition$LJavaScriptEmitter$LClassDefinition$(this, classDefs[i]);
	}
	for (i = 0; i < classDefs.length; ++ i) {
		JavaScriptEmitter$_emitStaticInitializationCode$LJavaScriptEmitter$LClassDefinition$(this, classDefs[i]);
	}
};


function JavaScriptEmitter$_emitCore$LJavaScriptEmitter$ALClassDefinition$($this, classDefs) {
	var i;
	var onFuncDef;
	for (i = 0; i < classDefs.length; ++ i) {
		function onFuncDef(funcDef) {
			MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFuncDef);
			JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
			return true;
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDefs[i], onFuncDef);
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDefs[i], (function (varDef) {
			if ((varDef._flags & 8) !== 0 && varDef._initialValue != null) {
				JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$($this, varDef._initialValue);
			}
			return true;
		}));
	}
	for (i = 0; i < classDefs.length; ++ i) {
		JavaScriptEmitter$_emitClassDefinition$LJavaScriptEmitter$LClassDefinition$($this, classDefs[i]);
	}
	for (i = 0; i < classDefs.length; ++ i) {
		JavaScriptEmitter$_emitStaticInitializationCode$LJavaScriptEmitter$LClassDefinition$($this, classDefs[i]);
	}
};

JavaScriptEmitter._emitCore$LJavaScriptEmitter$ALClassDefinition$ = JavaScriptEmitter$_emitCore$LJavaScriptEmitter$ALClassDefinition$;

JavaScriptEmitter.prototype.setBootstrapMode$NSS = function (mode, sourceFile, executableFor) {
	var this$0;
	switch (mode) {
	case 0:
		this._bootstrapBuilder = null;
		break;
	case 1:
		this._bootstrapBuilder = new _ExecutableBootstrapBuilder();
		break;
	case 2:
		this._bootstrapBuilder = new _TestBootstrapBuilder();
		break;
	default:
		throw new Error("unexpected bootstrap mode:" + (mode + ""));
	}
	if (this._bootstrapBuilder != null) {
		this$0 = this._bootstrapBuilder;
		this$0._emitter = this;
		this$0._entrySourceFile = sourceFile;
		this$0._executableFor = executableFor;
	}
};


function JavaScriptEmitter$setBootstrapMode$LJavaScriptEmitter$NSS($this, mode, sourceFile, executableFor) {
	var this$0;
	switch (mode) {
	case 0:
		$this._bootstrapBuilder = null;
		break;
	case 1:
		$this._bootstrapBuilder = new _ExecutableBootstrapBuilder();
		break;
	case 2:
		$this._bootstrapBuilder = new _TestBootstrapBuilder();
		break;
	default:
		throw new Error("unexpected bootstrap mode:" + (mode + ""));
	}
	if ($this._bootstrapBuilder != null) {
		this$0 = $this._bootstrapBuilder;
		this$0._emitter = $this;
		this$0._entrySourceFile = sourceFile;
		this$0._executableFor = executableFor;
	}
};

JavaScriptEmitter.setBootstrapMode$LJavaScriptEmitter$NSS = JavaScriptEmitter$setBootstrapMode$LJavaScriptEmitter$NSS;

JavaScriptEmitter.prototype.getStash$LStashable$ = function (stashable) {
	var stash;
	stash = stashable.getStash$S("jsemitter");
	if (stash == null) {
		stash = stashable.setStash$SLStash$("jsemitter", new _JSEmitterStash());
	}
	return stash;
};


function JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, stashable) {
	var stash;
	stash = stashable.getStash$S("jsemitter");
	if (stash == null) {
		stash = stashable.setStash$SLStash$("jsemitter", new _JSEmitterStash());
	}
	return stash;
};

JavaScriptEmitter.getStash$LJavaScriptEmitter$LStashable$ = JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$;

JavaScriptEmitter.prototype._setupBooleanizeFlags$LExpression$ = function (expr) {
	var $this = this;
	var exprReturnsBoolean;
	var parentExpr;
	var onExpr;
	exprReturnsBoolean = (function (expr) {
		return (expr instanceof LogicalExpression ? JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).returnsBoolean : expr.getType$().equals$LType$(Type.booleanType));
	});
	parentExpr = [];
	onExpr = (function (expr) {
		var shouldBooleanize;
		var returnsBoolean;
		parentExpr.unshift(expr);
		Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		parentExpr.shift();
		if (expr instanceof LogicalExpression) {
			shouldBooleanize = true;
			returnsBoolean = false;
			if (exprReturnsBoolean(expr._expr1) && exprReturnsBoolean(expr._expr2)) {
				returnsBoolean = true;
				shouldBooleanize = false;
			} else {
				if (parentExpr.length === 0) {
				} else {
					if (parentExpr[0] instanceof LogicalExpression || parentExpr[0] instanceof LogicalNotExpression) {
						shouldBooleanize = false;
					} else {
						if (parentExpr[0] instanceof ConditionalExpression && parentExpr[0]._condExpr == expr) {
							shouldBooleanize = false;
						}
					}
				}
			}
			JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).shouldBooleanize = shouldBooleanize;
			JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).returnsBoolean = returnsBoolean;
		}
		return true;
	});
	onExpr(expr);
};


function JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$($this, expr) {
	var exprReturnsBoolean;
	var parentExpr;
	var onExpr;
	exprReturnsBoolean = (function (expr) {
		return (expr instanceof LogicalExpression ? JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).returnsBoolean : expr.getType$().equals$LType$(Type.booleanType));
	});
	parentExpr = [];
	onExpr = (function (expr) {
		var shouldBooleanize;
		var returnsBoolean;
		parentExpr.unshift(expr);
		Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		parentExpr.shift();
		if (expr instanceof LogicalExpression) {
			shouldBooleanize = true;
			returnsBoolean = false;
			if (exprReturnsBoolean(expr._expr1) && exprReturnsBoolean(expr._expr2)) {
				returnsBoolean = true;
				shouldBooleanize = false;
			} else {
				if (parentExpr.length === 0) {
				} else {
					if (parentExpr[0] instanceof LogicalExpression || parentExpr[0] instanceof LogicalNotExpression) {
						shouldBooleanize = false;
					} else {
						if (parentExpr[0] instanceof ConditionalExpression && parentExpr[0]._condExpr == expr) {
							shouldBooleanize = false;
						}
					}
				}
			}
			JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).shouldBooleanize = shouldBooleanize;
			JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).returnsBoolean = returnsBoolean;
		}
		return true;
	});
	onExpr(expr);
};

JavaScriptEmitter._setupBooleanizeFlags$LJavaScriptEmitter$LExpression$ = JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$;

JavaScriptEmitter.prototype._setupBooleanizeFlags$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
			JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$($this, expr);
			if (statement instanceof ExpressionStatement || statement instanceof IfStatement || statement instanceof DoWhileStatement || statement instanceof WhileStatement || statement instanceof ForStatement) {
				JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).shouldBooleanize = false;
			}
			return true;
		}));
		return statement.forEachStatement$F$LStatement$B$(onStatement);
	}), funcDef._statements);
};


function JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef) {
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
			JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$($this, expr);
			if (statement instanceof ExpressionStatement || statement instanceof IfStatement || statement instanceof DoWhileStatement || statement instanceof WhileStatement || statement instanceof ForStatement) {
				JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).shouldBooleanize = false;
			}
			return true;
		}));
		return statement.forEachStatement$F$LStatement$B$(onStatement);
	}), funcDef._statements);
};

JavaScriptEmitter._setupBooleanizeFlags$LJavaScriptEmitter$LMemberFunctionDefinition$ = JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LMemberFunctionDefinition$;

JavaScriptEmitter.prototype.shouldBooleanize$LExpression$ = function (logicalExpr) {
	return JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$(this, logicalExpr).shouldBooleanize;
};


function JavaScriptEmitter$shouldBooleanize$LJavaScriptEmitter$LExpression$($this, logicalExpr) {
	return JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, logicalExpr).shouldBooleanize;
};

JavaScriptEmitter.shouldBooleanize$LJavaScriptEmitter$LExpression$ = JavaScriptEmitter$shouldBooleanize$LJavaScriptEmitter$LExpression$;

JavaScriptEmitter.prototype._emitClassDefinition$LClassDefinition$ = function (classDef) {
	var ctors;
	var i;
	var members;
	var member;
	if ((classDef.flags$() & 16) !== 0) {
		if (classDef._nativeSource != null) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "var " + this._namer.getNameOfClass$LClassDefinition$(classDef) + " = " + Util$decodeStringLiteral$S(classDef._nativeSource._value) + ";\n", classDef._nativeSource);
		}
		return;
	}
	this._emittingClass = classDef;
	try {
		ctors = _Util$0$findFunctions$LClassDefinition$SB(classDef, "constructor", false);
		for (i = 0; i < ctors.length; ++ i) {
			JavaScriptEmitter$_emitConstructor$LJavaScriptEmitter$LMemberFunctionDefinition$(this, ctors[i]);
		}
		JavaScriptEmitter$_emitClassObjectAmendments$LJavaScriptEmitter$LClassDefinition$ALMemberFunctionDefinition$(this, classDef, ctors);
		members = classDef._members;
		for (i = 0; i < members.length; ++ i) {
			member = members[i];
			if (member instanceof MemberFunctionDefinition) {
				if (! (member._nameToken._value === "constructor" && (member._flags & 8) === 0) && member._statements != null) {
					if (member instanceof TemplateFunctionDefinition) {
					} else {
						JavaScriptEmitter$_emitFunction$LJavaScriptEmitter$LMemberFunctionDefinition$(this, member);
					}
				}
			}
		}
	} finally {
		this._emittingClass = null;
	}
};


function JavaScriptEmitter$_emitClassDefinition$LJavaScriptEmitter$LClassDefinition$($this, classDef) {
	var ctors;
	var i;
	var members;
	var member;
	if ((classDef.flags$() & 16) !== 0) {
		if (classDef._nativeSource != null) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "var " + $this._namer.getNameOfClass$LClassDefinition$(classDef) + " = " + Util$decodeStringLiteral$S(classDef._nativeSource._value) + ";\n", classDef._nativeSource);
		}
		return;
	}
	$this._emittingClass = classDef;
	try {
		ctors = _Util$0$findFunctions$LClassDefinition$SB(classDef, "constructor", false);
		for (i = 0; i < ctors.length; ++ i) {
			JavaScriptEmitter$_emitConstructor$LJavaScriptEmitter$LMemberFunctionDefinition$($this, ctors[i]);
		}
		JavaScriptEmitter$_emitClassObjectAmendments$LJavaScriptEmitter$LClassDefinition$ALMemberFunctionDefinition$($this, classDef, ctors);
		members = classDef._members;
		for (i = 0; i < members.length; ++ i) {
			member = members[i];
			if (member instanceof MemberFunctionDefinition) {
				if (! (member._nameToken._value === "constructor" && (member._flags & 8) === 0) && member._statements != null) {
					if (member instanceof TemplateFunctionDefinition) {
					} else {
						JavaScriptEmitter$_emitFunction$LJavaScriptEmitter$LMemberFunctionDefinition$($this, member);
					}
				}
			}
		}
	} finally {
		$this._emittingClass = null;
	}
};

JavaScriptEmitter._emitClassDefinition$LJavaScriptEmitter$LClassDefinition$ = JavaScriptEmitter$_emitClassDefinition$LJavaScriptEmitter$LClassDefinition$;

JavaScriptEmitter.prototype._emitStaticInitializationCode$LClassDefinition$ = function (classDef) {
	var members;
	var i;
	var member;
	if (JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$(this, classDef)) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "var js = { global: function () { return this; }() };\n", null);
		return;
	}
	if ((classDef.flags$() & 16) !== 0) {
		return;
	}
	members = classDef._members;
	for (i = 0; i < members.length; ++ i) {
		member = members[i];
		if (member instanceof MemberVariableDefinition && (member._flags & 24) === 8) {
			JavaScriptEmitter$_emitStaticMemberVariable$LJavaScriptEmitter$LMemberVariableDefinition$(this, member);
		}
	}
};


function JavaScriptEmitter$_emitStaticInitializationCode$LJavaScriptEmitter$LClassDefinition$($this, classDef) {
	var members;
	var i;
	var member;
	if (JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$($this, classDef)) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "var js = { global: function () { return this; }() };\n", null);
		return;
	}
	if ((classDef.flags$() & 16) !== 0) {
		return;
	}
	members = classDef._members;
	for (i = 0; i < members.length; ++ i) {
		member = members[i];
		if (member instanceof MemberVariableDefinition && (member._flags & 24) === 8) {
			JavaScriptEmitter$_emitStaticMemberVariable$LJavaScriptEmitter$LMemberVariableDefinition$($this, member);
		}
	}
};

JavaScriptEmitter._emitStaticInitializationCode$LJavaScriptEmitter$LClassDefinition$ = JavaScriptEmitter$_emitStaticInitializationCode$LJavaScriptEmitter$LClassDefinition$;

JavaScriptEmitter.prototype._emitClassMap$ALClassDefinition$ = function (classDefs) {
	var $this = this;
	var i;
	var isFirstEntry;
	var list;
	var pushClass;
	var filename;
	var escapedFilename;
	var this$0;
	var getFilename$this$1;
	var encodeObjectLiteralKey$s$0;
	classDefs = classDefs.concat([]);
	for (i = 0; i < classDefs.length; ) {
		if (classDefs[i].getToken$() == null || (classDefs[i].flags$() & 16) !== 0) {
			classDefs.splice(i, 1);
		} else {
			++ i;
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\nvar $__jsx_classMap = {", null);
	isFirstEntry = true;
	while (classDefs.length !== 0) {
		list = [];
		pushClass = (function (classDef) {
			var ctors;
			var exportedCtor;
			var i;
			var push;
			var ctors$len$0;
			ctors = _Util$0$findFunctions$LClassDefinition$SB(classDef, "constructor", false);
			if ((classDef.flags$() & 16384) !== 0) {
				exportedCtor = null;
				for ((i = 0, ctors$len$0 = ctors.length); i < ctors$len$0; ++ i) {
					if ((ctors[i]._flags & 16384) !== 0) {
						exportedCtor = ctors[i];
					}
				}
				if (exportedCtor == null) {
					exportedCtor = ctors[0];
				}
				list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef), $this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(exportedCtor)) ]);
			}
			if (! $this._enableMinifier) {
				if ((classDef.flags$() & 16384) === 0) {
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef), $this._namer.getNameOfClass$LClassDefinition$(classDef) ]);
				}
				push = (function (argTypes) {
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef) + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this._mangler, argTypes), $this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, argTypes) ]);
				});
				if (ctors.length === 0) {
					push([]);
				} else {
					for (i = 0; i < ctors.length; ++ i) {
						push(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(ctors[i]));
					}
				}
			}
		});
		this$0 = classDefs[0].getToken$();
		filename = this$0._filename;
		pushClass(classDefs.shift());
		for (i = 0; i < classDefs.length; ) {
			if ((getFilename$this$1 = classDefs[i].getToken$(), getFilename$this$1._filename) === filename) {
				pushClass(classDefs[i]);
				classDefs.splice(i, 1);
			} else {
				++ i;
			}
		}
		if (list.length !== 0 || ! this._enableMinifier) {
			if (isFirstEntry) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\n", null);
				++ this._indent;
				isFirstEntry = false;
			} else {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ",\n", null);
			}
			escapedFilename = JSON.stringify(Platform$encodeFilename$LPlatform$S(this._platform, filename));
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, escapedFilename + ": ", null);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "{\n", null);
			++ this._indent;
			for (i = 0; i < list.length; ++ i) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, (encodeObjectLiteralKey$s$0 = list[i][0], encodeObjectLiteralKey$s$0.length === 0 || encodeObjectLiteralKey$s$0.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/) ? encodeObjectLiteralKey$s$0 : Util$encodeStringLiteral$S(encodeObjectLiteralKey$s$0)) + ": " + list[i][1], null);
				if (i !== list.length - 1) {
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ",", null);
				}
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\n", null);
			}
			JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$(this);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "}", null);
		}
	}
	if (! isFirstEntry) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\n", null);
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$(this);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "};\n\n", null);
};


function JavaScriptEmitter$_emitClassMap$LJavaScriptEmitter$ALClassDefinition$($this, classDefs) {
	var i;
	var isFirstEntry;
	var list;
	var pushClass;
	var filename;
	var escapedFilename;
	var this$0;
	var getFilename$this$1;
	var encodeObjectLiteralKey$s$0;
	classDefs = classDefs.concat([]);
	for (i = 0; i < classDefs.length; ) {
		if (classDefs[i].getToken$() == null || (classDefs[i].flags$() & 16) !== 0) {
			classDefs.splice(i, 1);
		} else {
			++ i;
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\nvar $__jsx_classMap = {", null);
	isFirstEntry = true;
	while (classDefs.length !== 0) {
		list = [];
		pushClass = (function (classDef) {
			var ctors;
			var exportedCtor;
			var i;
			var push;
			var ctors$len$0;
			ctors = _Util$0$findFunctions$LClassDefinition$SB(classDef, "constructor", false);
			if ((classDef.flags$() & 16384) !== 0) {
				exportedCtor = null;
				for ((i = 0, ctors$len$0 = ctors.length); i < ctors$len$0; ++ i) {
					if ((ctors[i]._flags & 16384) !== 0) {
						exportedCtor = ctors[i];
					}
				}
				if (exportedCtor == null) {
					exportedCtor = ctors[0];
				}
				list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef), $this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(exportedCtor)) ]);
			}
			if (! $this._enableMinifier) {
				if ((classDef.flags$() & 16384) === 0) {
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef), $this._namer.getNameOfClass$LClassDefinition$(classDef) ]);
				}
				push = (function (argTypes) {
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef) + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this._mangler, argTypes), $this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, argTypes) ]);
				});
				if (ctors.length === 0) {
					push([]);
				} else {
					for (i = 0; i < ctors.length; ++ i) {
						push(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(ctors[i]));
					}
				}
			}
		});
		this$0 = classDefs[0].getToken$();
		filename = this$0._filename;
		pushClass(classDefs.shift());
		for (i = 0; i < classDefs.length; ) {
			if ((getFilename$this$1 = classDefs[i].getToken$(), getFilename$this$1._filename) === filename) {
				pushClass(classDefs[i]);
				classDefs.splice(i, 1);
			} else {
				++ i;
			}
		}
		if (list.length !== 0 || ! $this._enableMinifier) {
			if (isFirstEntry) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\n", null);
				++ $this._indent;
				isFirstEntry = false;
			} else {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ",\n", null);
			}
			escapedFilename = JSON.stringify(Platform$encodeFilename$LPlatform$S($this._platform, filename));
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, escapedFilename + ": ", null);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "{\n", null);
			++ $this._indent;
			for (i = 0; i < list.length; ++ i) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, (encodeObjectLiteralKey$s$0 = list[i][0], encodeObjectLiteralKey$s$0.length === 0 || encodeObjectLiteralKey$s$0.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/) ? encodeObjectLiteralKey$s$0 : Util$encodeStringLiteral$S(encodeObjectLiteralKey$s$0)) + ": " + list[i][1], null);
				if (i !== list.length - 1) {
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ",", null);
				}
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\n", null);
			}
			JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "}", null);
		}
	}
	if (! isFirstEntry) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\n", null);
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "};\n\n", null);
};

JavaScriptEmitter._emitClassMap$LJavaScriptEmitter$ALClassDefinition$ = JavaScriptEmitter$_emitClassMap$LJavaScriptEmitter$ALClassDefinition$;

JavaScriptEmitter.prototype.getOutput$ = function () {
	var output;
	var ast$0;
	var _platform$0;
	output = "";
	if (this._sourceMapper) {
		output += this._sourceMapper._header;
	}
	output += this._output + "\n";
	if (this._enableProfiler) {
		output += (_platform$0 = this._platform).load$S(_platform$0.getRoot$() + "/src/js/profiler.js");
	}
	if (this._bootstrapBuilder != null) {
		output = _BootstrapBuilder$addBootstrap$L_BootstrapBuilder$S(this._bootstrapBuilder, output);
	}
	output += this._fileFooter;
	if (this._sourceMapper) {
		output += SourceMapper$getSourceMapFooter$LSourceMapper$(this._sourceMapper);
	}
	if (this._enableMinifier) {
		ast$0 = esprima$0.parse(output);
		ast$0 = esmangle$0.mangle(ast$0, ({ destructive: true }));
		output = escodegen$0.generate(ast$0, ({ format: ({ renumber: true, hexadecimal: true, escapeless: true, compact: true, semicolons: false, parentheses: false }), directive: true }));
	}
	return output;
};


JavaScriptEmitter.prototype._emitClassObjectAmendments$LClassDefinition$ALMemberFunctionDefinition$ = function (classDef, constructors) {
	var $this = this;
	var extendClassDef;
	var i;
	var implementTypes;
	var unresolvedExports;
	var this$0;
	if (classDef._extendType != null) {
		this$0 = classDef._extendType;
		extendClassDef = this$0._classDef;
	} else {
		extendClassDef = null;
	}
	if (constructors.length !== 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "$__jsx_extend([", null);
		for (i = 0; i < constructors.length; ++ i) {
			if (i !== 0) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ", ", null);
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(constructors[i])), null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "], " + (extendClassDef != null ? this._namer.getNameOfClass$LClassDefinition$(extendClassDef) : "Object") + ");\n", null);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "function " + this._namer.getNameOfClass$LClassDefinition$(classDef) + "() {}\n", null);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "$__jsx_extend([" + this._namer.getNameOfClass$LClassDefinition$(classDef) + "], " + (extendClassDef != null ? this._namer.getNameOfClass$LClassDefinition$(extendClassDef) : "Object") + ");\n", null);
	}
	implementTypes = classDef._implementTypes;
	if (implementTypes.length !== 0) {
		for (i = 0; i < implementTypes.length; ++ i) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "$__jsx_merge_interface(" + this._namer.getNameOfClass$LClassDefinition$(classDef) + ", " + this._namer.getNameOfClass$LClassDefinition$(implementTypes[i]._classDef) + ");\n", null);
		}
		unresolvedExports = {};
		(function buildUnresolvedExports(baseClassDef) {
			var this$0;
			var i$0;
			var implType$0;
			if (baseClassDef._extendType != null) {
				buildUnresolvedExports(baseClassDef._extendType._classDef);
			}
			this$0 = baseClassDef._implementTypes;
			for (i$0 in this$0) {
				implType$0 = this$0[i$0];
				buildUnresolvedExports(implType$0._classDef);
			}
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(baseClassDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_EXPORT)) === ClassDefinition.IS_EXPORT && MemberDefinition$name$LMemberDefinition$(funcDef) !== "constructor") {
					if (classDef == baseClassDef && MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef) != null) {
						delete unresolvedExports[MemberDefinition$name$LMemberDefinition$(funcDef)];
					} else {
						unresolvedExports[MemberDefinition$name$LMemberDefinition$(funcDef)] = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef);
					}
				}
				return true;
			}));
		})(classDef);
		for (i = implementTypes.length - 1; i >= 0 && Object.keys(unresolvedExports).length !== 0; -- i) {
			ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(implementTypes[i]._classDef, (function (baseClassDef) {
				var name;
				for (name in unresolvedExports) {
					if (Util$findFunctionInClass$LClassDefinition$SALType$B(baseClassDef, name, unresolvedExports[name], false)) {
						JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype." + name + " = " + $this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype." + $this._namer.getNameOfMethod$LClassDefinition$SALType$(classDef, name, unresolvedExports[name]) + ";\n", null);
						delete unresolvedExports[name];
					}
				}
				return Object.keys(unresolvedExports).length !== 0;
			}));
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\n", null);
	}
	if ((classDef.flags$() & 192) !== 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype.$__jsx_implements_" + this._namer.getNameOfClass$LClassDefinition$(classDef) + " = true;\n\n", null);
	}
};


function JavaScriptEmitter$_emitClassObjectAmendments$LJavaScriptEmitter$LClassDefinition$ALMemberFunctionDefinition$($this, classDef, constructors) {
	var extendClassDef;
	var i;
	var implementTypes;
	var unresolvedExports;
	var this$0;
	if (classDef._extendType != null) {
		this$0 = classDef._extendType;
		extendClassDef = this$0._classDef;
	} else {
		extendClassDef = null;
	}
	if (constructors.length !== 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "$__jsx_extend([", null);
		for (i = 0; i < constructors.length; ++ i) {
			if (i !== 0) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ", ", null);
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(constructors[i])), null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "], " + (extendClassDef != null ? $this._namer.getNameOfClass$LClassDefinition$(extendClassDef) : "Object") + ");\n", null);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "function " + $this._namer.getNameOfClass$LClassDefinition$(classDef) + "() {}\n", null);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "$__jsx_extend([" + $this._namer.getNameOfClass$LClassDefinition$(classDef) + "], " + (extendClassDef != null ? $this._namer.getNameOfClass$LClassDefinition$(extendClassDef) : "Object") + ");\n", null);
	}
	implementTypes = classDef._implementTypes;
	if (implementTypes.length !== 0) {
		for (i = 0; i < implementTypes.length; ++ i) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "$__jsx_merge_interface(" + $this._namer.getNameOfClass$LClassDefinition$(classDef) + ", " + $this._namer.getNameOfClass$LClassDefinition$(implementTypes[i]._classDef) + ");\n", null);
		}
		unresolvedExports = {};
		(function buildUnresolvedExports(baseClassDef) {
			var this$0;
			var i$0;
			var implType$0;
			if (baseClassDef._extendType != null) {
				buildUnresolvedExports(baseClassDef._extendType._classDef);
			}
			this$0 = baseClassDef._implementTypes;
			for (i$0 in this$0) {
				implType$0 = this$0[i$0];
				buildUnresolvedExports(implType$0._classDef);
			}
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(baseClassDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_EXPORT)) === ClassDefinition.IS_EXPORT && MemberDefinition$name$LMemberDefinition$(funcDef) !== "constructor") {
					if (classDef == baseClassDef && MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef) != null) {
						delete unresolvedExports[MemberDefinition$name$LMemberDefinition$(funcDef)];
					} else {
						unresolvedExports[MemberDefinition$name$LMemberDefinition$(funcDef)] = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef);
					}
				}
				return true;
			}));
		})(classDef);
		for (i = implementTypes.length - 1; i >= 0 && Object.keys(unresolvedExports).length !== 0; -- i) {
			ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(implementTypes[i]._classDef, (function (baseClassDef) {
				var name;
				for (name in unresolvedExports) {
					if (Util$findFunctionInClass$LClassDefinition$SALType$B(baseClassDef, name, unresolvedExports[name], false)) {
						JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype." + name + " = " + $this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype." + $this._namer.getNameOfMethod$LClassDefinition$SALType$(classDef, name, unresolvedExports[name]) + ";\n", null);
						delete unresolvedExports[name];
					}
				}
				return Object.keys(unresolvedExports).length !== 0;
			}));
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\n", null);
	}
	if ((classDef.flags$() & 192) !== 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype.$__jsx_implements_" + $this._namer.getNameOfClass$LClassDefinition$(classDef) + " = true;\n\n", null);
	}
};

JavaScriptEmitter._emitClassObjectAmendments$LJavaScriptEmitter$LClassDefinition$ALMemberFunctionDefinition$ = JavaScriptEmitter$_emitClassObjectAmendments$LJavaScriptEmitter$LClassDefinition$ALMemberFunctionDefinition$;

JavaScriptEmitter.prototype._emitConstructor$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var funcName;
	funcName = this._namer.getNameOfConstructor$LClassDefinition$ALType$(funcDef._classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "function ", null);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, funcName + "(", funcDef._classDef.getToken$());
	this._namer.enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
		JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ") {\n", null);
		++ $this._indent;
		JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "};\n\n", null);
	}));
};


function JavaScriptEmitter$_emitConstructor$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef) {
	var funcName;
	funcName = $this._namer.getNameOfConstructor$LClassDefinition$ALType$(funcDef._classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "function ", null);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, funcName + "(", funcDef._classDef.getToken$());
	$this._namer.enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
		JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ") {\n", null);
		++ $this._indent;
		JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "};\n\n", null);
	}));
};

JavaScriptEmitter._emitConstructor$LJavaScriptEmitter$LMemberFunctionDefinition$ = JavaScriptEmitter$_emitConstructor$LJavaScriptEmitter$LMemberFunctionDefinition$;

JavaScriptEmitter.prototype._emitFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var isStatic;
	var _value$0;
	isStatic = (funcDef._flags & 8) !== 0;
	if (isStatic) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "function " + this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + "(", funcDef._nameToken);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + this._namer.getNameOfMethod$LClassDefinition$SALType$(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + " = function (", funcDef._nameToken);
	}
	this._namer.enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
		JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ") {\n", null);
		++ $this._indent;
		JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "};\n\n", null);
	}));
	if (isStatic) {
		if (Util$memberIsExported$LClassDefinition$SALType$B(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), true)) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + "." + (_value$0 = funcDef._nameToken._value) + " = " + this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, _value$0, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
		}
		if (! this._enableMinifier) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + "." + funcDef._nameToken._value + _Mangler$mangleFunctionArguments$L_Mangler$ALType$(this._mangler, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + " = " + this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
		}
	} else {
		if (Util$memberIsExported$LClassDefinition$SALType$B(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), false)) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + funcDef._nameToken._value + " = " + this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + this._namer.getNameOfMethod$LClassDefinition$SALType$(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\n", null);
};


function JavaScriptEmitter$_emitFunction$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef) {
	var isStatic;
	var _value$0;
	isStatic = (funcDef._flags & 8) !== 0;
	if (isStatic) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "function " + $this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + "(", funcDef._nameToken);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + $this._namer.getNameOfMethod$LClassDefinition$SALType$(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + " = function (", funcDef._nameToken);
	}
	$this._namer.enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
		JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ") {\n", null);
		++ $this._indent;
		JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "};\n\n", null);
	}));
	if (isStatic) {
		if (Util$memberIsExported$LClassDefinition$SALType$B(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), true)) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + "." + (_value$0 = funcDef._nameToken._value) + " = " + $this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, _value$0, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
		}
		if (! $this._enableMinifier) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + "." + funcDef._nameToken._value + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this._mangler, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + " = " + $this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
		}
	} else {
		if (Util$memberIsExported$LClassDefinition$SALType$B(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), false)) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + funcDef._nameToken._value + " = " + $this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + $this._namer.getNameOfMethod$LClassDefinition$SALType$(funcDef._classDef, funcDef._nameToken._value, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\n", null);
};

JavaScriptEmitter._emitFunction$LJavaScriptEmitter$LMemberFunctionDefinition$ = JavaScriptEmitter$_emitFunction$LJavaScriptEmitter$LMemberFunctionDefinition$;

JavaScriptEmitter.prototype._emitFunctionArguments$LMemberFunctionDefinition$ = function (funcDef) {
	var args;
	var i;
	args = funcDef._args;
	for (i = 0; i < args.length; ++ i) {
		if (i !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ", ", null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfLocalVariable$LLocalVariable$(args[i]), args[i]._name);
	}
};


function JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef) {
	var args;
	var i;
	args = funcDef._args;
	for (i = 0; i < args.length; ++ i) {
		if (i !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ", ", null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfLocalVariable$LLocalVariable$(args[i]), args[i]._name);
	}
};

JavaScriptEmitter._emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$ = JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$;

JavaScriptEmitter.prototype._emitFunctionBody$LMemberFunctionDefinition$ = function (funcDef) {
	var prevEmittingFunction;
	var locals;
	var i;
	var type;
	var statements;
	var statement$0;
	var emitter$0;
	prevEmittingFunction = this._emittingFunction;
	try {
		this._emittingFunction = funcDef;
		if (this._enableProfiler) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "var $__jsx_profiler_ctx = $__jsx_profiler.enter(" + Util$encodeStringLiteral$S(funcDef.getNotation$()) + ");\n", null);
		}
		if (funcDef._closures.length !== 0 && (funcDef._flags & 8) === 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "var $this = this;\n", null);
		}
		locals = funcDef._locals;
		for (i = 0; i < locals.length; ++ i) {
			type = locals[i]._type;
			if (type == null) {
				continue;
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "var " + this._namer.getNameOfLocalVariable$LLocalVariable$(locals[i]) + ";\n", null);
		}
		statements = funcDef._statements;
		for (i = 0; i < statements.length; ++ i) {
			statement$0 = statements[i];
			emitter$0 = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$(this, statement$0);
			emitter$0.emit$();
		}
		if (this._enableProfiler) {
			if (statements.length === 0 || ! (statements[statements.length - 1] instanceof ReturnStatement)) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "$__jsx_profiler.exit();\n", null);
			}
		}
	} finally {
		this._emittingFunction = prevEmittingFunction;
	}
};


function JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef) {
	var prevEmittingFunction;
	var locals;
	var i;
	var type;
	var statements;
	var statement$0;
	var emitter$0;
	prevEmittingFunction = $this._emittingFunction;
	try {
		$this._emittingFunction = funcDef;
		if ($this._enableProfiler) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "var $__jsx_profiler_ctx = $__jsx_profiler.enter(" + Util$encodeStringLiteral$S(funcDef.getNotation$()) + ");\n", null);
		}
		if (funcDef._closures.length !== 0 && (funcDef._flags & 8) === 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "var $this = this;\n", null);
		}
		locals = funcDef._locals;
		for (i = 0; i < locals.length; ++ i) {
			type = locals[i]._type;
			if (type == null) {
				continue;
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "var " + $this._namer.getNameOfLocalVariable$LLocalVariable$(locals[i]) + ";\n", null);
		}
		statements = funcDef._statements;
		for (i = 0; i < statements.length; ++ i) {
			statement$0 = statements[i];
			emitter$0 = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$($this, statement$0);
			emitter$0.emit$();
		}
		if ($this._enableProfiler) {
			if (statements.length === 0 || ! (statements[statements.length - 1] instanceof ReturnStatement)) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "$__jsx_profiler.exit();\n", null);
			}
		}
	} finally {
		$this._emittingFunction = prevEmittingFunction;
	}
};

JavaScriptEmitter._emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$ = JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$;

JavaScriptEmitter.prototype._emitStaticMemberVariable$LMemberVariableDefinition$ = function (variable) {
	var initialValue;
	initialValue = variable._initialValue;
	if (initialValue != null && ! (initialValue instanceof NullExpression || initialValue instanceof BooleanLiteralExpression || initialValue instanceof IntegerLiteralExpression || initialValue instanceof NumberLiteralExpression || initialValue instanceof StringLiteralExpression || initialValue instanceof RegExpLiteralExpression)) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "$__jsx_lazy_init(", variable._nameToken);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(variable._classDef) + ", \"" + this._namer.getNameOfStaticVariable$LClassDefinition$S(variable._classDef, variable._nameToken._value) + "\", function () {\n", variable._nameToken);
		++ this._indent;
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "return ", variable._nameToken);
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(this, initialValue, variable.getType$());
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ";\n", variable._nameToken);
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$(this);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "});\n", variable._nameToken);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(variable._classDef) + "." + this._namer.getNameOfStaticVariable$LClassDefinition$S(variable._classDef, variable._nameToken._value) + " = ", variable._nameToken);
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(this, initialValue, variable.getType$());
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ";\n", initialValue._token);
	}
};


function JavaScriptEmitter$_emitStaticMemberVariable$LJavaScriptEmitter$LMemberVariableDefinition$($this, variable) {
	var initialValue;
	initialValue = variable._initialValue;
	if (initialValue != null && ! (initialValue instanceof NullExpression || initialValue instanceof BooleanLiteralExpression || initialValue instanceof IntegerLiteralExpression || initialValue instanceof NumberLiteralExpression || initialValue instanceof StringLiteralExpression || initialValue instanceof RegExpLiteralExpression)) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "$__jsx_lazy_init(", variable._nameToken);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(variable._classDef) + ", \"" + $this._namer.getNameOfStaticVariable$LClassDefinition$S(variable._classDef, variable._nameToken._value) + "\", function () {\n", variable._nameToken);
		++ $this._indent;
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "return ", variable._nameToken);
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$($this, initialValue, variable.getType$());
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ";\n", variable._nameToken);
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "});\n", variable._nameToken);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(variable._classDef) + "." + $this._namer.getNameOfStaticVariable$LClassDefinition$S(variable._classDef, variable._nameToken._value) + " = ", variable._nameToken);
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$($this, initialValue, variable.getType$());
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ";\n", initialValue._token);
	}
};

JavaScriptEmitter._emitStaticMemberVariable$LJavaScriptEmitter$LMemberVariableDefinition$ = JavaScriptEmitter$_emitStaticMemberVariable$LJavaScriptEmitter$LMemberVariableDefinition$;

JavaScriptEmitter.prototype._emitStatements$ALStatement$ = function (statements) {
	var i;
	var statement$0;
	var emitter$0;
	++ this._indent;
	for (i = 0; i < statements.length; ++ i) {
		statement$0 = statements[i];
		emitter$0 = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$(this, statement$0);
		emitter$0.emit$();
	}
	JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$(this);
};


function JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$($this, statements) {
	var i;
	var statement$0;
	var emitter$0;
	++ $this._indent;
	for (i = 0; i < statements.length; ++ i) {
		statement$0 = statements[i];
		emitter$0 = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$($this, statement$0);
		emitter$0.emit$();
	}
	JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this);
};

JavaScriptEmitter._emitStatements$LJavaScriptEmitter$ALStatement$ = JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$;

JavaScriptEmitter.prototype._emitStatement$LStatement$ = function (statement) {
	var emitter;
	emitter = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$(this, statement);
	emitter.emit$();
};


function JavaScriptEmitter$_emitStatement$LJavaScriptEmitter$LStatement$($this, statement) {
	var emitter;
	emitter = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$($this, statement);
	emitter.emit$();
};

JavaScriptEmitter._emitStatement$LJavaScriptEmitter$LStatement$ = JavaScriptEmitter$_emitStatement$LJavaScriptEmitter$LStatement$;

JavaScriptEmitter.prototype._addSourceMapping$LToken$ = function (token) {
	SourceMapper$add$LSourceMapper$SNNUSUS(this._sourceMapper, this._output, token._lineNumber, token._columnNumber, token._isIdentifier ? token._value : null, token._filename);
};


function JavaScriptEmitter$_addSourceMapping$LJavaScriptEmitter$LToken$($this, token) {
	SourceMapper$add$LSourceMapper$SNNUSUS($this._sourceMapper, $this._output, token._lineNumber, token._columnNumber, token._isIdentifier ? token._value : null, token._filename);
};

JavaScriptEmitter._addSourceMapping$LJavaScriptEmitter$LToken$ = JavaScriptEmitter$_addSourceMapping$LJavaScriptEmitter$LToken$;

JavaScriptEmitter.prototype._emit$SLToken$ = function (str, token) {
	var $this = this;
	if (str === "") {
		return;
	}
	if (this._outputEndsWithReturn && this._indent !== 0) {
		this._output += JavaScriptEmitter$_getIndent$LJavaScriptEmitter$(this);
		this._outputEndsWithReturn = false;
	}
	if (this._sourceMapper != null && token != null) {
		SourceMapper$add$LSourceMapper$SNNUSUS(this._sourceMapper, this._output, token._lineNumber, token._columnNumber, token._isIdentifier ? token._value : null, token._filename);
	}
	str = str.replace(/\n(.)/g, (function (m) {
		return "\n" + JavaScriptEmitter$_getIndent$LJavaScriptEmitter$($this) + m.substring(1);
	}));
	this._output += str;
	this._outputEndsWithReturn = str.charAt(str.length - 1) === "\n";
};


function JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, str, token) {
	if (str === "") {
		return;
	}
	if ($this._outputEndsWithReturn && $this._indent !== 0) {
		$this._output += JavaScriptEmitter$_getIndent$LJavaScriptEmitter$($this);
		$this._outputEndsWithReturn = false;
	}
	if ($this._sourceMapper != null && token != null) {
		SourceMapper$add$LSourceMapper$SNNUSUS($this._sourceMapper, $this._output, token._lineNumber, token._columnNumber, token._isIdentifier ? token._value : null, token._filename);
	}
	str = str.replace(/\n(.)/g, (function (m) {
		return "\n" + JavaScriptEmitter$_getIndent$LJavaScriptEmitter$($this) + m.substring(1);
	}));
	$this._output += str;
	$this._outputEndsWithReturn = str.charAt(str.length - 1) === "\n";
};

JavaScriptEmitter._emit$LJavaScriptEmitter$SLToken$ = JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$;

JavaScriptEmitter.prototype._advanceIndent$ = function () {
	++ this._indent;
};


function JavaScriptEmitter$_advanceIndent$LJavaScriptEmitter$($this) {
	++ $this._indent;
};

JavaScriptEmitter._advanceIndent$LJavaScriptEmitter$ = JavaScriptEmitter$_advanceIndent$LJavaScriptEmitter$;

JavaScriptEmitter.prototype._reduceIndent$ = function () {
	if (-- this._indent < 0) {
		throw new Error("indent mistach");
	}
};


function JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this) {
	if (-- $this._indent < 0) {
		throw new Error("indent mistach");
	}
};

JavaScriptEmitter._reduceIndent$LJavaScriptEmitter$ = JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$;

JavaScriptEmitter.prototype._getIndent$ = function () {
	var s;
	var i;
	s = "";
	for (i = 0; i < this._indent; ++ i) {
		s += "\t";
	}
	return s;
};


function JavaScriptEmitter$_getIndent$LJavaScriptEmitter$($this) {
	var s;
	var i;
	s = "";
	for (i = 0; i < $this._indent; ++ i) {
		s += "\t";
	}
	return s;
};

JavaScriptEmitter._getIndent$LJavaScriptEmitter$ = JavaScriptEmitter$_getIndent$LJavaScriptEmitter$;

JavaScriptEmitter.prototype._getStatementEmitterFor$LStatement$ = function (statement) {
	if (statement instanceof ConstructorInvocationStatement) {
		return new _ConstructorInvocationStatementEmitter(this, statement);
	} else {
		if (statement instanceof ExpressionStatement) {
			return new _ExpressionStatementEmitter(this, statement);
		} else {
			if (statement instanceof FunctionStatement) {
				return new _FunctionStatementEmitter(this, statement);
			} else {
				if (statement instanceof ReturnStatement) {
					return new _ReturnStatementEmitter(this, statement);
				} else {
					if (statement instanceof DeleteStatement) {
						return new _DeleteStatementEmitter(this, statement);
					} else {
						if (statement instanceof BreakStatement) {
							return new _BreakStatementEmitter(this, statement);
						} else {
							if (statement instanceof ContinueStatement) {
								return new _ContinueStatementEmitter(this, statement);
							} else {
								if (statement instanceof DoWhileStatement) {
									return new _DoWhileStatementEmitter(this, statement);
								} else {
									if (statement instanceof ForInStatement) {
										return new _ForInStatementEmitter(this, statement);
									} else {
										if (statement instanceof ForStatement) {
											return new _ForStatementEmitter(this, statement);
										} else {
											if (statement instanceof IfStatement) {
												return new _IfStatementEmitter(this, statement);
											} else {
												if (statement instanceof SwitchStatement) {
													return new _SwitchStatementEmitter(this, statement);
												} else {
													if (statement instanceof CaseStatement) {
														return new _CaseStatementEmitter(this, statement);
													} else {
														if (statement instanceof DefaultStatement) {
															return new _DefaultStatementEmitter(this, statement);
														} else {
															if (statement instanceof WhileStatement) {
																return new _WhileStatementEmitter(this, statement);
															} else {
																if (statement instanceof TryStatement) {
																	return new _TryStatementEmitter(this, statement);
																} else {
																	if (statement instanceof CatchStatement) {
																		return new _CatchStatementEmitter(this, statement);
																	} else {
																		if (statement instanceof ThrowStatement) {
																			return new _ThrowStatementEmitter(this, statement);
																		} else {
																			if (statement instanceof AssertStatement) {
																				return new _AssertStatementEmitter(this, statement);
																			} else {
																				if (statement instanceof LogStatement) {
																					return new _LogStatementEmitter(this, statement);
																				} else {
																					if (statement instanceof DebuggerStatement) {
																						return new _DebuggerStatementEmitter(this, statement);
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	throw new Error("got unexpected type of statement: " + JSON.stringify(statement.serialize$()));
};


function JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$($this, statement) {
	if (statement instanceof ConstructorInvocationStatement) {
		return new _ConstructorInvocationStatementEmitter($this, statement);
	} else {
		if (statement instanceof ExpressionStatement) {
			return new _ExpressionStatementEmitter($this, statement);
		} else {
			if (statement instanceof FunctionStatement) {
				return new _FunctionStatementEmitter($this, statement);
			} else {
				if (statement instanceof ReturnStatement) {
					return new _ReturnStatementEmitter($this, statement);
				} else {
					if (statement instanceof DeleteStatement) {
						return new _DeleteStatementEmitter($this, statement);
					} else {
						if (statement instanceof BreakStatement) {
							return new _BreakStatementEmitter($this, statement);
						} else {
							if (statement instanceof ContinueStatement) {
								return new _ContinueStatementEmitter($this, statement);
							} else {
								if (statement instanceof DoWhileStatement) {
									return new _DoWhileStatementEmitter($this, statement);
								} else {
									if (statement instanceof ForInStatement) {
										return new _ForInStatementEmitter($this, statement);
									} else {
										if (statement instanceof ForStatement) {
											return new _ForStatementEmitter($this, statement);
										} else {
											if (statement instanceof IfStatement) {
												return new _IfStatementEmitter($this, statement);
											} else {
												if (statement instanceof SwitchStatement) {
													return new _SwitchStatementEmitter($this, statement);
												} else {
													if (statement instanceof CaseStatement) {
														return new _CaseStatementEmitter($this, statement);
													} else {
														if (statement instanceof DefaultStatement) {
															return new _DefaultStatementEmitter($this, statement);
														} else {
															if (statement instanceof WhileStatement) {
																return new _WhileStatementEmitter($this, statement);
															} else {
																if (statement instanceof TryStatement) {
																	return new _TryStatementEmitter($this, statement);
																} else {
																	if (statement instanceof CatchStatement) {
																		return new _CatchStatementEmitter($this, statement);
																	} else {
																		if (statement instanceof ThrowStatement) {
																			return new _ThrowStatementEmitter($this, statement);
																		} else {
																			if (statement instanceof AssertStatement) {
																				return new _AssertStatementEmitter($this, statement);
																			} else {
																				if (statement instanceof LogStatement) {
																					return new _LogStatementEmitter($this, statement);
																				} else {
																					if (statement instanceof DebuggerStatement) {
																						return new _DebuggerStatementEmitter($this, statement);
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	throw new Error("got unexpected type of statement: " + JSON.stringify(statement.serialize$()));
};

JavaScriptEmitter._getStatementEmitterFor$LJavaScriptEmitter$LStatement$ = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$;

JavaScriptEmitter.prototype._getExpressionEmitterFor$LExpression$ = function (expr) {
	if (expr instanceof LocalExpression) {
		return new _LocalExpressionEmitter(this, expr);
	} else {
		if (expr instanceof ClassExpression) {
			return new _ClassExpressionEmitter(this, expr);
		} else {
			if (expr instanceof NullExpression) {
				return new _NullExpressionEmitter(this, expr);
			} else {
				if (expr instanceof BooleanLiteralExpression) {
					return new _BooleanLiteralExpressionEmitter(this, expr);
				} else {
					if (expr instanceof IntegerLiteralExpression) {
						return new _IntegerLiteralExpressionEmitter(this, expr);
					} else {
						if (expr instanceof NumberLiteralExpression) {
							return new _NumberLiteralExpressionEmitter(this, expr);
						} else {
							if (expr instanceof StringLiteralExpression) {
								return new _StringLiteralExpressionEmitter(this, expr);
							} else {
								if (expr instanceof RegExpLiteralExpression) {
									return new _RegExpLiteralExpressionEmitter(this, expr);
								} else {
									if (expr instanceof ArrayLiteralExpression) {
										return new _ArrayLiteralExpressionEmitter(this, expr);
									} else {
										if (expr instanceof MapLiteralExpression) {
											return new _MapLiteralExpressionEmitter(this, expr);
										} else {
											if (expr instanceof ThisExpression) {
												return new _ThisExpressionEmitter(this, expr);
											} else {
												if (expr instanceof BitwiseNotExpression) {
													return new _UnaryExpressionEmitter(this, expr);
												} else {
													if (expr instanceof InstanceofExpression) {
														return new _InstanceofExpressionEmitter(this, expr);
													} else {
														if (expr instanceof AsExpression) {
															return new _AsExpressionEmitter(this, expr);
														} else {
															if (expr instanceof AsNoConvertExpression) {
																return new _AsNoConvertExpressionEmitter(this, expr);
															} else {
																if (expr instanceof LogicalNotExpression) {
																	return new _UnaryExpressionEmitter(this, expr);
																} else {
																	if (expr instanceof TypeofExpression) {
																		return new _UnaryExpressionEmitter(this, expr);
																	} else {
																		if (expr instanceof PostIncrementExpression) {
																			return new _PostfixExpressionEmitter(this, expr);
																		} else {
																			if (expr instanceof PreIncrementExpression) {
																				return new _UnaryExpressionEmitter(this, expr);
																			} else {
																				if (expr instanceof PropertyExpression) {
																					return new _PropertyExpressionEmitter(this, expr);
																				} else {
																					if (expr instanceof SignExpression) {
																						return new _UnaryExpressionEmitter(this, expr);
																					} else {
																						if (expr instanceof AdditiveExpression) {
																							return new _AdditiveExpressionEmitter(this, expr);
																						} else {
																							if (expr instanceof ArrayExpression) {
																								return new _ArrayExpressionEmitter(this, expr);
																							} else {
																								if (expr instanceof AssignmentExpression) {
																									return new _AssignmentExpressionEmitter(this, expr);
																								} else {
																									if (expr instanceof BinaryNumberExpression) {
																										return new _BinaryNumberExpressionEmitter(this, expr);
																									} else {
																										if (expr instanceof EqualityExpression) {
																											return new _EqualityExpressionEmitter(this, expr);
																										} else {
																											if (expr instanceof InExpression) {
																												return new _InExpressionEmitter(this, expr);
																											} else {
																												if (expr instanceof LogicalExpression) {
																													return new _LogicalExpressionEmitter(this, expr);
																												} else {
																													if (expr instanceof ShiftExpression) {
																														return new _ShiftExpressionEmitter(this, expr);
																													} else {
																														if (expr instanceof ConditionalExpression) {
																															return new _ConditionalExpressionEmitter(this, expr);
																														} else {
																															if (expr instanceof CallExpression) {
																																return new _CallExpressionEmitter(this, expr);
																															} else {
																																if (expr instanceof SuperExpression) {
																																	return new _SuperExpressionEmitter(this, expr);
																																} else {
																																	if (expr instanceof NewExpression) {
																																		return new _NewExpressionEmitter(this, expr);
																																	} else {
																																		if (expr instanceof FunctionExpression) {
																																			return new _FunctionExpressionEmitter(this, expr);
																																		} else {
																																			if (expr instanceof CommaExpression) {
																																				return new _CommaExpressionEmitter(this, expr);
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	throw new Error("got unexpected type of expression: " + (expr != null ? JSON.stringify(expr.serialize$()) : expr.toString()));
};


function JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr) {
	if (expr instanceof LocalExpression) {
		return new _LocalExpressionEmitter($this, expr);
	} else {
		if (expr instanceof ClassExpression) {
			return new _ClassExpressionEmitter($this, expr);
		} else {
			if (expr instanceof NullExpression) {
				return new _NullExpressionEmitter($this, expr);
			} else {
				if (expr instanceof BooleanLiteralExpression) {
					return new _BooleanLiteralExpressionEmitter($this, expr);
				} else {
					if (expr instanceof IntegerLiteralExpression) {
						return new _IntegerLiteralExpressionEmitter($this, expr);
					} else {
						if (expr instanceof NumberLiteralExpression) {
							return new _NumberLiteralExpressionEmitter($this, expr);
						} else {
							if (expr instanceof StringLiteralExpression) {
								return new _StringLiteralExpressionEmitter($this, expr);
							} else {
								if (expr instanceof RegExpLiteralExpression) {
									return new _RegExpLiteralExpressionEmitter($this, expr);
								} else {
									if (expr instanceof ArrayLiteralExpression) {
										return new _ArrayLiteralExpressionEmitter($this, expr);
									} else {
										if (expr instanceof MapLiteralExpression) {
											return new _MapLiteralExpressionEmitter($this, expr);
										} else {
											if (expr instanceof ThisExpression) {
												return new _ThisExpressionEmitter($this, expr);
											} else {
												if (expr instanceof BitwiseNotExpression) {
													return new _UnaryExpressionEmitter($this, expr);
												} else {
													if (expr instanceof InstanceofExpression) {
														return new _InstanceofExpressionEmitter($this, expr);
													} else {
														if (expr instanceof AsExpression) {
															return new _AsExpressionEmitter($this, expr);
														} else {
															if (expr instanceof AsNoConvertExpression) {
																return new _AsNoConvertExpressionEmitter($this, expr);
															} else {
																if (expr instanceof LogicalNotExpression) {
																	return new _UnaryExpressionEmitter($this, expr);
																} else {
																	if (expr instanceof TypeofExpression) {
																		return new _UnaryExpressionEmitter($this, expr);
																	} else {
																		if (expr instanceof PostIncrementExpression) {
																			return new _PostfixExpressionEmitter($this, expr);
																		} else {
																			if (expr instanceof PreIncrementExpression) {
																				return new _UnaryExpressionEmitter($this, expr);
																			} else {
																				if (expr instanceof PropertyExpression) {
																					return new _PropertyExpressionEmitter($this, expr);
																				} else {
																					if (expr instanceof SignExpression) {
																						return new _UnaryExpressionEmitter($this, expr);
																					} else {
																						if (expr instanceof AdditiveExpression) {
																							return new _AdditiveExpressionEmitter($this, expr);
																						} else {
																							if (expr instanceof ArrayExpression) {
																								return new _ArrayExpressionEmitter($this, expr);
																							} else {
																								if (expr instanceof AssignmentExpression) {
																									return new _AssignmentExpressionEmitter($this, expr);
																								} else {
																									if (expr instanceof BinaryNumberExpression) {
																										return new _BinaryNumberExpressionEmitter($this, expr);
																									} else {
																										if (expr instanceof EqualityExpression) {
																											return new _EqualityExpressionEmitter($this, expr);
																										} else {
																											if (expr instanceof InExpression) {
																												return new _InExpressionEmitter($this, expr);
																											} else {
																												if (expr instanceof LogicalExpression) {
																													return new _LogicalExpressionEmitter($this, expr);
																												} else {
																													if (expr instanceof ShiftExpression) {
																														return new _ShiftExpressionEmitter($this, expr);
																													} else {
																														if (expr instanceof ConditionalExpression) {
																															return new _ConditionalExpressionEmitter($this, expr);
																														} else {
																															if (expr instanceof CallExpression) {
																																return new _CallExpressionEmitter($this, expr);
																															} else {
																																if (expr instanceof SuperExpression) {
																																	return new _SuperExpressionEmitter($this, expr);
																																} else {
																																	if (expr instanceof NewExpression) {
																																		return new _NewExpressionEmitter($this, expr);
																																	} else {
																																		if (expr instanceof FunctionExpression) {
																																			return new _FunctionExpressionEmitter($this, expr);
																																		} else {
																																			if (expr instanceof CommaExpression) {
																																				return new _CommaExpressionEmitter($this, expr);
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	throw new Error("got unexpected type of expression: " + (expr != null ? JSON.stringify(expr.serialize$()) : expr.toString()));
};

JavaScriptEmitter._getExpressionEmitterFor$LJavaScriptEmitter$LExpression$ = JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$;

JavaScriptEmitter.prototype._emitCallArguments$LToken$SALExpression$ALType$ = function (token, prefix, args, argTypes) {
	var i;
	var argType;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, prefix, token);
	for (i = 0; i < args.length; ++ i) {
		if (i !== 0 || prefix.charAt(prefix.length - 1) !== '(') {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ", ", null);
		}
		argType = null;
		if (argTypes != null) {
			if (i < argTypes.length) {
				argType = argTypes[i];
			} else {
				if (argTypes.length !== 0 && argTypes[argTypes.length - 1] instanceof VariableLengthArgumentType) {
					argType = argTypes[argTypes.length - 1];
				}
			}
			if (argType instanceof VariableLengthArgumentType) {
				argType = argType._baseType;
			}
		}
		if (argType != null && ! (Type.nullType, argType instanceof NullableType || argType instanceof ObjectType || argType instanceof VariantType || argType instanceof StaticFunctionType)) {
			JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(this, args[i], argType);
		} else {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, args[i]).emit$N(0);
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ")", token);
};


function JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$($this, token, prefix, args, argTypes) {
	var i;
	var argType;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, prefix, token);
	for (i = 0; i < args.length; ++ i) {
		if (i !== 0 || prefix.charAt(prefix.length - 1) !== '(') {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ", ", null);
		}
		argType = null;
		if (argTypes != null) {
			if (i < argTypes.length) {
				argType = argTypes[i];
			} else {
				if (argTypes.length !== 0 && argTypes[argTypes.length - 1] instanceof VariableLengthArgumentType) {
					argType = argTypes[argTypes.length - 1];
				}
			}
			if (argType instanceof VariableLengthArgumentType) {
				argType = argType._baseType;
			}
		}
		if (argType != null && ! (Type.nullType, argType instanceof NullableType || argType instanceof ObjectType || argType instanceof VariantType || argType instanceof StaticFunctionType)) {
			JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$($this, args[i], argType);
		} else {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, args[i]).emit$N(0);
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ")", token);
};

JavaScriptEmitter._emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$ = JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$;

JavaScriptEmitter.prototype._emitAssertion$F$V$LToken$S = function (emitTestExpr, token, message) {
	var s;
	var err;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "if (! (", token);
	emitTestExpr();
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ")) {\n", null);
	++ this._indent;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "debugger;\n", null);
	s = Util$makeErrorMessage$LPlatform$SUSNNN(this._platform, message, token._filename, token._lineNumber, token._columnNumber, token._value.length);
	err = Util$format$SAS('throw new Error(%1);\n', [ Util$encodeStringLiteral$S(s) ]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, err, token);
	JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$(this);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "}\n", null);
};


function JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S($this, emitTestExpr, token, message) {
	var s;
	var err;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "if (! (", token);
	emitTestExpr();
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ")) {\n", null);
	++ $this._indent;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "debugger;\n", null);
	s = Util$makeErrorMessage$LPlatform$SUSNNN($this._platform, message, token._filename, token._lineNumber, token._columnNumber, token._value.length);
	err = Util$format$SAS('throw new Error(%1);\n', [ Util$encodeStringLiteral$S(s) ]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, err, token);
	JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "}\n", null);
};

JavaScriptEmitter._emitAssertion$LJavaScriptEmitter$F$V$LToken$S = JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S;

JavaScriptEmitter.prototype._emitAssertionWithMsg$F$V$LToken$SLExpression$ = function (emitTestExpr, token, message, msgExpr) {
	var s;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "if (! (", token);
	emitTestExpr();
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ")) {\n", null);
	++ this._indent;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "debugger;\n", null);
	s = Util$makeErrorMessage$LPlatform$SUSNNN(this._platform, message + ": {MSG}", token._filename, token._lineNumber, token._columnNumber, token._value.length).split("{MSG}");
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, Util$format$SAS('throw new Error(%1 + ', [ Util$encodeStringLiteral$S(s[0]) ]), token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, msgExpr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, Util$format$SAS(' + %1);\n', [ Util$encodeStringLiteral$S(s[1]) ]), token);
	JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$(this);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "}\n", null);
};


function JavaScriptEmitter$_emitAssertionWithMsg$LJavaScriptEmitter$F$V$LToken$SLExpression$($this, emitTestExpr, token, message, msgExpr) {
	var s;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "if (! (", token);
	emitTestExpr();
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ")) {\n", null);
	++ $this._indent;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "debugger;\n", null);
	s = Util$makeErrorMessage$LPlatform$SUSNNN($this._platform, message + ": {MSG}", token._filename, token._lineNumber, token._columnNumber, token._value.length).split("{MSG}");
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, Util$format$SAS('throw new Error(%1 + ', [ Util$encodeStringLiteral$S(s[0]) ]), token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, msgExpr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, Util$format$SAS(' + %1);\n', [ Util$encodeStringLiteral$S(s[1]) ]), token);
	JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "}\n", null);
};

JavaScriptEmitter._emitAssertionWithMsg$LJavaScriptEmitter$F$V$LToken$SLExpression$ = JavaScriptEmitter$_emitAssertionWithMsg$LJavaScriptEmitter$F$V$LToken$SLExpression$;

JavaScriptEmitter.prototype._emitWithNullableGuard$LExpression$N = function (expr, outerOpPrecedence) {
	var $this = this;
	var token;
	if (this._enableRunTimeTypeCheck && expr.getType$() instanceof NullableType) {
		token = expr._token;
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "(function (v) {\n", token);
		++ this._indent;
		JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S(this, (function () {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "v != null", token);
		}), token, "null access");
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "return v;\n", token);
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$(this);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "}(", token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, expr).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "))", token);
	} else {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, expr).emit$N(outerOpPrecedence);
	}
};


function JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this, expr, outerOpPrecedence) {
	var token;
	if ($this._enableRunTimeTypeCheck && expr.getType$() instanceof NullableType) {
		token = expr._token;
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "(function (v) {\n", token);
		++ $this._indent;
		JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S($this, (function () {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "v != null", token);
		}), token, "null access");
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "return v;\n", token);
		JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "}(", token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "))", token);
	} else {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr).emit$N(outerOpPrecedence);
	}
};

JavaScriptEmitter._emitWithNullableGuard$LJavaScriptEmitter$LExpression$N = JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N;

JavaScriptEmitter.prototype._emitRHSOfAssignment$LExpression$LType$ = function (expr, lhsType) {
	var exprType;
	exprType = expr.getType$();
	if ((lhsType instanceof NullableType ? lhsType._baseType : lhsType).equals$LType$(Type.integerType) && exprType.equals$LType$(Type.numberType)) {
		if (expr instanceof NumberLiteralExpression || expr instanceof IntegerLiteralExpression) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, (expr._token._value | 0).toString(), expr._token);
		} else {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "(", expr._token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, expr).emit$N(_BinaryNumberExpressionEmitter._operatorPrecedence["|"]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, " | 0)", expr._token);
		}
		return;
	}
	if (lhsType.equals$LType$(Type.integerType) && (exprType instanceof NullableType ? exprType._baseType : exprType).equals$LType$(Type.numberType)) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "(", expr._token);
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this, expr, _BinaryNumberExpressionEmitter._operatorPrecedence["|"]);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, " | 0)", expr._token);
		return;
	}
	if (lhsType instanceof NullableType && lhsType._baseType.equals$LType$(Type.integerType) && (exprType instanceof NullableType && exprType._baseType.equals$LType$(Type.numberType))) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "(function (v) { return v != null ? v | 0 : v; })(", expr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, expr).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ")", expr._token);
		return;
	}
	if (lhsType.equals$LType$(Type.variantType) || lhsType instanceof NullableType) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, expr).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
	} else {
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this, expr, _AssignmentExpressionEmitter._operatorPrecedence["="]);
	}
};


function JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$($this, expr, lhsType) {
	var exprType;
	exprType = expr.getType$();
	if ((lhsType instanceof NullableType ? lhsType._baseType : lhsType).equals$LType$(Type.integerType) && exprType.equals$LType$(Type.numberType)) {
		if (expr instanceof NumberLiteralExpression || expr instanceof IntegerLiteralExpression) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, (expr._token._value | 0).toString(), expr._token);
		} else {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "(", expr._token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr).emit$N(_BinaryNumberExpressionEmitter._operatorPrecedence["|"]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, " | 0)", expr._token);
		}
		return;
	}
	if (lhsType.equals$LType$(Type.integerType) && (exprType instanceof NullableType ? exprType._baseType : exprType).equals$LType$(Type.numberType)) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "(", expr._token);
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this, expr, _BinaryNumberExpressionEmitter._operatorPrecedence["|"]);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, " | 0)", expr._token);
		return;
	}
	if (lhsType instanceof NullableType && lhsType._baseType.equals$LType$(Type.integerType) && (exprType instanceof NullableType && exprType._baseType.equals$LType$(Type.numberType))) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "(function (v) { return v != null ? v | 0 : v; })(", expr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ")", expr._token);
		return;
	}
	if (lhsType.equals$LType$(Type.variantType) || lhsType instanceof NullableType) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
	} else {
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this, expr, _AssignmentExpressionEmitter._operatorPrecedence["="]);
	}
};

JavaScriptEmitter._emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$ = JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$;

function JavaScriptEmitter$_initialize$() {
	var precedence;
	var i;
	var opTypeList;
	var j;
	var key;
	if (JavaScriptEmitter._initialized) {
		return;
	}
	JavaScriptEmitter._initialized = true;
	precedence = [ [ ({ "new": _NewExpressionEmitter$_setOperatorPrecedence$SN }), ({ "[": _ArrayExpressionEmitter$_setOperatorPrecedence$SN }), ({ ".": _PropertyExpressionEmitter$_setOperatorPrecedence$SN }), ({ "(": _CallExpressionEmitter$_setOperatorPrecedence$SN }), ({ "super": _SuperExpressionEmitter$_setOperatorPrecedence$SN }), ({ "function": _FunctionExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "++": _PostfixExpressionEmitter$_setOperatorPrecedence$SN }), ({ "--": _PostfixExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "void": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "typeof": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "++": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "--": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "+": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "-": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "~": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "!": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "*": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ "/": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ "%": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "+": _AdditiveExpressionEmitter$_setOperatorPrecedence$SN }), ({ "-": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "<<": _ShiftExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">>": _ShiftExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">>>": _ShiftExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "<": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ "<=": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">=": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ "instanceof": _InstanceofExpressionEmitter$_setOperatorPrecedence$SN }), ({ "in": _InExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "==": _EqualityExpressionEmitter$_setOperatorPrecedence$SN }), ({ "!=": _EqualityExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "&": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "^": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "|": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "&&": _LogicalExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "||": _LogicalExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "*=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "/=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "%=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "+=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "-=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "<<=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">>=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">>>=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "&=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "^=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "|=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "?": _ConditionalExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ ",": _CommaExpressionEmitter$_setOperatorPrecedence$SN }) ] ];
	for (i = 0; i < precedence.length; ++ i) {
		opTypeList = precedence[i];
		for (j = 0; j < opTypeList.length; ++ j) {
			for (key in opTypeList[j]) {
				opTypeList[j][key](key, - (precedence.length - i));
			}
		}
	}
};

JavaScriptEmitter._initialize$ = JavaScriptEmitter$_initialize$;

function LocalVariable(name, type) {
	this._stash = {};
	this.isInstantiated = false;
	this._name = name;
	this._type = type;
	this._instantiated = [];
};

$__jsx_extend([LocalVariable], Object);
$__jsx_merge_interface(LocalVariable, Stashable);

LocalVariable.prototype.serialize$ = function () {
	var serializeNullable$v$0;
	return [ this._name, (serializeNullable$v$0 = this._type, serializeNullable$v$0 == null ? null : serializeNullable$v$0.toString()) ];
};


function LocalVariable$serialize$LLocalVariable$($this) {
	var serializeNullable$v$0;
	return [ $this._name, (serializeNullable$v$0 = $this._type, serializeNullable$v$0 == null ? null : serializeNullable$v$0.toString()) ];
};

LocalVariable.serialize$LLocalVariable$ = LocalVariable$serialize$LLocalVariable$;

LocalVariable.prototype.getName$ = function () {
	return this._name;
};


function LocalVariable$getName$LLocalVariable$($this) {
	return $this._name;
};

LocalVariable.getName$LLocalVariable$ = LocalVariable$getName$LLocalVariable$;

LocalVariable.prototype.getType$ = function () {
	return this._type;
};


function LocalVariable$getType$LLocalVariable$($this) {
	return $this._type;
};

LocalVariable.getType$LLocalVariable$ = LocalVariable$getType$LLocalVariable$;

LocalVariable.prototype.setType$LType$ = function (type) {
	if (this._type != null) {
		throw new Error("type is already set for " + (this._name._value + " : " + this._type.toString()));
	}
	if (type.equals$LType$(Type.integerType)) {
		type = Type.numberType;
	}
	this._type = type;
};


function LocalVariable$setType$LLocalVariable$LType$($this, type) {
	if ($this._type != null) {
		throw new Error("type is already set for " + ($this._name._value + " : " + $this._type.toString()));
	}
	if (type.equals$LType$(Type.integerType)) {
		type = Type.numberType;
	}
	$this._type = type;
};

LocalVariable.setType$LLocalVariable$LType$ = LocalVariable$setType$LLocalVariable$LType$;

LocalVariable.prototype.setTypeForced$LType$ = function (type) {
	this._type = type;
};


function LocalVariable$setTypeForced$LLocalVariable$LType$($this, type) {
	$this._type = type;
};

LocalVariable.setTypeForced$LLocalVariable$LType$ = LocalVariable$setTypeForced$LLocalVariable$LType$;

LocalVariable.prototype.touchVariable$LAnalysisContext$LToken$B = function (context, token, isAssignment) {
	var blockStack$0;
	var blockStack$1;
	if (isAssignment) {
		LocalVariableStatuses$setStatus$LLocalVariableStatuses$LLocalVariable$((blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses, this);
	} else {
		switch (LocalVariableStatuses$getStatus$LLocalVariableStatuses$LLocalVariable$((blockStack$1 = context.blockStack)[blockStack$1.length - 1].localVariableStatuses, this)) {
		case -1:
			context.errors.push(new CompileError(token, "the return type of recursive function needs to be explicitly declared"));
			return false;
		case 1:
			break;
		case 0:
			context.errors.push(new CompileError(token, "variable is not initialized"));
			return false;
		case 2:
			context.errors.push(new CompileError(token, "variable may not be initialized"));
			return false;
		default:
			throw new Error("logic flaw");
		}
	}
	return true;
};


LocalVariable.prototype.toString = function () {
	return this._name._value + " : " + this._type.toString();
};


LocalVariable.prototype.popInstantiated$ = function () {
	this._instantiated.pop();
};


function LocalVariable$popInstantiated$LLocalVariable$($this) {
	$this._instantiated.pop();
};

LocalVariable.popInstantiated$LLocalVariable$ = LocalVariable$popInstantiated$LLocalVariable$;

LocalVariable.prototype.getInstantiated$ = function () {
	var _instantiated$0;
	if (this._instantiated.length === 0) {
		throw new Error("logic flaw, no instantiation for " + this._name._value + "," + (this.isInstantiated + ""));
	}
	return (_instantiated$0 = this._instantiated)[_instantiated$0.length - 1];
};


function LocalVariable$getInstantiated$LLocalVariable$($this) {
	var _instantiated$0;
	if ($this._instantiated.length === 0) {
		throw new Error("logic flaw, no instantiation for " + $this._name._value + "," + ($this.isInstantiated + ""));
	}
	return (_instantiated$0 = $this._instantiated)[_instantiated$0.length - 1];
};

LocalVariable.getInstantiated$LLocalVariable$ = LocalVariable$getInstantiated$LLocalVariable$;

LocalVariable.prototype.instantiateAndPush$LInstantiationContext$ = function (instantiationContext) {
	var instantiated;
	instantiated = this._instantiate$LInstantiationContext$(instantiationContext);
	instantiated.isInstantiated = true;
	this._instantiated.push(instantiated);
	return instantiated;
};


LocalVariable.prototype._instantiate$LInstantiationContext$ = function (instantiationContext) {
	var type;
	type = (this._type != null ? this._type.instantiate$LInstantiationContext$(instantiationContext) : null);
	return new LocalVariable(this._name, type);
};


function CaughtVariable(name, type) {
	this._stash = {};
	this.isInstantiated = false;
	this._name = name;
	this._type = type;
	this._instantiated = [];
};

$__jsx_extend([CaughtVariable], LocalVariable);
CaughtVariable.prototype.clone$ = function () {
	return new CaughtVariable(this._name, this._type);
};


function CaughtVariable$clone$LCaughtVariable$($this) {
	return new CaughtVariable($this._name, $this._type);
};

CaughtVariable.clone$LCaughtVariable$ = CaughtVariable$clone$LCaughtVariable$;

CaughtVariable.prototype.touchVariable$LAnalysisContext$LToken$B = function (context, token, isAssignment) {
	return true;
};


CaughtVariable.prototype._instantiate$LInstantiationContext$ = function (instantiationContext) {
	return new CaughtVariable(this._name, this._type.instantiate$LInstantiationContext$(instantiationContext));
};


CaughtVariable.prototype.instantiateAndPush$LInstantiationContext$ = function (instantiationContext) {
	return LocalVariable.prototype.instantiateAndPush$LInstantiationContext$.call(this, instantiationContext);
};


function ArgumentDeclaration(name, type) {
	this._stash = {};
	this.isInstantiated = false;
	this._name = name;
	this._type = type;
	this._instantiated = [];
	this._defaultValue = null;
};

function ArgumentDeclaration$0(name, type, defaultValue) {
	this._stash = {};
	this.isInstantiated = false;
	this._name = name;
	this._type = type;
	this._instantiated = [];
	this._defaultValue = defaultValue;
};

$__jsx_extend([ArgumentDeclaration, ArgumentDeclaration$0], LocalVariable);
ArgumentDeclaration.prototype.clone$ = function () {
	return new ArgumentDeclaration$0(this._name, this._type, this._defaultValue);
};


function ArgumentDeclaration$clone$LArgumentDeclaration$($this) {
	return new ArgumentDeclaration$0($this._name, $this._type, $this._defaultValue);
};

ArgumentDeclaration.clone$LArgumentDeclaration$ = ArgumentDeclaration$clone$LArgumentDeclaration$;

ArgumentDeclaration.prototype.getDefaultValue$ = function () {
	return this._defaultValue;
};


function ArgumentDeclaration$getDefaultValue$LArgumentDeclaration$($this) {
	return $this._defaultValue;
};

ArgumentDeclaration.getDefaultValue$LArgumentDeclaration$ = ArgumentDeclaration$getDefaultValue$LArgumentDeclaration$;

ArgumentDeclaration.prototype._instantiate$LInstantiationContext$ = function (instantiationContext) {
	var type;
	type = (this._type != null ? this._type.instantiate$LInstantiationContext$(instantiationContext) : null);
	return new ArgumentDeclaration$0(this._name, type, this._defaultValue);
};


ArgumentDeclaration.prototype.instantiateAndPush$LInstantiationContext$ = function (instantiationContext) {
	return LocalVariable.prototype.instantiateAndPush$LInstantiationContext$.call(this, instantiationContext);
};


function LocalVariableStatuses(funcDef, base) {
	var k;
	var args;
	var i;
	var locals;
	this._isReachable = false;
	this._statuses = {};
	if (base != null) {
		for (k in base._statuses) {
			this._statuses[k] = (base._statuses[k] === 0 ? 2 : base._statuses[k]);
		}
	}
	args = funcDef._args;
	for (i = 0; i < args.length; ++ i) {
		this._statuses[args[i]._name._value] = 1;
	}
	locals = funcDef._locals;
	for (i = 0; i < locals.length; ++ i) {
		this._statuses[locals[i]._name._value] = 0;
	}
	this._isReachable = true;
};

function LocalVariableStatuses$0(srcStatus) {
	this._isReachable = false;
	this._statuses = {};
	LocalVariableStatuses$_copyFrom$LLocalVariableStatuses$LLocalVariableStatuses$(this, srcStatus);
	this._isReachable = srcStatus._isReachable;
};

$__jsx_extend([LocalVariableStatuses, LocalVariableStatuses$0], Object);
LocalVariableStatuses.prototype.clone$ = function () {
	return new LocalVariableStatuses$0(this);
};


function LocalVariableStatuses$clone$LLocalVariableStatuses$($this) {
	return new LocalVariableStatuses$0($this);
};

LocalVariableStatuses.clone$LLocalVariableStatuses$ = LocalVariableStatuses$clone$LLocalVariableStatuses$;

LocalVariableStatuses.prototype.merge$LLocalVariableStatuses$ = function (that) {
	var ret;
	var k;
	if (this._isReachable !== that._isReachable) {
		if (this._isReachable) {
			return new LocalVariableStatuses$0(this);
		} else {
			return new LocalVariableStatuses$0(that);
		}
	}
	ret = new LocalVariableStatuses$0(this);
	for (k in ret._statuses) {
		if (ret._statuses[k] === 0 && that._statuses[k] === 0) {
		} else {
			if (ret._statuses[k] === 1 && that._statuses[k] === 1) {
			} else {
				ret._statuses[k] = 2;
			}
		}
	}
	return ret;
};


function LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$($this, that) {
	var ret;
	var k;
	if ($this._isReachable !== that._isReachable) {
		if ($this._isReachable) {
			return new LocalVariableStatuses$0($this);
		} else {
			return new LocalVariableStatuses$0(that);
		}
	}
	ret = new LocalVariableStatuses$0($this);
	for (k in ret._statuses) {
		if (ret._statuses[k] === 0 && that._statuses[k] === 0) {
		} else {
			if (ret._statuses[k] === 1 && that._statuses[k] === 1) {
			} else {
				ret._statuses[k] = 2;
			}
		}
	}
	return ret;
};

LocalVariableStatuses.merge$LLocalVariableStatuses$LLocalVariableStatuses$ = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$;

LocalVariableStatuses.prototype.mergeFinally$LLocalVariableStatuses$ = function (postFinallyStats) {
	var ret;
	var k;
	ret = new LocalVariableStatuses$0(this);
	for (k in ret._statuses) {
		switch (postFinallyStats._statuses[k]) {
		case 1:
			ret._statuses[k] = 1;
			break;
		case 2:
			if (ret._statuses[k] !== 1) {
				ret._statuses[k] = 2;
			}
			break;
		}
	}
	if (! postFinallyStats._isReachable) {
		ret._isReachable = false;
	}
	return ret;
};


function LocalVariableStatuses$mergeFinally$LLocalVariableStatuses$LLocalVariableStatuses$($this, postFinallyStats) {
	var ret;
	var k;
	ret = new LocalVariableStatuses$0($this);
	for (k in ret._statuses) {
		switch (postFinallyStats._statuses[k]) {
		case 1:
			ret._statuses[k] = 1;
			break;
		case 2:
			if (ret._statuses[k] !== 1) {
				ret._statuses[k] = 2;
			}
			break;
		}
	}
	if (! postFinallyStats._isReachable) {
		ret._isReachable = false;
	}
	return ret;
};

LocalVariableStatuses.mergeFinally$LLocalVariableStatuses$LLocalVariableStatuses$ = LocalVariableStatuses$mergeFinally$LLocalVariableStatuses$LLocalVariableStatuses$;

LocalVariableStatuses.prototype.setStatus$LLocalVariable$ = function (local) {
	var name;
	var this$0;
	this$0 = local._name;
	name = this$0._value;
	if (this._statuses[name] == null) {
		throw new Error("logic flaw, could not find status for local variable: " + name);
	}
	this._statuses[name] = 1;
};


function LocalVariableStatuses$setStatus$LLocalVariableStatuses$LLocalVariable$($this, local) {
	var name;
	var this$0;
	this$0 = local._name;
	name = this$0._value;
	if ($this._statuses[name] == null) {
		throw new Error("logic flaw, could not find status for local variable: " + name);
	}
	$this._statuses[name] = 1;
};

LocalVariableStatuses.setStatus$LLocalVariableStatuses$LLocalVariable$ = LocalVariableStatuses$setStatus$LLocalVariableStatuses$LLocalVariable$;

LocalVariableStatuses.prototype.getStatus$LLocalVariable$ = function (local) {
	var name;
	var this$0;
	this$0 = local._name;
	name = this$0._value;
	if (this._statuses[name] == null) {
		throw new Error("logic flaw, could not find status for local variable: " + name);
	}
	return this._statuses[name];
};


function LocalVariableStatuses$getStatus$LLocalVariableStatuses$LLocalVariable$($this, local) {
	var name;
	var this$0;
	this$0 = local._name;
	name = this$0._value;
	if ($this._statuses[name] == null) {
		throw new Error("logic flaw, could not find status for local variable: " + name);
	}
	return $this._statuses[name];
};

LocalVariableStatuses.getStatus$LLocalVariableStatuses$LLocalVariable$ = LocalVariableStatuses$getStatus$LLocalVariableStatuses$LLocalVariable$;

LocalVariableStatuses.prototype.isReachable$ = function () {
	return this._isReachable;
};


function LocalVariableStatuses$isReachable$LLocalVariableStatuses$($this) {
	return $this._isReachable;
};

LocalVariableStatuses.isReachable$LLocalVariableStatuses$ = LocalVariableStatuses$isReachable$LLocalVariableStatuses$;

LocalVariableStatuses.prototype.setIsReachable$B = function (isReachable) {
	this._isReachable = isReachable;
};


function LocalVariableStatuses$setIsReachable$LLocalVariableStatuses$B($this, isReachable) {
	$this._isReachable = isReachable;
};

LocalVariableStatuses.setIsReachable$LLocalVariableStatuses$B = LocalVariableStatuses$setIsReachable$LLocalVariableStatuses$B;

LocalVariableStatuses.prototype._copyFrom$LLocalVariableStatuses$ = function (that) {
	var k;
	for (k in that._statuses) {
		this._statuses[k] = that._statuses[k];
	}
};


function LocalVariableStatuses$_copyFrom$LLocalVariableStatuses$LLocalVariableStatuses$($this, that) {
	var k;
	for (k in that._statuses) {
		$this._statuses[k] = that._statuses[k];
	}
};

LocalVariableStatuses._copyFrom$LLocalVariableStatuses$LLocalVariableStatuses$ = LocalVariableStatuses$_copyFrom$LLocalVariableStatuses$LLocalVariableStatuses$;

function CompileIssue(token, message) {
	this._filename = null;
	this._lineNumber = 0;
	this._columnNumber = 0;
	this._message = "";
	this._size = 0;
	if (token != null) {
		this._filename = token._filename;
		this._lineNumber = token._lineNumber;
		this._columnNumber = token._columnNumber;
		this._size = token._value.length;
		this._message = message;
	} else {
		this._filename = null;
		this._lineNumber = 0;
		this._columnNumber = -1;
		this._message = message;
		this._size = 1;
	}
};

function CompileIssue$0(filename, lineNumber, columnNumber, message) {
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message;
	this._size = 1;
};

$__jsx_extend([CompileIssue, CompileIssue$0], Object);
CompileIssue.prototype.format$LPlatform$ = function (platform) {
	return Util$makeErrorMessage$LPlatform$SUSNNN(platform, this.getPrefix$() + this._message, this._filename, this._lineNumber, this._columnNumber, this._size);
};


function CompileIssue$format$LCompileIssue$LPlatform$($this, platform) {
	return Util$makeErrorMessage$LPlatform$SUSNNN(platform, $this.getPrefix$() + $this._message, $this._filename, $this._lineNumber, $this._columnNumber, $this._size);
};

CompileIssue.format$LCompileIssue$LPlatform$ = CompileIssue$format$LCompileIssue$LPlatform$;

function CompileError(token, message) {
	CompileIssue.call(this, token, message);
	this._notes = [];
};

function CompileError$0(filename, lineNumber, columnNumber, message) {
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message;
	this._size = 1;
	this._notes = [];
};

$__jsx_extend([CompileError, CompileError$0], CompileIssue);
CompileError.prototype.addCompileNote$LCompileNote$ = function (note) {
	this._notes.push(note);
	return this;
};


function CompileError$addCompileNote$LCompileError$LCompileNote$($this, note) {
	$this._notes.push(note);
	return $this;
};

CompileError.addCompileNote$LCompileError$LCompileNote$ = CompileError$addCompileNote$LCompileError$LCompileNote$;

CompileError.prototype.addCompileNotes$ALCompileNote$ = function (notes) {
	var $this = this;
	var i$0;
	var note$0;
	for (i$0 in notes) {
		note$0 = notes[i$0];
		this._notes.push(note$0);
	}
};


function CompileError$addCompileNotes$LCompileError$ALCompileNote$($this, notes) {
	var i$0;
	var note$0;
	for (i$0 in notes) {
		note$0 = notes[i$0];
		$this._notes.push(note$0);
	}
};

CompileError.addCompileNotes$LCompileError$ALCompileNote$ = CompileError$addCompileNotes$LCompileError$ALCompileNote$;

CompileError.prototype.getCompileNotes$ = function () {
	return this._notes;
};


function CompileError$getCompileNotes$LCompileError$($this) {
	return $this._notes;
};

CompileError.getCompileNotes$LCompileError$ = CompileError$getCompileNotes$LCompileError$;

CompileError.prototype.getPrefix$ = function () {
	return "";
};


function CompileWarning(token, message) {
	CompileError.call(this, token, message);
};

function CompileWarning$0(filename, lineNumber, columnNumber, message) {
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message;
	this._size = 1;
	this._notes = [];
};

$__jsx_extend([CompileWarning, CompileWarning$0], CompileError);
CompileWarning.prototype.getPrefix$ = function () {
	return "Warning: ";
};


function DeprecatedWarning(token, message) {
	CompileWarning.call(this, token, message);
};

function DeprecatedWarning$0(filename, lineNumber, columnNumber, message) {
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message;
	this._size = 1;
	this._notes = [];
};

$__jsx_extend([DeprecatedWarning, DeprecatedWarning$0], CompileWarning);
function CompileNote(token, message) {
	CompileIssue.call(this, token, message);
};

function CompileNote$0(filename, lineNumber, columnNumber, message) {
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message;
	this._size = 1;
};

$__jsx_extend([CompileNote, CompileNote$0], CompileIssue);
CompileNote.prototype.getPrefix$ = function () {
	return "Note: ";
};


function Token(value, isIdentifier, filename, lineNumber, columnNumber) {
	this._value = value;
	this._isIdentifier = isIdentifier;
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
};

function Token$0(value) {
	Token.call(this, value, false, null, NaN, NaN);
};

function Token$1(value, isIdentifier) {
	Token.call(this, value, isIdentifier, null, NaN, NaN);
};

function Token$2(value, isIdentifier, filename) {
	this._value = value;
	this._isIdentifier = isIdentifier;
	this._filename = filename;
	this._lineNumber = NaN;
	this._columnNumber = NaN;
};

function Token$3(value, isIdentifier, filename, lineNumber) {
	this._value = value;
	this._isIdentifier = isIdentifier;
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = NaN;
};

$__jsx_extend([Token, Token$0, Token$1, Token$2, Token$3], Object);
function Token$getValue$LToken$($this) {
	return $this._value;
};

Token.getValue$LToken$ = Token$getValue$LToken$;

function Token$isIdentifier$LToken$($this) {
	return $this._isIdentifier;
};

Token.isIdentifier$LToken$ = Token$isIdentifier$LToken$;

function Token$getFilename$LToken$($this) {
	return $this._filename;
};

Token.getFilename$LToken$ = Token$getFilename$LToken$;

function Token$getLineNumber$LToken$($this) {
	return $this._lineNumber;
};

Token.getLineNumber$LToken$ = Token$getLineNumber$LToken$;

function Token$getColumnNumber$LToken$($this) {
	return $this._columnNumber;
};

Token.getColumnNumber$LToken$ = Token$getColumnNumber$LToken$;

function Token$serialize$LToken$($this) {
	return [ $this._value, $this._isIdentifier, $this._filename, $this._lineNumber, $this._columnNumber ];
};

Token.serialize$LToken$ = Token$serialize$LToken$;

function Token$getNotation$LToken$($this) {
	return "'" + $this._value + "'" + " at " + ($this._filename || "<<unknown>>") + ":" + ($this._lineNumber + "");
};

Token.getNotation$LToken$ = Token$getNotation$LToken$;

function _Lexer() {
};

$__jsx_extend([_Lexer], Object);
function _Lexer$makeAlt$AS(patterns) {
	return "(?: \n" + patterns.join("\n | \n") + "\n)\n";
};

_Lexer.makeAlt$AS = _Lexer$makeAlt$AS;

function _Lexer$quoteMeta$S(pattern) {
	return pattern.replace(/([^0-9A-Za-z_])/g, '\\$1');
};

_Lexer.quoteMeta$S = _Lexer$quoteMeta$S;

function _Lexer$rx$S(pat) {
	return new RegExp(pat.replace(/[ \t\r\n]/g, ""));
};

_Lexer.rx$S = _Lexer$rx$S;

function Import(parser) {
	this._filenameToken = null;
	this._aliasToken = null;
	this._classNames = null;
	this._sourceParsers = [ parser ];
};

function Import$0(filenameToken, aliasToken, classNames) {
	this._filenameToken = filenameToken;
	this._aliasToken = aliasToken;
	this._classNames = classNames;
	this._sourceParsers = [  ];
};

$__jsx_extend([Import, Import$0], Object);
Import.prototype.getFilenameToken$ = function () {
	return this._filenameToken;
};


function Import$getFilenameToken$LImport$($this) {
	return $this._filenameToken;
};

Import.getFilenameToken$LImport$ = Import$getFilenameToken$LImport$;

Import.prototype.getAlias$ = function () {
	return (this._aliasToken ? this._aliasToken._value : null);
};


function Import$getAlias$LImport$($this) {
	return ($this._aliasToken ? $this._aliasToken._value : null);
};

Import.getAlias$LImport$ = Import$getAlias$LImport$;

Import.prototype.getClassNames$ = function () {
	var names;
	var i;
	if (this._classNames == null) {
		return null;
	}
	names = [];
	for (i = 0; i < this._classNames.length; ++ i) {
		names[i] = this._classNames[i]._value;
	}
	return names;
};


function Import$getClassNames$LImport$($this) {
	var names;
	var i;
	if ($this._classNames == null) {
		return null;
	}
	names = [];
	for (i = 0; i < $this._classNames.length; ++ i) {
		names[i] = $this._classNames[i]._value;
	}
	return names;
};

Import.getClassNames$LImport$ = Import$getClassNames$LImport$;

Import.prototype.serialize$ = function () {
	var serializeNullable$v$0;
	var serializeNullable$v$1;
	return [ "Import", (serializeNullable$v$0 = this._filenameToken, serializeNullable$v$0 == null ? null : [ serializeNullable$v$0._value, serializeNullable$v$0._isIdentifier, serializeNullable$v$0._filename, serializeNullable$v$0._lineNumber, serializeNullable$v$0._columnNumber ]), (serializeNullable$v$1 = this._aliasToken, serializeNullable$v$1 == null ? null : [ serializeNullable$v$1._value, serializeNullable$v$1._isIdentifier, serializeNullable$v$1._filename, serializeNullable$v$1._lineNumber, serializeNullable$v$1._columnNumber ]), Serializer$x2E$x3CToken$x3E$serializeArray$ALToken$(this._classNames) ];
};


function Import$serialize$LImport$($this) {
	var serializeNullable$v$0;
	var serializeNullable$v$1;
	return [ "Import", (serializeNullable$v$0 = $this._filenameToken, serializeNullable$v$0 == null ? null : [ serializeNullable$v$0._value, serializeNullable$v$0._isIdentifier, serializeNullable$v$0._filename, serializeNullable$v$0._lineNumber, serializeNullable$v$0._columnNumber ]), (serializeNullable$v$1 = $this._aliasToken, serializeNullable$v$1 == null ? null : [ serializeNullable$v$1._value, serializeNullable$v$1._isIdentifier, serializeNullable$v$1._filename, serializeNullable$v$1._lineNumber, serializeNullable$v$1._columnNumber ]), Serializer$x2E$x3CToken$x3E$serializeArray$ALToken$($this._classNames) ];
};

Import.serialize$LImport$ = Import$serialize$LImport$;

Import.prototype.checkNameConflict$ALCompileError$LToken$ = function (errors, nameToken) {
	var i;
	if (this._aliasToken != null) {
		if (this._aliasToken._value === nameToken._value) {
			errors.push(new CompileError(nameToken, "an alias with the same name is already declared"));
			return false;
		}
	} else {
		if (this._classNames != null) {
			for (i = 0; i < this._classNames.length; ++ i) {
				if (this._classNames[i]._value === nameToken._value) {
					errors.push(new CompileError(nameToken, "a class with the same name has already been explicitely imported"));
					return false;
				}
			}
		}
	}
	return true;
};


function Import$checkNameConflict$LImport$ALCompileError$LToken$($this, errors, nameToken) {
	var i;
	if ($this._aliasToken != null) {
		if ($this._aliasToken._value === nameToken._value) {
			errors.push(new CompileError(nameToken, "an alias with the same name is already declared"));
			return false;
		}
	} else {
		if ($this._classNames != null) {
			for (i = 0; i < $this._classNames.length; ++ i) {
				if ($this._classNames[i]._value === nameToken._value) {
					errors.push(new CompileError(nameToken, "a class with the same name has already been explicitely imported"));
					return false;
				}
			}
		}
	}
	return true;
};

Import.checkNameConflict$LImport$ALCompileError$LToken$ = Import$checkNameConflict$LImport$ALCompileError$LToken$;

Import.prototype.addSource$LParser$ = function (parser) {
	this._sourceParsers.push(parser);
};


function Import$addSource$LImport$LParser$($this, parser) {
	$this._sourceParsers.push(parser);
};

Import.addSource$LImport$LParser$ = Import$addSource$LImport$LParser$;

Import.prototype.getSources$ = function () {
	return this._sourceParsers;
};


function Import$getSources$LImport$($this) {
	return $this._sourceParsers;
};

Import.getSources$LImport$ = Import$getSources$LImport$;

Import.prototype.assertExistenceOfNamedClasses$ALCompileError$ = function (errors) {
	var $this = this;
	var allClassNames;
	var i;
	var countNumberOfClassesByName;
	var _classNames$0;
	var _classNames$1;
	if (this._classNames == null) {
		return;
	}
	allClassNames = [];
	for (i = 0; i < this._sourceParsers.length; ++ i) {
		allClassNames = allClassNames.concat(this._sourceParsers[i]._classDefs.map((function (classDef) {
			return classDef.className$();
		})));
		allClassNames = allClassNames.concat(this._sourceParsers[i]._templateClassDefs.map((function (classDef) {
			return classDef._className;
		})));
	}
	function countNumberOfClassesByName(className) {
		var num;
		var i;
		var allClassNames$len$0;
		num = 0;
		for ((i = 0, allClassNames$len$0 = allClassNames.length); i < allClassNames$len$0; ++ i) {
			if (allClassNames[i] === className) {
				++ num;
			}
		}
		return num;
	}
	for (i = 0; i < this._classNames.length; ++ i) {
		switch (countNumberOfClassesByName(this._classNames[i]._value)) {
		case 0:
			errors.push(new CompileError((_classNames$0 = this._classNames)[i], "no definition for class '" + _classNames$0[i]._value + "'"));
			break;
		case 1:
			break;
		default:
			errors.push(new CompileError((_classNames$1 = this._classNames)[i], "multiple candidates for class '" + _classNames$1[i]._value + "'"));
			break;
		}
	}
};


function Import$assertExistenceOfNamedClasses$LImport$ALCompileError$($this, errors) {
	var allClassNames;
	var i;
	var countNumberOfClassesByName;
	var _classNames$0;
	var _classNames$1;
	if ($this._classNames == null) {
		return;
	}
	allClassNames = [];
	for (i = 0; i < $this._sourceParsers.length; ++ i) {
		allClassNames = allClassNames.concat($this._sourceParsers[i]._classDefs.map((function (classDef) {
			return classDef.className$();
		})));
		allClassNames = allClassNames.concat($this._sourceParsers[i]._templateClassDefs.map((function (classDef) {
			return classDef._className;
		})));
	}
	function countNumberOfClassesByName(className) {
		var num;
		var i;
		var allClassNames$len$0;
		num = 0;
		for ((i = 0, allClassNames$len$0 = allClassNames.length); i < allClassNames$len$0; ++ i) {
			if (allClassNames[i] === className) {
				++ num;
			}
		}
		return num;
	}
	for (i = 0; i < $this._classNames.length; ++ i) {
		switch (countNumberOfClassesByName($this._classNames[i]._value)) {
		case 0:
			errors.push(new CompileError((_classNames$0 = $this._classNames)[i], "no definition for class '" + _classNames$0[i]._value + "'"));
			break;
		case 1:
			break;
		default:
			errors.push(new CompileError((_classNames$1 = $this._classNames)[i], "multiple candidates for class '" + _classNames$1[i]._value + "'"));
			break;
		}
	}
};

Import.assertExistenceOfNamedClasses$LImport$ALCompileError$ = Import$assertExistenceOfNamedClasses$LImport$ALCompileError$;

Import.prototype.getClasses$S = function (name) {
	var found;
	var i;
	var classDefs;
	var j;
	var classDef;
	if (! Import$_classIsImportable$LImport$S(this, name)) {
		return [  ];
	}
	found = [  ];
	for (i = 0; i < this._sourceParsers.length; ++ i) {
		classDefs = this._sourceParsers[i]._classDefs;
		for (j = 0; j < classDefs.length; ++ j) {
			classDef = classDefs[j];
			if (classDef.className$() === name) {
				found.push(classDef);
				break;
			}
		}
	}
	return found;
};


function Import$getClasses$LImport$S($this, name) {
	var found;
	var i;
	var classDefs;
	var j;
	var classDef;
	if (! Import$_classIsImportable$LImport$S($this, name)) {
		return [  ];
	}
	found = [  ];
	for (i = 0; i < $this._sourceParsers.length; ++ i) {
		classDefs = $this._sourceParsers[i]._classDefs;
		for (j = 0; j < classDefs.length; ++ j) {
			classDef = classDefs[j];
			if (classDef.className$() === name) {
				found.push(classDef);
				break;
			}
		}
	}
	return found;
};

Import.getClasses$LImport$S = Import$getClasses$LImport$S;

Import.prototype.createGetTemplateClassCallbacks$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = function (errors, request, postInstantiationCallback) {
	var callbacks;
	var i;
	var callback;
	if (! Import$_classIsImportable$LImport$S(this, request._className)) {
		return [];
	}
	callbacks = [];
	for (i = 0; i < this._sourceParsers.length; ++ i) {
		callback = Parser$createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(this._sourceParsers[i], errors, request, postInstantiationCallback);
		if (callback != null) {
			callbacks.push(callback);
		}
	}
	return callbacks;
};


function Import$createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback) {
	var callbacks;
	var i;
	var callback;
	if (! Import$_classIsImportable$LImport$S($this, request._className)) {
		return [];
	}
	callbacks = [];
	for (i = 0; i < $this._sourceParsers.length; ++ i) {
		callback = Parser$createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this._sourceParsers[i], errors, request, postInstantiationCallback);
		if (callback != null) {
			callbacks.push(callback);
		}
	}
	return callbacks;
};

Import.createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = Import$createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$;

Import.prototype._classIsImportable$S = function (name) {
	var i;
	if (this._classNames != null) {
		for (i = 0; i < this._classNames.length; ++ i) {
			if (this._classNames[i]._value === name) {
				break;
			}
		}
		if (i === this._classNames.length) {
			return false;
		}
	} else {
		if (name.charAt(0) === '_') {
			return false;
		}
	}
	return true;
};


function Import$_classIsImportable$LImport$S($this, name) {
	var i;
	if ($this._classNames != null) {
		for (i = 0; i < $this._classNames.length; ++ i) {
			if ($this._classNames[i]._value === name) {
				break;
			}
		}
		if (i === $this._classNames.length) {
			return false;
		}
	} else {
		if (name.charAt(0) === '_') {
			return false;
		}
	}
	return true;
};

Import._classIsImportable$LImport$S = Import$_classIsImportable$LImport$S;

function Import$create$ALCompileError$LToken$LToken$ALToken$(errors, filenameToken, aliasToken, classNames) {
	var filename;
	var match;
	filename = Util$decodeStringLiteral$S(filenameToken._value);
	if (filename.indexOf("*") !== -1) {
		match = filename.match(/^([^\*]*)\/\*(\.[^\/\*]*)$/);
		if (match == null) {
			errors.push(new CompileError(filenameToken, "invalid use of wildcard"));
			return null;
		}
		return new WildcardImport(filenameToken, aliasToken, classNames, match[1], match[2]);
	}
	return new Import$0(filenameToken, aliasToken, classNames);
};

Import.create$ALCompileError$LToken$LToken$ALToken$ = Import$create$ALCompileError$LToken$LToken$ALToken$;

function WildcardImport(filenameToken, aliasToken, classNames, directory, suffix) {
	this._filenameToken = filenameToken;
	this._aliasToken = aliasToken;
	this._classNames = classNames;
	this._sourceParsers = [  ];
	this._directory = directory;
	this._suffix = suffix;
};

$__jsx_extend([WildcardImport], Import);
WildcardImport.prototype.getDirectory$ = function () {
	return this._directory;
};


function WildcardImport$getDirectory$LWildcardImport$($this) {
	return $this._directory;
};

WildcardImport.getDirectory$LWildcardImport$ = WildcardImport$getDirectory$LWildcardImport$;

WildcardImport.prototype.getSuffix$ = function () {
	return this._suffix;
};


function WildcardImport$getSuffix$LWildcardImport$($this) {
	return $this._suffix;
};

WildcardImport.getSuffix$LWildcardImport$ = WildcardImport$getSuffix$LWildcardImport$;

function QualifiedName(token) {
	this._token = token;
	this._import = null;
	this._enclosingType = null;
};

function QualifiedName$0(token, imprt) {
	this._token = token;
	this._import = imprt;
	this._enclosingType = null;
};

function QualifiedName$1(token, enclosingType) {
	this._token = token;
	this._import = null;
	this._enclosingType = enclosingType;
};

$__jsx_extend([QualifiedName, QualifiedName$0, QualifiedName$1], Object);
QualifiedName.prototype.getToken$ = function () {
	return this._token;
};


function QualifiedName$getToken$LQualifiedName$($this) {
	return $this._token;
};

QualifiedName.getToken$LQualifiedName$ = QualifiedName$getToken$LQualifiedName$;

QualifiedName.prototype.getImport$ = function () {
	return this._import;
};


function QualifiedName$getImport$LQualifiedName$($this) {
	return $this._import;
};

QualifiedName.getImport$LQualifiedName$ = QualifiedName$getImport$LQualifiedName$;

QualifiedName.prototype.getEnclosingType$ = function () {
	return this._enclosingType;
};


function QualifiedName$getEnclosingType$LQualifiedName$($this) {
	return $this._enclosingType;
};

QualifiedName.getEnclosingType$LQualifiedName$ = QualifiedName$getEnclosingType$LQualifiedName$;

QualifiedName.prototype.serialize$ = function () {
	var serialize$this$0;
	var serializeNullable$v$0;
	var serializeNullable$v$1;
	return [ "QualifiedName", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), (serializeNullable$v$0 = this._import, serializeNullable$v$0 == null ? null : Import$serialize$LImport$(serializeNullable$v$0)), (serializeNullable$v$1 = this._enclosingType, serializeNullable$v$1 == null ? null : serializeNullable$v$1._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(serializeNullable$v$1._qualifiedName._token._value, serializeNullable$v$1._typeArguments) : serializeNullable$v$1._qualifiedName._token._value) ];
};


function QualifiedName$serialize$LQualifiedName$($this) {
	var serialize$this$0;
	var serializeNullable$v$0;
	var serializeNullable$v$1;
	return [ "QualifiedName", (serialize$this$0 = $this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), (serializeNullable$v$0 = $this._import, serializeNullable$v$0 == null ? null : Import$serialize$LImport$(serializeNullable$v$0)), (serializeNullable$v$1 = $this._enclosingType, serializeNullable$v$1 == null ? null : serializeNullable$v$1._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(serializeNullable$v$1._qualifiedName._token._value, serializeNullable$v$1._typeArguments) : serializeNullable$v$1._qualifiedName._token._value) ];
};

QualifiedName.serialize$LQualifiedName$ = QualifiedName$serialize$LQualifiedName$;

QualifiedName.prototype.equals$LQualifiedName$ = function (x) {
	if (x == null) {
		return false;
	}
	if (this._token._value !== x._token._value) {
		return false;
	}
	if (this._import != x._import) {
		return false;
	}
	if (this._enclosingType == null) {
		if (x._enclosingType != null) {
			return false;
		}
	} else {
		if (! this._enclosingType.equals$LType$(x._enclosingType)) {
			return false;
		}
	}
	return true;
};


function QualifiedName$equals$LQualifiedName$LQualifiedName$($this, x) {
	if (x == null) {
		return false;
	}
	if ($this._token._value !== x._token._value) {
		return false;
	}
	if ($this._import != x._import) {
		return false;
	}
	if ($this._enclosingType == null) {
		if (x._enclosingType != null) {
			return false;
		}
	} else {
		if (! $this._enclosingType.equals$LType$(x._enclosingType)) {
			return false;
		}
	}
	return true;
};

QualifiedName.equals$LQualifiedName$LQualifiedName$ = QualifiedName$equals$LQualifiedName$LQualifiedName$;

QualifiedName.prototype.getClass$LAnalysisContext$ALType$ = function (context, typeArguments) {
	var $this = this;
	var classDef;
	var classDefs;
	var callbacks;
	var enclosingClassDef;
	var _token$0;
	var _token$1;
	var _token$2;
	var _token$3;
	classDef = null;
	if (this._import != null) {
		if (typeArguments.length === 0) {
			classDefs = Import$getClasses$LImport$S(this._import, this._token._value);
			switch (classDefs.length) {
			case 1:
				classDef = classDefs[0];
				break;
			case 0:
				context.errors.push(new CompileError(this._token, "no definition for class '" + this.toString() + "' in file '" + this._import._filenameToken._value + "'"));
				return null;
			default:
				context.errors.push(new CompileError(this._token, "multiple candidates"));
				return null;
			}
		} else {
			callbacks = Import$createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(this._import, context.errors, ({_token: _token$0 = this._token, _className: _token$0._value, _typeArgs: typeArguments}), (function (parser, classDef) {
				return null;
			}));
			switch (callbacks.length) {
			case 1:
				return callbacks[0](null, null, null);
			case 0:
				context.errors.push(new CompileError(this._token, "no definition for template class '" + this.toString() + "' in file '" + this._import._filenameToken._value + "'"));
				return null;
			default:
				context.errors.push(new CompileError(this._token, "multiple canditates"));
				return null;
			}
		}
	} else {
		if (this._enclosingType != null) {
			this._enclosingType.resolveType$LAnalysisContext$(context);
			if ((enclosingClassDef = this._enclosingType._classDef) == null) {
				return null;
			}
			if (typeArguments.length === 0) {
				if ((classDef = ClassDefinition$lookupInnerClass$LClassDefinition$S(enclosingClassDef, this._token._value)) == null) {
					context.errors.push(new CompileError(this._token, "no class definition for '" + this.toString() + "'"));
					return null;
				}
			} else {
				if ((classDef = ClassDefinition$lookupTemplateInnerClass$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(enclosingClassDef, context.errors, ({_token: _token$1 = this._token, _className: _token$1._value, _typeArgs: typeArguments}), (function (parser, classDef) {
					return null;
				}))) == null) {
					context.errors.push(new CompileError(this._token, "failed to instantiate class"));
					return null;
				}
			}
		} else {
			if (typeArguments.length === 0) {
				if ((classDef = Parser$lookup$LParser$ALCompileError$LToken$S(context.parser, context.errors, _token$2 = this._token, _token$2._value)) == null) {
					context.errors.push(new CompileError(this._token, "no class definition for '" + this.toString() + "'"));
					return null;
				}
			} else {
				if ((classDef = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: _token$3 = this._token, _className: _token$3._value, _typeArgs: typeArguments}), (function (parser, classDef) {
					return null;
				}))) == null) {
					context.errors.push(new CompileError(this._token, "failed to instantiate class"));
					return null;
				}
			}
		}
	}
	return classDef;
};


function QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$($this, context, typeArguments) {
	var classDef;
	var classDefs;
	var callbacks;
	var enclosingClassDef;
	var _token$0;
	var _token$1;
	var _token$2;
	var _token$3;
	classDef = null;
	if ($this._import != null) {
		if (typeArguments.length === 0) {
			classDefs = Import$getClasses$LImport$S($this._import, $this._token._value);
			switch (classDefs.length) {
			case 1:
				classDef = classDefs[0];
				break;
			case 0:
				context.errors.push(new CompileError($this._token, "no definition for class '" + $this.toString() + "' in file '" + $this._import._filenameToken._value + "'"));
				return null;
			default:
				context.errors.push(new CompileError($this._token, "multiple candidates"));
				return null;
			}
		} else {
			callbacks = Import$createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this._import, context.errors, ({_token: _token$0 = $this._token, _className: _token$0._value, _typeArgs: typeArguments}), (function (parser, classDef) {
				return null;
			}));
			switch (callbacks.length) {
			case 1:
				return callbacks[0](null, null, null);
			case 0:
				context.errors.push(new CompileError($this._token, "no definition for template class '" + $this.toString() + "' in file '" + $this._import._filenameToken._value + "'"));
				return null;
			default:
				context.errors.push(new CompileError($this._token, "multiple canditates"));
				return null;
			}
		}
	} else {
		if ($this._enclosingType != null) {
			$this._enclosingType.resolveType$LAnalysisContext$(context);
			if ((enclosingClassDef = $this._enclosingType._classDef) == null) {
				return null;
			}
			if (typeArguments.length === 0) {
				if ((classDef = ClassDefinition$lookupInnerClass$LClassDefinition$S(enclosingClassDef, $this._token._value)) == null) {
					context.errors.push(new CompileError($this._token, "no class definition for '" + $this.toString() + "'"));
					return null;
				}
			} else {
				if ((classDef = ClassDefinition$lookupTemplateInnerClass$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(enclosingClassDef, context.errors, ({_token: _token$1 = $this._token, _className: _token$1._value, _typeArgs: typeArguments}), (function (parser, classDef) {
					return null;
				}))) == null) {
					context.errors.push(new CompileError($this._token, "failed to instantiate class"));
					return null;
				}
			}
		} else {
			if (typeArguments.length === 0) {
				if ((classDef = Parser$lookup$LParser$ALCompileError$LToken$S(context.parser, context.errors, _token$2 = $this._token, _token$2._value)) == null) {
					context.errors.push(new CompileError($this._token, "no class definition for '" + $this.toString() + "'"));
					return null;
				}
			} else {
				if ((classDef = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: _token$3 = $this._token, _className: _token$3._value, _typeArgs: typeArguments}), (function (parser, classDef) {
					return null;
				}))) == null) {
					context.errors.push(new CompileError($this._token, "failed to instantiate class"));
					return null;
				}
			}
		}
	}
	return classDef;
};

QualifiedName.getClass$LQualifiedName$LAnalysisContext$ALType$ = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$;

QualifiedName.prototype.getTemplateClass$LParser$ = function (parser) {
	var $this = this;
	var foundClassDefs;
	var checkClassDef;
	var this$0;
	var i$0;
	var this$1;
	var i$1;
	var this$2;
	var i$2;
	foundClassDefs = [];
	checkClassDef = (function (classDef) {
		if (classDef._className === $this._token._value) {
			foundClassDefs.push(classDef);
		}
	});
	if (this._import != null) {
		this$0 = this._import._sourceParsers;
		for (i$0 in this$0) {
			(function (parser) {
				var this$0;
				var i$0;
				this$0 = parser._templateClassDefs;
				for (i$0 in this$0) {
					checkClassDef(this$0[i$0]);
				}
			})(this$0[i$0]);
		}
	} else {
		this$1 = parser._templateClassDefs;
		for (i$1 in this$1) {
			checkClassDef(this$1[i$1]);
		}
		if (foundClassDefs.length === 0) {
			this$2 = parser._imports;
			for (i$2 in this$2) {
				(function (imprt) {
					var this$0;
					var i$0;
					this$0 = imprt._sourceParsers;
					for (i$0 in this$0) {
						(function (parser) {
							var this$0;
							var i$0;
							this$0 = parser._templateClassDefs;
							for (i$0 in this$0) {
								checkClassDef(this$0[i$0]);
							}
						})(this$0[i$0]);
					}
				})(this$2[i$2]);
			}
		}
	}
	return (foundClassDefs.length === 1 ? foundClassDefs[0] : null);
};


function QualifiedName$getTemplateClass$LQualifiedName$LParser$($this, parser) {
	var foundClassDefs;
	var checkClassDef;
	var this$0;
	var i$0;
	var this$1;
	var i$1;
	var this$2;
	var i$2;
	foundClassDefs = [];
	checkClassDef = (function (classDef) {
		if (classDef._className === $this._token._value) {
			foundClassDefs.push(classDef);
		}
	});
	if ($this._import != null) {
		this$0 = $this._import._sourceParsers;
		for (i$0 in this$0) {
			(function (parser) {
				var this$0;
				var i$0;
				this$0 = parser._templateClassDefs;
				for (i$0 in this$0) {
					checkClassDef(this$0[i$0]);
				}
			})(this$0[i$0]);
		}
	} else {
		this$1 = parser._templateClassDefs;
		for (i$1 in this$1) {
			checkClassDef(this$1[i$1]);
		}
		if (foundClassDefs.length === 0) {
			this$2 = parser._imports;
			for (i$2 in this$2) {
				(function (imprt) {
					var this$0;
					var i$0;
					this$0 = imprt._sourceParsers;
					for (i$0 in this$0) {
						(function (parser) {
							var this$0;
							var i$0;
							this$0 = parser._templateClassDefs;
							for (i$0 in this$0) {
								checkClassDef(this$0[i$0]);
							}
						})(this$0[i$0]);
					}
				})(this$2[i$2]);
			}
		}
	}
	return (foundClassDefs.length === 1 ? foundClassDefs[0] : null);
};

QualifiedName.getTemplateClass$LQualifiedName$LParser$ = QualifiedName$getTemplateClass$LQualifiedName$LParser$;

QualifiedName.prototype.toString = function () {
	var toString$this$0;
	return (this._enclosingType != null ? (toString$this$0 = this._enclosingType, toString$this$0._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(toString$this$0._qualifiedName._token._value, toString$this$0._typeArguments) : toString$this$0._qualifiedName._token._value) + "." + this._token._value : this._token._value);
};


function ParserState(lineNumber, columnNumber, docComment, tokenLength, isGenerator, numErrors, numClosures, numObjectTypesUsed, numTemplateInstantiationRequests) {
	this.lineNumber = lineNumber;
	this.columnOffset = columnNumber;
	this.docComment = docComment;
	this.tokenLength = tokenLength;
	this.isGenerator = isGenerator;
	this.numErrors = numErrors;
	this.numClosures = numClosures;
	this.numObjectTypesUsed = numObjectTypesUsed;
	this.numTemplateInstantiationRequests = numTemplateInstantiationRequests;
};

$__jsx_extend([ParserState], Object);
function ClassState(outer, classType, typeArgs, extendType, implementTypes, objectTypesUsed, classFlags, inners, templateInners) {
	this.outer = outer;
	this.classType = classType;
	this.typeArgs = typeArgs;
	this.extendType = extendType;
	this.implementTypes = implementTypes;
	this.objectTypesUsed = objectTypesUsed;
	this.classFlags = classFlags;
	this.inners = inners;
	this.templateInners = templateInners;
};

$__jsx_extend([ClassState], Object);
function Scope(prev, locals, funcLocal, args, statements, closures, isGenerator) {
	this.prev = prev;
	this.locals = locals;
	this.funcLocal = funcLocal;
	this.arguments = args;
	this.statements = statements;
	this.closures = closures;
	this.isGenerator = isGenerator;
};

$__jsx_extend([Scope], Object);
function Parser(sourceToken, filename, completionRequest) {
	this._input = "";
	this._lines = null;
	this._tokenLength = 0;
	this._lineNumber = 0;
	this._columnOffset = 0;
	this._fileLevelDocComment = null;
	this._docComment = null;
	this._errors = null;
	this._templateClassDefs = null;
	this._classDefs = null;
	this._imports = null;
	this._isGenerator = false;
	this._locals = null;
	this._statements = null;
	this._closures = null;
	this._outerClass = null;
	this._classType = null;
	this._extendType = null;
	this._implementTypes = null;
	this._objectTypesUsed = null;
	this._inners = null;
	this._templateInners = null;
	this._templateInstantiationRequests = null;
	this._prevScope = null;
	this._funcLocal = null;
	this._arguments = null;
	this._classFlags = 0;
	this._typeArgs = null;
	this._sourceToken = sourceToken;
	this._filename = filename;
	this._completionRequest = completionRequest;
};

$__jsx_extend([Parser], Object);
function Parser$parse$LParser$SALCompileError$($this, input, errors) {
	var compLineNumber;
	var line;
	var importToken;
	var value1$0;
	var value2$0;
	var _input$0;
	_input$0 = $this._input = input;
	$this._lines = _input$0.split(_Lexer.rxNewline);
	$this._tokenLength = 0;
	$this._lineNumber = 1;
	$this._columnOffset = 0;
	$this._fileLevelDocComment = null;
	$this._docComment = null;
	if ($this._completionRequest != null) {
		value1$0 = $this._completionRequest._lineNumber;
		value2$0 = $this._lines.length + 1;
		compLineNumber = (value1$0 <= value2$0 ? value1$0 : value2$0);
		line = $this._lines[compLineNumber - 1] || '';
		$this._lines[compLineNumber - 1] = line.substring(0, $this._completionRequest._columnOffest) + "Q," + line.substring($this._completionRequest._columnOffest);
	}
	$this._errors = errors;
	$this._templateClassDefs = [];
	$this._classDefs = [];
	$this._imports = [];
	$this._isGenerator = false;
	$this._locals = null;
	$this._statements = null;
	$this._closures = null;
	$this._classType = null;
	$this._extendType = null;
	$this._implementTypes = null;
	$this._objectTypesUsed = [];
	$this._inners = [];
	$this._templateInners = [];
	$this._templateInstantiationRequests = [];
	while (! Parser$_isEOF$LParser$($this)) {
		importToken = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "import" ], null);
		if (importToken == null) {
			break;
		}
		Parser$_importStatement$LParser$LToken$($this, importToken);
	}
	while (! Parser$_isEOF$LParser$($this)) {
		if (Parser$_classDefinition$LParser$($this) == null) {
			return false;
		}
	}
	return ($this._errors.length !== 0 ? false : true);
};

Parser.parse$LParser$SALCompileError$ = Parser$parse$LParser$SALCompileError$;

function Parser$_getInput$LParser$($this) {
	return $this._lines[$this._lineNumber - 1].substring($this._columnOffset);
};

Parser._getInput$LParser$ = Parser$_getInput$LParser$;

function Parser$_getInputByLength$LParser$N($this, length) {
	var _columnOffset$0;
	return $this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + length);
};

Parser._getInputByLength$LParser$N = Parser$_getInputByLength$LParser$N;

function Parser$_forwardPos$LParser$N($this, len) {
	$this._columnOffset += len;
};

Parser._forwardPos$LParser$N = Parser$_forwardPos$LParser$N;

function Parser$getSourceToken$LParser$($this) {
	return $this._sourceToken;
};

Parser.getSourceToken$LParser$ = Parser$getSourceToken$LParser$;

function Parser$getPath$LParser$($this) {
	return $this._filename;
};

Parser.getPath$LParser$ = Parser$getPath$LParser$;

function Parser$getDocComment$LParser$($this) {
	return $this._fileLevelDocComment;
};

Parser.getDocComment$LParser$ = Parser$getDocComment$LParser$;

function Parser$getClassDefs$LParser$($this) {
	return $this._classDefs;
};

Parser.getClassDefs$LParser$ = Parser$getClassDefs$LParser$;

function Parser$getTemplateClassDefs$LParser$($this) {
	return $this._templateClassDefs;
};

Parser.getTemplateClassDefs$LParser$ = Parser$getTemplateClassDefs$LParser$;

function Parser$getTemplateInstantiationRequests$LParser$($this) {
	return $this._templateInstantiationRequests;
};

Parser.getTemplateInstantiationRequests$LParser$ = Parser$getTemplateInstantiationRequests$LParser$;

function Parser$getImports$LParser$($this) {
	return $this._imports;
};

Parser.getImports$LParser$ = Parser$getImports$LParser$;

function Parser$registerBuiltinImports$LParser$ALParser$($this, parsers) {
	var i;
	for (i = parsers.length - 1; i >= 0; -- i) {
		$this._imports.unshift(new Import(parsers[i]));
	}
};

Parser.registerBuiltinImports$LParser$ALParser$ = Parser$registerBuiltinImports$LParser$ALParser$;

function Parser$lookupImportAlias$LParser$S($this, name) {
	var i;
	var alias;
	var this$0;
	for (i = 0; i < $this._imports.length; ++ i) {
		this$0 = $this._imports[i];
		alias = (this$0._aliasToken ? this$0._aliasToken._value : null);
		if (alias != null && alias === name) {
			return $this._imports[i];
		}
	}
	return null;
};

Parser.lookupImportAlias$LParser$S = Parser$lookupImportAlias$LParser$S;

function Parser$lookup$LParser$ALCompileError$LToken$S($this, errors, contextToken, className) {
	var i;
	var classDef;
	var found;
	var getAlias$this$0;
	for (i = 0; i < $this._classDefs.length; ++ i) {
		classDef = $this._classDefs[i];
		if (classDef.className$() === className) {
			return classDef;
		}
	}
	found = [];
	for (i = 0; i < $this._imports.length; ++ i) {
		if ((getAlias$this$0 = $this._imports[i], getAlias$this$0._aliasToken ? getAlias$this$0._aliasToken._value : null) == null) {
			found = found.concat(Import$getClasses$LImport$S($this._imports[i], className));
		}
	}
	if (found.length === 1) {
		return found[0];
	}
	if (found.length >= 2) {
		errors.push(new CompileError(contextToken, "multiple candidates exist for class name '" + className + "'"));
	}
	return null;
};

Parser.lookup$LParser$ALCompileError$LToken$S = Parser$lookup$LParser$ALCompileError$LToken$S;

function Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback) {
	var instantiateCallback;
	var candidateCallbacks;
	var i;
	instantiateCallback = Parser$createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback);
	if (instantiateCallback != null) {
		return instantiateCallback(errors, request, postInstantiationCallback);
	}
	candidateCallbacks = [];
	for (i = 0; i < $this._imports.length; ++ i) {
		candidateCallbacks = candidateCallbacks.concat(Import$createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this._imports[i], errors, request, postInstantiationCallback));
	}
	if (candidateCallbacks.length === 0) {
		errors.push(new CompileError(request._token, "could not find definition for template class: '" + request._className + "'"));
		return null;
	} else {
		if (candidateCallbacks.length >= 2) {
			errors.push(new CompileError(request._token, "multiple candidates exist for template class name '" + request._className + "'"));
			return null;
		}
	}
	return candidateCallbacks[0](null, null, null);
};

Parser.lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$;

function Parser$createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback) {
	var i;
	var classDef;
	var templateDef;
	for (i = 0; i < $this._classDefs.length; ++ i) {
		classDef = $this._classDefs[i];
		if (classDef instanceof InstantiatedClassDefinition && classDef._templateClassDef._className === request._className && Util$typesAreEqual$ALType$ALType$(classDef._typeArguments, request._typeArgs)) {
			return (function (_, __, ___) {
				return classDef;
			});
		}
	}
	for (i = 0; i < $this._templateClassDefs.length; ++ i) {
		templateDef = $this._templateClassDefs[i];
		if (templateDef._className === request._className) {
			return (function (_, __, ___) {
				var classDef;
				classDef = TemplateClassDefinition$instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$(templateDef, errors, request);
				if (classDef == null) {
					return null;
				}
				$this._classDefs.push(classDef);
				classDef._parser = $this;
				ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(classDef, ({errors: errors, parser: $this, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}));
				postInstantiationCallback($this, classDef);
				return classDef;
			});
		}
	}
	return null;
};

Parser.createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = Parser$createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$;

function Parser$_pushClassState$LParser$($this) {
	$this._outerClass = ({outer: $this._outerClass, classType: $this._classType, typeArgs: $this._typeArgs, extendType: $this._extendType, implementTypes: $this._implementTypes, objectTypesUsed: $this._objectTypesUsed, classFlags: $this._classFlags, inners: $this._inners, templateInners: $this._templateInners});
};

Parser._pushClassState$LParser$ = Parser$_pushClassState$LParser$;

function Parser$_popClassState$LParser$($this) {
	var _outerClass$0;
	$this._classType = (_outerClass$0 = $this._outerClass).classType;
	$this._typeArgs = _outerClass$0.typeArgs;
	$this._extendType = _outerClass$0.extendType;
	$this._implementTypes = _outerClass$0.implementTypes;
	$this._objectTypesUsed = _outerClass$0.objectTypesUsed;
	$this._classFlags = _outerClass$0.classFlags;
	$this._inners = _outerClass$0.inners;
	$this._templateInners = _outerClass$0.templateInners;
	$this._outerClass = _outerClass$0.outer;
};

Parser._popClassState$LParser$ = Parser$_popClassState$LParser$;

function Parser$_pushScope$LParser$LLocalVariable$ALArgumentDeclaration$($this, funcLocal, args) {
	$this._prevScope = ({prev: $this._prevScope, locals: $this._locals, funcLocal: $this._funcLocal, arguments: $this._arguments, statements: $this._statements, closures: $this._closures, isGenerator: $this._isGenerator});
	$this._locals = [];
	$this._funcLocal = funcLocal;
	$this._arguments = args;
	$this._statements = [];
	$this._closures = [];
	$this._isGenerator = false;
};

Parser._pushScope$LParser$LLocalVariable$ALArgumentDeclaration$ = Parser$_pushScope$LParser$LLocalVariable$ALArgumentDeclaration$;

function Parser$_popScope$LParser$($this) {
	var _prevScope$0;
	$this._locals = (_prevScope$0 = $this._prevScope).locals;
	$this._funcLocal = _prevScope$0.funcLocal;
	$this._arguments = _prevScope$0.arguments;
	$this._statements = _prevScope$0.statements;
	$this._closures = _prevScope$0.closures;
	$this._isGenerator = _prevScope$0.isGenerator;
	$this._prevScope = _prevScope$0.prev;
};

Parser._popScope$LParser$ = Parser$_popScope$LParser$;

function Parser$_registerLocal$LParser$LToken$LType$($this, identifierToken, type) {
	var isEqualTo;
	var i;
	var newLocal;
	var message$0;
	function isEqualTo(local) {
		var message$0;
		var _type$0;
		if (local._name._value === identifierToken._value) {
			if (type != null && (_type$0 = local._type) != null && ! _type$0.equals$LType$(type)) {
				message$0 = "conflicting types for variable " + identifierToken._value;
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$0));
			}
			return true;
		}
		return false;
	}
	if ($this._arguments == null) {
		message$0 = Util$format$SAS("cannot declare variable %1 outside of a function", [ identifierToken._value ]);
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$0));
		return null;
	}
	if ($this._funcLocal != null) {
		if (isEqualTo($this._funcLocal)) {
			return $this._funcLocal;
		}
	}
	for (i = 0; i < $this._arguments.length; ++ i) {
		if (isEqualTo($this._arguments[i])) {
			return $this._arguments[i];
		}
	}
	for (i = 0; i < $this._locals.length; i++) {
		if (isEqualTo($this._locals[i])) {
			return $this._locals[i];
		}
	}
	newLocal = new LocalVariable(identifierToken, type);
	$this._locals.push(newLocal);
	return newLocal;
};

Parser._registerLocal$LParser$LToken$LType$ = Parser$_registerLocal$LParser$LToken$LType$;

function Parser$_preserveState$LParser$($this) {
	return ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
};

Parser._preserveState$LParser$ = Parser$_preserveState$LParser$;

function Parser$_restoreState$LParser$LParserState$($this, state) {
	var _closures$0;
	var numClosures$0;
	var _objectTypesUsed$0;
	var numObjectTypesUsed$0;
	var _templateInstantiationRequests$0;
	var numTemplateInstantiationRequests$0;
	$this._lineNumber = state.lineNumber;
	$this._columnOffset = state.columnOffset;
	$this._docComment = state.docComment;
	$this._tokenLength = state.tokenLength;
	$this._isGenerator = state.isGenerator;
	$this._errors.length = state.numErrors;
	if ($this._closures != null) {
		(_closures$0 = $this._closures).splice(numClosures$0 = state.numClosures, _closures$0.length - numClosures$0);
	}
	(_objectTypesUsed$0 = $this._objectTypesUsed).splice(numObjectTypesUsed$0 = state.numObjectTypesUsed, _objectTypesUsed$0.length - numObjectTypesUsed$0);
	(_templateInstantiationRequests$0 = $this._templateInstantiationRequests).splice(numTemplateInstantiationRequests$0 = state.numTemplateInstantiationRequests, _templateInstantiationRequests$0.length - numTemplateInstantiationRequests$0);
};

Parser._restoreState$LParser$LParserState$ = Parser$_restoreState$LParser$LParserState$;

function Parser$_getColumn$LParser$($this) {
	return $this._columnOffset;
};

Parser._getColumn$LParser$ = Parser$_getColumn$LParser$;

function Parser$_newError$LParser$S($this, message) {
	$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message));
};

Parser._newError$LParser$S = Parser$_newError$LParser$S;

function Parser$_newDeprecatedWarning$LParser$S($this, message) {
	$this._errors.push(new DeprecatedWarning$0($this._filename, $this._lineNumber, $this._columnOffset, message));
};

Parser._newDeprecatedWarning$LParser$S = Parser$_newDeprecatedWarning$LParser$S;

function Parser$_advanceToken$LParser$($this) {
	var matched;
	var fileLevelDocComment;
	var len$0;
	var _columnOffset$0;
	var _columnOffset$1;
	var _columnOffset$2;
	if ($this._tokenLength !== 0) {
		len$0 = $this._tokenLength;
		$this._columnOffset += len$0;
		$this._tokenLength = 0;
		$this._docComment = null;
	}
	while (true) {
		while (true) {
			matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(/^[ \t]+/);
			if (matched != null) {
				Parser$_forwardPos$LParser$N($this, matched[0].length);
			}
			if ($this._columnOffset !== $this._lines[$this._lineNumber - 1].length) {
				break;
			}
			if ($this._lineNumber === $this._lines.length) {
				break;
			}
			$this._lineNumber++;
			$this._columnOffset = 0;
		}
		switch ($this._lines[$this._lineNumber - 1].substring(_columnOffset$2 = $this._columnOffset, _columnOffset$2 + 2)) {
		case "/*":
			if ($this._lines[$this._lineNumber - 1].substring(_columnOffset$1 = $this._columnOffset, _columnOffset$1 + 4) === "/***") {
				$this._columnOffset += 3;
				fileLevelDocComment = Parser$_parseDocComment$LParser$($this);
				if (fileLevelDocComment == null) {
					return;
				}
				if ($this._fileLevelDocComment == null) {
					$this._fileLevelDocComment = fileLevelDocComment;
				}
			} else {
				if ($this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + 3) === "/**") {
					$this._columnOffset += 2;
					if (($this._docComment = Parser$_parseDocComment$LParser$($this)) == null) {
						return;
					}
				} else {
					$this._columnOffset += 2;
					$this._docComment = null;
					if (! Parser$_skipMultilineComment$LParser$($this)) {
						return;
					}
				}
			}
			break;
		case "//":
			$this._docComment = null;
			if ($this._lineNumber === $this._lines.length) {
				$this._columnOffset = $this._lines[$this._lineNumber - 1].length;
			} else {
				$this._lineNumber++;
				$this._columnOffset = 0;
			}
			break;
		default:
			return;
		}
	}
};

Parser._advanceToken$LParser$ = Parser$_advanceToken$LParser$;

function Parser$_skipMultilineComment$LParser$($this) {
	var startLineNumber;
	var startColumnOffset;
	var endAt;
	var len$0;
	startLineNumber = $this._lineNumber;
	startColumnOffset = $this._columnOffset;
	while (true) {
		endAt = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).indexOf("*/");
		if (endAt !== -1) {
			len$0 = endAt + 2;
			$this._columnOffset += len$0;
			return true;
		}
		if ($this._lineNumber === $this._lines.length) {
			$this._columnOffset = $this._lines[$this._lineNumber - 1].length;
			$this._errors.push(new CompileError$0($this._filename, startLineNumber, startColumnOffset, "could not find the end of the comment"));
			return false;
		}
		++ $this._lineNumber;
		$this._columnOffset = 0;
	}
	return false;
};

Parser._skipMultilineComment$LParser$ = Parser$_skipMultilineComment$LParser$;

function Parser$_parseDocComment$LParser$($this) {
	var docComment;
	var node;
	var count;
	var tagMatch;
	var tag;
	var nameMatch;
	var token;
	var endAt;
	var len$0;
	var s$0;
	var len$1;
	var s$1;
	var _columnOffset$0;
	var _columnOffset$1;
	var _lineNumber$0;
	var _columnOffset$2;
	docComment = new DocComment();
	node = docComment;
	while (true) {
		count = Parser$_parseDocCommentAdvanceWhiteSpace$LParser$($this);
		if ($this._lines[$this._lineNumber - 1].substring(_columnOffset$1 = $this._columnOffset, _columnOffset$1 + 2) === "*/") {
			$this._columnOffset += 2;
			break;
		} else {
			if ($this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + 1) === "*") {
				$this._columnOffset += 1;
				Parser$_parseDocCommentAdvanceWhiteSpace$LParser$($this);
			} else {
				len$0 = - count;
				$this._columnOffset += len$0;
			}
		}
		tagMatch = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(/^\@([0-9A-Za-z_]+)[ \t]*/);
		if (tagMatch != null) {
			Parser$_forwardPos$LParser$N($this, tagMatch[0].length);
			tag = tagMatch[1];
			switch (tag) {
			case "param":
				nameMatch = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(/[0-9A-Za-z_]+/);
				if (nameMatch != null) {
					token = ({_value: nameMatch[0], _isIdentifier: false, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
					Parser$_forwardPos$LParser$N($this, nameMatch[0].length);
					node = new DocCommentParameter(token);
					docComment._params.push(node);
				} else {
					$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "name of the parameter not found after @param"));
					node = null;
				}
				break;
			default:
				node = new DocCommentTag(tag);
				docComment._tags.push(node);
				break;
			}
		}
		endAt = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).indexOf("*/");
		if (endAt !== -1) {
			if (node != null) {
				s$0 = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).substring(0, endAt) + "\n";
				node._description += s$0;
			}
			len$1 = endAt + 2;
			$this._columnOffset += len$1;
			break;
		}
		if (node != null) {
			s$1 = $this._lines[$this._lineNumber - 1].substring($this._columnOffset) + "\n";
			node._description += s$1;
		}
		if ($this._lineNumber === $this._lines.length) {
			_columnOffset$2 = $this._columnOffset = $this._lines[(_lineNumber$0 = $this._lineNumber) - 1].length;
			$this._errors.push(new CompileError$0($this._filename, _lineNumber$0, _columnOffset$2, "could not find the end of the doccomment"));
			return null;
		}
		++ $this._lineNumber;
		$this._columnOffset = 0;
	}
	return docComment;
};

Parser._parseDocComment$LParser$ = Parser$_parseDocComment$LParser$;

function Parser$_parseDocCommentAdvanceWhiteSpace$LParser$($this) {
	var count;
	var ch;
	var _columnOffset$0;
	count = 0;
	while (true) {
		ch = $this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + 1);
		if (ch === " " || ch === "\t") {
			$this._columnOffset += 1;
			count++;
		} else {
			break;
		}
	}
	return count;
};

Parser._parseDocCommentAdvanceWhiteSpace$LParser$ = Parser$_parseDocCommentAdvanceWhiteSpace$LParser$;

function Parser$_isEOF$LParser$($this) {
	var _lines$0;
	Parser$_advanceToken$LParser$($this);
	return $this._lineNumber === (_lines$0 = $this._lines).length && $this._columnOffset === _lines$0[_lines$0.length - 1].length;
};

Parser._isEOF$LParser$ = Parser$_isEOF$LParser$;

function Parser$_expectIsNotEOF$LParser$($this) {
	var _lines$0;
	Parser$_advanceToken$LParser$($this);
	if ($this._lineNumber === (_lines$0 = $this._lines).length && $this._columnOffset === _lines$0[_lines$0.length - 1].length) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "unexpected EOF"));
		return false;
	}
	return true;
};

Parser._expectIsNotEOF$LParser$ = Parser$_expectIsNotEOF$LParser$;

function Parser$_expectOpt$LParser$S($this, expected) {
	return Parser$_expectOpt$LParser$ASLRegExp$($this, [ expected ], null);
};

Parser._expectOpt$LParser$S = Parser$_expectOpt$LParser$S;

function Parser$_expectOpt$LParser$AS($this, expected) {
	return Parser$_expectOpt$LParser$ASLRegExp$($this, expected, null);
};

Parser._expectOpt$LParser$AS = Parser$_expectOpt$LParser$AS;

function Parser$_expectOpt$LParser$SLRegExp$($this, expected, excludePattern) {
	return Parser$_expectOpt$LParser$ASLRegExp$($this, [ expected ], excludePattern);
};

Parser._expectOpt$LParser$SLRegExp$ = Parser$_expectOpt$LParser$SLRegExp$;

function Parser$_expectOpt$LParser$ASLRegExp$($this, expected, excludePattern) {
	var i;
	var offset;
	var this$0;
	var prefix$0;
	var _columnOffset$0;
	Parser$_advanceToken$LParser$($this);
	for (i = 0; i < expected.length; ++ i) {
		if ($this._completionRequest != null) {
			offset = CompletionRequest$isInRange$LCompletionRequest$NNN($this._completionRequest, $this._lineNumber, $this._columnOffset, expected[i].length);
			if (offset !== -1) {
				this$0 = new KeywordCompletionCandidate(expected[i]);
				prefix$0 = $this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + offset);
				this$0._prefix = prefix$0;
				$this._completionRequest._candidates.push(this$0);
			}
		}
		if (Parser$_getInputByLength$LParser$N($this, expected[i].length) === expected[i]) {
			if (expected[i].match(_Lexer.rxIdent) != null && $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxIdent)[0].length !== expected[i].length) {
			} else {
				if (excludePattern != null && $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(excludePattern) != null) {
				} else {
					$this._tokenLength = expected[i].length;
					return ({_value: expected[i], _isIdentifier: false, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
				}
			}
		}
	}
	return null;
};

Parser._expectOpt$LParser$ASLRegExp$ = Parser$_expectOpt$LParser$ASLRegExp$;

function Parser$_expect$LParser$S($this, expected) {
	return Parser$_expect$LParser$ASLRegExp$($this, [ expected ], null);
};

Parser._expect$LParser$S = Parser$_expect$LParser$S;

function Parser$_expect$LParser$AS($this, expected) {
	return Parser$_expect$LParser$ASLRegExp$($this, expected, null);
};

Parser._expect$LParser$AS = Parser$_expect$LParser$AS;

function Parser$_expect$LParser$SLRegExp$($this, expected, excludePattern) {
	return Parser$_expect$LParser$ASLRegExp$($this, [ expected ], excludePattern);
};

Parser._expect$LParser$SLRegExp$ = Parser$_expect$LParser$SLRegExp$;

function Parser$_expect$LParser$ASLRegExp$($this, expected, excludePattern) {
	var token;
	var message$0;
	token = Parser$_expectOpt$LParser$ASLRegExp$($this, expected, excludePattern);
	if (token == null) {
		message$0 = "expected keyword: " + expected.join(" ");
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$0));
		return null;
	}
	return token;
};

Parser._expect$LParser$ASLRegExp$ = Parser$_expect$LParser$ASLRegExp$;

function Parser$_expectIdentifierOpt$LParser$($this) {
	return Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
};

Parser._expectIdentifierOpt$LParser$ = Parser$_expectIdentifierOpt$LParser$;

function Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, completionCb) {
	var matched;
	var offset;
	var this$0;
	var lineNumber$0;
	var columnOffset$0;
	var length$0;
	var this$1;
	var prefix$0;
	Parser$_advanceToken$LParser$($this);
	matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxIdent);
	if (completionCb != null && $this._completionRequest != null) {
		this$0 = $this._completionRequest;
		lineNumber$0 = $this._lineNumber;
		columnOffset$0 = $this._columnOffset;
		length$0 = (matched != null ? matched[0].length : 0);
		offset = (lineNumber$0 !== this$0._lineNumber ? -1 : columnOffset$0 <= this$0._columnOffest && this$0._columnOffest <= columnOffset$0 + length$0 ? this$0._columnOffest - columnOffset$0 : -1);
		if (offset !== -1) {
			this$1 = completionCb($this);
			prefix$0 = matched[0].substring(0, offset);
			this$1._prefix = prefix$0;
			$this._completionRequest._candidates.push(this$1);
		}
	}
	if (matched == null) {
		return null;
	}
	if ($__jsx_ObjectHasOwnProperty.call(_Lexer.keywords, matched[0])) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "expected an identifier but found a keyword"));
		return null;
	}
	if ($__jsx_ObjectHasOwnProperty.call(_Lexer.reserved, matched[0])) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "expected an identifier but found a reserved word"));
		return null;
	}
	$this._tokenLength = matched[0].length;
	return ({_value: matched[0], _isIdentifier: true, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
};

Parser._expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$ = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$;

function Parser$_expectIdentifier$LParser$($this) {
	return Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
};

Parser._expectIdentifier$LParser$ = Parser$_expectIdentifier$LParser$;

function Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, completionCb) {
	var token;
	token = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, completionCb);
	if (token != null) {
		return token;
	}
	$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "expected an identifier"));
	return null;
};

Parser._expectIdentifier$LParser$F$LParser$LCompletionCandidates$$ = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$;

function Parser$_expectStringLiteralOpt$LParser$($this) {
	var matched;
	Parser$_advanceToken$LParser$($this);
	matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxStringLiteral);
	if (matched == null) {
		return null;
	}
	$this._tokenLength = matched[0].length;
	return ({_value: matched[0], _isIdentifier: false, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
};

Parser._expectStringLiteralOpt$LParser$ = Parser$_expectStringLiteralOpt$LParser$;

function Parser$_expectStringLiteral$LParser$($this) {
	var token;
	token = Parser$_expectStringLiteralOpt$LParser$($this);
	if (token != null) {
		return token;
	}
	$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "expected a string literal"));
	return null;
};

Parser._expectStringLiteral$LParser$ = Parser$_expectStringLiteral$LParser$;

function Parser$_expectNumberLiteralOpt$LParser$($this) {
	var matched;
	Parser$_advanceToken$LParser$($this);
	matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxIntegerLiteral);
	if (matched == null) {
		matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxNumberLiteral);
	}
	if (matched == null) {
		return null;
	}
	$this._tokenLength = matched[0].length;
	return ({_value: matched[0], _isIdentifier: false, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
};

Parser._expectNumberLiteralOpt$LParser$ = Parser$_expectNumberLiteralOpt$LParser$;

function Parser$_expectRegExpLiteralOpt$LParser$($this) {
	var matched;
	Parser$_advanceToken$LParser$($this);
	matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxRegExpLiteral);
	if (matched == null) {
		return null;
	}
	$this._tokenLength = matched[0].length;
	return ({_value: matched[0], _isIdentifier: false, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
};

Parser._expectRegExpLiteralOpt$LParser$ = Parser$_expectRegExpLiteralOpt$LParser$;

function Parser$_skipStatement$LParser$($this) {
	var advanced;
	var _columnOffset$0;
	advanced = false;
	while (! Parser$_isEOF$LParser$($this)) {
		switch ($this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + 1)) {
		case ";":
			$this._tokenLength = 1;
			Parser$_advanceToken$LParser$($this);
			return;
		case "{":
			if (! advanced) {
				$this._tokenLength = 1;
				Parser$_advanceToken$LParser$($this);
			}
			return;
		case "}":
			return;
		}
		$this._tokenLength = 1;
		Parser$_advanceToken$LParser$($this);
		advanced = true;
	}
};

Parser._skipStatement$LParser$ = Parser$_skipStatement$LParser$;

function Parser$_importStatement$LParser$LToken$($this, importToken) {
	var classes;
	var token;
	var filenameToken;
	var alias;
	var success;
	var i;
	var j;
	var imprt;
	var getAlias$this$0;
	var classes$len$0;
	classes = null;
	token = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (token != null) {
		classes = [ token ];
		while (true) {
			if ((token = Parser$_expect$LParser$ASLRegExp$($this, [ ",", "from" ], null)) == null) {
				return false;
			}
			if (token._value === "from") {
				break;
			}
			if ((token = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null)) == null) {
				return false;
			}
			classes.push(token);
		}
	}
	filenameToken = Parser$_expectStringLiteral$LParser$($this);
	if (filenameToken == null) {
		return false;
	}
	alias = null;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "into" ], null) != null) {
		if ((alias = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null)) == null) {
			return false;
		}
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
		return false;
	}
	if (alias != null && $__jsx_ObjectHasOwnProperty.call(_Lexer.builtInClasses, alias._value)) {
		$this._errors.push(new CompileError(alias, "cannot use name of a built-in class as an alias"));
		return false;
	}
	if (classes != null) {
		success = true;
		for (i = 0; i < $this._imports.length; ++ i) {
			for ((j = 0, classes$len$0 = classes.length); j < classes$len$0; ++ j) {
				if (! Import$checkNameConflict$LImport$ALCompileError$LToken$($this._imports[i], $this._errors, classes[j])) {
					success = false;
				}
			}
		}
		if (! success) {
			return false;
		}
	} else {
		for (i = 0; i < $this._imports.length; ++ i) {
			if (alias == null) {
				if ((getAlias$this$0 = $this._imports[i], getAlias$this$0._aliasToken ? getAlias$this$0._aliasToken._value : null) == null && $this._imports[i]._filenameToken._value === filenameToken._value) {
					$this._errors.push(new CompileError(filenameToken, "cannot import the same file more than once (unless using an alias)"));
					return false;
				}
			} else {
				if (! Import$checkNameConflict$LImport$ALCompileError$LToken$($this._imports[i], $this._errors, alias)) {
					return false;
				}
			}
		}
	}
	imprt = Import$create$ALCompileError$LToken$LToken$ALToken$($this._errors, filenameToken, alias, classes);
	if (imprt == null) {
		return false;
	}
	$this._imports.push(imprt);
	return true;
};

Parser._importStatement$LParser$LToken$ = Parser$_importStatement$LParser$LToken$;

function Parser$_expectClassDefOpt$LParser$($this) {
	var state;
	var token;
	var expected$0;
	var _value$0;
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	try {
		while (true) {
			expected$0 = [ "class", "interface", "mixin", "abstract", "final" ];
			token = Parser$_expectOpt$LParser$ASLRegExp$($this, expected$0, null);
			if (token == null) {
				return false;
			}
			if ((_value$0 = token._value) === "class" || _value$0 === "interface" || _value$0 === "mixin") {
				return true;
			}
		}
	} finally {
		Parser$_restoreState$LParser$LParserState$($this, state);
	}
	return true;
};

Parser._expectClassDefOpt$LParser$ = Parser$_expectClassDefOpt$LParser$;

function Parser$_classDefinition$LParser$($this) {
	var nativeSource;
	var docComment;
	var token;
	var newFlag;
	var className;
	var implementType;
	var members;
	var success;
	var member;
	var assignToken;
	var i;
	var classDef;
	var templateClassDef;
	var expected$0;
	var _extendType$0;
	var _classType$0;
	$this._classType = null;
	$this._extendType = null;
	$this._implementTypes = [];
	$this._objectTypesUsed = [];
	$this._inners = [];
	$this._templateInners = [];
	$this._classFlags = 0;
	if ($this._outerClass) {
		$this._classFlags |= $this._outerClass.classFlags & 16;
	}
	nativeSource = null;
	docComment = null;
	while (true) {
		expected$0 = [ "class", "interface", "mixin", "abstract", "final", "native", "__fake__", "__export__" ];
		token = Parser$_expect$LParser$ASLRegExp$($this, expected$0, null);
		if (token == null) {
			return null;
		}
		if ($this._classFlags === 0) {
			docComment = $this._docComment;
		}
		if (token._value === "class") {
			break;
		} else {
			if (token._value === "interface") {
				if (($this._classFlags & 20) !== 0) {
					$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "interface cannot have final or native attribute set"));
					return null;
				}
				$this._classFlags |= 64;
				break;
			} else {
				if (token._value === "mixin") {
					if (($this._classFlags & 16404) !== 0) {
						$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "mixin cannot have final, native, or __export__ attribute set"));
						return null;
					}
					$this._classFlags |= 128;
					break;
				}
			}
		}
		newFlag = 0;
		switch (token._value) {
		case "abstract":
			newFlag = 2;
			break;
		case "final":
			newFlag = 4;
			break;
		case "native":
			if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "(" ], null) != null) {
				$this._errors.push(new DeprecatedWarning$0($this._filename, $this._lineNumber, $this._columnOffset, "use of native(\"...\") is deprecated, use class N { ... } = \"...\"; instead"));
				nativeSource = Parser$_expectStringLiteral$LParser$($this);
				Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null);
			}
			newFlag = 16;
			break;
		case "__fake__":
			newFlag = 256;
			break;
		case "__export__":
			newFlag = 16384;
			break;
		default:
			throw new Error("logic flaw");
		}
		if (($this._classFlags & newFlag) !== 0) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "same attribute cannot be specified more than once"));
			return null;
		}
		$this._classFlags |= newFlag;
	}
	className = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (className == null) {
		return null;
	}
	if (($this._typeArgs = Parser$_formalTypeArguments$LParser$($this)) == null) {
		return null;
	}
	_classType$0 = $this._classType = new ParsedObjectType(new QualifiedName$1(className, $this._outerClass != null ? $this._outerClass.classType : null), $this._typeArgs.map((function (token) {
		return new ParsedObjectType(new QualifiedName(token), []);
	})));
	$this._objectTypesUsed.push(_classType$0);
	if (($this._classFlags & 192) === 0) {
		if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "extends" ], null) != null) {
			$this._extendType = Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, null, true, (function (classDef) {
				return (classDef.flags$() & 196) === 0;
			}));
		}
		if ($this._extendType == null && className._value !== "Object") {
			_extendType$0 = $this._extendType = new ParsedObjectType(new QualifiedName(new Token$1("Object", true)), []);
			$this._objectTypesUsed.push(_extendType$0);
		}
	} else {
		if (($this._classFlags & 22) !== 0) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "interface or mixin cannot have attributes: 'abstract', 'final', 'native"));
			$this._classFlags &= -23;
		}
	}
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "implements" ], null) != null) {
		do {
			implementType = Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, null, true, (function (classDef) {
				return (classDef.flags$() & 192) !== 0;
			}));
			if (implementType != null) {
				$this._implementTypes.push(implementType);
			}
		} while (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "," ], null) != null);
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "{" ], null) == null) {
		return null;
	}
	members = [];
	success = true;
	while (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "}" ], null) == null) {
		if (! Parser$_expectIsNotEOF$LParser$($this)) {
			break;
		}
		if (Parser$_expectClassDefOpt$LParser$($this)) {
			$this._outerClass = ({outer: $this._outerClass, classType: $this._classType, typeArgs: $this._typeArgs, extendType: $this._extendType, implementTypes: $this._implementTypes, objectTypesUsed: $this._objectTypesUsed, classFlags: $this._classFlags, inners: $this._inners, templateInners: $this._templateInners});
			if (Parser$_classDefinition$LParser$($this) == null) {
				Parser$_skipStatement$LParser$($this);
			}
			Parser$_popClassState$LParser$($this);
			continue;
		}
		member = Parser$_memberDefinition$LParser$($this);
		if (member != null) {
			members.push(member);
		} else {
			Parser$_skipStatement$LParser$($this);
		}
	}
	assignToken = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "=" ], null);
	if (assignToken != null) {
		nativeSource = Parser$_expectStringLiteral$LParser$($this);
		if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
			return null;
		}
		if (($this._classFlags & 16) === 0) {
			$this._errors.push(new CompileError(assignToken, "in-line native definition requires native attribute"));
			return null;
		}
	}
	if (($this._classFlags & 16) === 0 && $__jsx_ObjectHasOwnProperty.call(_Lexer.builtInClasses, className._value)) {
		$this._errors.push(new CompileError(className, "cannot re-define a built-in class"));
		success = false;
	} else {
		if ($this._outerClass != null) {
			for (i = 0; i < $this._outerClass.inners.length; ++ i) {
				if ($this._outerClass.inners[i].className$() === className._value) {
					$this._errors.push(new CompileError(className, "a non-template inner class with the same name has been already declared"));
					success = false;
					break;
				}
			}
			for (i = 0; i < $this._outerClass.templateInners.length; ++ i) {
				if ($this._outerClass.templateInners[i]._className === className._value) {
					$this._errors.push(new CompileError(className, "a non-template inner class with the same name has been already declared"));
					success = false;
					break;
				}
			}
		} else {
			for (i = 0; i < $this._imports.length; ++ i) {
				if (! Import$checkNameConflict$LImport$ALCompileError$LToken$($this._imports[i], $this._errors, className)) {
					success = false;
				}
			}
			for (i = 0; i < $this._classDefs.length; ++ i) {
				if ($this._classDefs[i].className$() === className._value) {
					$this._errors.push(new CompileError(className, "a non-template class with the same name has been already declared"));
					success = false;
					break;
				}
			}
			for (i = 0; i < $this._templateClassDefs.length; ++ i) {
				if ($this._templateClassDefs[i]._className === className._value) {
					$this._errors.push(new CompileError(className, "a template class with the name same has been already declared"));
					success = false;
					break;
				}
			}
		}
	}
	if (! success) {
		return null;
	}
	if ($this._typeArgs.length !== 0) {
		templateClassDef = new TemplateClassDefinition(className, className._value, $this._classFlags, $this._typeArgs, $this._extendType, $this._implementTypes, members, $this._inners, $this._templateInners, $this._objectTypesUsed, docComment);
		if ($this._outerClass != null) {
			$this._outerClass.templateInners.push(templateClassDef);
		} else {
			$this._templateClassDefs.push(templateClassDef);
		}
		classDef = templateClassDef;
	} else {
		classDef = new ClassDefinition(className, className._value, $this._classFlags, $this._extendType, $this._implementTypes, members, $this._inners, $this._templateInners, $this._objectTypesUsed, docComment);
		if ($this._outerClass != null) {
			$this._outerClass.inners.push(classDef);
		} else {
			$this._classDefs.push(classDef);
		}
	}
	if (nativeSource != null) {
		classDef._nativeSource = nativeSource;
	}
	classDef._parser = $this;
	return classDef;
};

Parser._classDefinition$LParser$ = Parser$_classDefinition$LParser$;

function Parser$_memberDefinition$LParser$($this) {
	var flags;
	var isNoExport;
	var docComment;
	var token;
	var newFlag;
	var shouldExport;
	var name;
	var type;
	var initialValue;
	var closures;
	var expected$0;
	var _value$0;
	flags = 0;
	isNoExport = false;
	docComment = null;
	while (true) {
		expected$0 = [ "function", "var", "static", "abstract", "override", "final", "const", "native", "__readonly__", "inline", "__pure__", "delete", "__export__", "__noexport__" ];
		token = Parser$_expect$LParser$ASLRegExp$($this, expected$0, null);
		if (token == null) {
			return null;
		}
		if (flags === 0) {
			docComment = $this._docComment;
		}
		if (token._value === "const") {
			if ((flags & 8) === 0) {
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "constants must be static"));
				return null;
			}
			flags |= 1;
			break;
		} else {
			if ((_value$0 = token._value) === "function" || _value$0 === "var") {
				break;
			} else {
				if (token._value === "__noexport__") {
					if (isNoExport) {
						$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "same attribute cannot be specified more than once"));
						return null;
					} else {
						if ((flags & 16384) !== 0) {
							$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "cannot set the attribute, already declared as __export__"));
							return null;
						}
					}
					isNoExport = true;
				} else {
					newFlag = 0;
					switch (token._value) {
					case "static":
						if (($this._classFlags & 192) !== 0) {
							$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "interfaces and mixins cannot have static members"));
							return null;
						}
						newFlag = 8;
						break;
					case "abstract":
						newFlag = 2;
						break;
					case "override":
						if (($this._classFlags & 64) !== 0) {
							$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "functions of an interface cannot have 'override' attribute set"));
							return null;
						}
						newFlag = 32;
						break;
					case "final":
						if (($this._classFlags & 64) !== 0) {
							$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "functions of an interface cannot have 'final' attribute set"));
							return null;
						}
						newFlag = 4;
						break;
					case "native":
						newFlag = 16;
						break;
					case "__readonly__":
						newFlag = 512;
						break;
					case "inline":
						newFlag = 1024;
						break;
					case "__pure__":
						newFlag = 2048;
						break;
					case "delete":
						newFlag = 4096;
						break;
					case "__export__":
						if (isNoExport) {
							$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "cannot set the attribute, already declared as __noexport__"));
							return null;
						}
						newFlag = 16384;
						break;
					default:
						throw new Error("logic flaw");
					}
					if ((flags & newFlag) !== 0) {
						$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "same attribute cannot be specified more than once"));
						return null;
					}
					flags |= newFlag;
				}
			}
		}
	}
	function shouldExport(name) {
		return (isNoExport ? false : ($this._classFlags & 16384) === 0 ? false : name.charAt(0) === "_" ? false : true);
	}
	if (($this._classFlags & 64) !== 0) {
		flags |= 2;
	}
	if (token._value === "function") {
		return Parser$_functionDefinition$LParser$LToken$NLDocComment$F$SB$($this, token, flags, docComment, shouldExport);
	}
	if ((flags & -16908) !== 0) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "variables may only have attributes: static, abstract, const"));
		return null;
	}
	if ((flags & 512) !== 0 && ($this._classFlags & 16) === 0) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "only native classes may use the __readonly__ attribute"));
		return null;
	}
	name = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (name == null) {
		return null;
	}
	if (shouldExport(name._value)) {
		flags |= 16384;
	}
	type = null;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ":" ], null) != null) {
		if ((type = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
			return null;
		}
	}
	initialValue = null;
	closures = [];
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "=" ], null) != null) {
		if ((flags & 2) !== 0) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "abstract variable cannot have default value"));
			return null;
		}
		$this._closures = closures;
		initialValue = Parser$_assignExpr$LParser$B($this, false);
		$this._closures = null;
		if (initialValue == null) {
			return null;
		}
	}
	if (type == null && initialValue == null) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "variable declaration should either have type declaration or initial value"));
		return null;
	}
	if (! Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null)) {
		return null;
	}
	if ($this._typeArgs.length === 0 && initialValue == null && ($this._classFlags & 16) === 0) {
		initialValue = Expression$getDefaultValueExpressionOf$LType$(type);
	}
	return new MemberVariableDefinition(token, name, flags, type, initialValue, closures, docComment);
};

Parser._memberDefinition$LParser$ = Parser$_memberDefinition$LParser$;

function Parser$_functionDefinition$LParser$LToken$NLDocComment$F$SB$($this, token, flags, docComment, shouldExport) {
	var name;
	var typeArgs;
	var numObjectTypesUsed;
	var args;
	var returnType;
	var createDefinition;
	var endDeclToken;
	var lastToken;
	var funcDef;
	var expected$0;
	var _objectTypesUsed$0;
	var _typeArgs$0;
	name = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (name == null) {
		return null;
	}
	if (shouldExport(name._value)) {
		flags |= 16384;
	}
	if (name._value === "constructor") {
		if (($this._classFlags & 64) !== 0) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "interface cannot have a constructor"));
			return null;
		}
		if ((flags & 6) !== 0) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "constructor cannot be declared as 'abstract' or 'final'"));
			return null;
		}
		flags |= 4;
	}
	flags |= $this._classFlags & 20;
	typeArgs = Parser$_formalTypeArguments$LParser$($this);
	if (typeArgs == null) {
		return null;
	}
	if (typeArgs.length !== 0 && ($this._classFlags & 16) === 0) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "only native classes may have template functions (for the time being)"));
		return null;
	}
	$this._typeArgs = $this._typeArgs.concat(typeArgs);
	numObjectTypesUsed = $this._objectTypesUsed.length;
	Parser$_pushScope$LParser$LLocalVariable$ALArgumentDeclaration$($this, null, null);
	try {
		if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null) {
			return null;
		}
		args = Parser$_functionArgumentsExpr$LParser$BBB($this, ($this._classFlags & 16) !== 0, true, true);
		if (args == null) {
			return null;
		}
		returnType = null;
		if (name._value === "constructor") {
			returnType = Type.voidType;
		} else {
			if (Parser$_expect$LParser$ASLRegExp$($this, [ ":" ], null) == null) {
				return null;
			}
			returnType = Parser$_typeDeclaration$LParser$B($this, true);
			if (returnType == null) {
				return null;
			}
		}
		if ((flags & 4096) !== 0) {
			if (name._value !== "constructor" || (flags & 8) !== 0) {
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "only constructors may have the \"delete\" attribute set"));
				return null;
			}
			if (args.length !== 0) {
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "cannot \"delete\" a constructor with one or more arguments"));
				return null;
			}
		}
		function createDefinition(locals, statements, closures, lastToken) {
			return (typeArgs.length !== 0 ? new TemplateFunctionDefinition(token, name, flags, typeArgs, returnType, args, locals, statements, closures, lastToken, docComment) : new MemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastToken, docComment));
		}
		if (($this._classFlags & 4160) !== 0) {
			if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
				return null;
			}
			return createDefinition(null, null, [], null);
		} else {
			if ((flags & 18) !== 0) {
				expected$0 = [ ";", "{" ];
				endDeclToken = Parser$_expect$LParser$ASLRegExp$($this, expected$0, null);
				if (endDeclToken == null) {
					return null;
				}
				if (endDeclToken._value === ";") {
					return createDefinition(null, null, [], null);
				}
			} else {
				if (Parser$_expect$LParser$ASLRegExp$($this, [ "{" ], null) == null) {
					return null;
				}
			}
		}
		$this._arguments = args;
		if (name._value === "constructor") {
			lastToken = Parser$_initializeBlock$LParser$($this);
		} else {
			lastToken = Parser$_block$LParser$($this);
		}
		if ($this._isGenerator) {
			flags |= 8192;
		}
		funcDef = createDefinition($this._locals, $this._statements, $this._closures, lastToken);
		return funcDef;
	} finally {
		Parser$_popScope$LParser$($this);
		(_typeArgs$0 = $this._typeArgs).splice(_typeArgs$0.length - typeArgs.length, _typeArgs$0.length);
		if (typeArgs.length !== 0) {
			(_objectTypesUsed$0 = $this._objectTypesUsed).splice(numObjectTypesUsed, _objectTypesUsed$0.length - numObjectTypesUsed);
		}
	}
};

Parser._functionDefinition$LParser$LToken$NLDocComment$F$SB$ = Parser$_functionDefinition$LParser$LToken$NLDocComment$F$SB$;

function Parser$_formalTypeArguments$LParser$($this) {
	var typeArgs;
	var typeArg;
	var token;
	var expected$0;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "." ], null) == null) {
		return [];
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "<" ], null) == null) {
		return null;
	}
	typeArgs = [];
	do {
		typeArg = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
		if (typeArg == null) {
			return null;
		}
		typeArgs.push(typeArg);
		expected$0 = [ ",", ">" ];
		token = Parser$_expectOpt$LParser$ASLRegExp$($this, expected$0, null);
		if (token == null) {
			return null;
		}
	} while (token._value === ",");
	return typeArgs;
};

Parser._formalTypeArguments$LParser$ = Parser$_formalTypeArguments$LParser$;

function Parser$_actualTypeArguments$LParser$($this) {
	var types;
	var state;
	var type;
	var token;
	var expected$0;
	types = [];
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "." ], null) == null) {
		return types;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "<" ], null) == null) {
		Parser$_restoreState$LParser$LParserState$($this, state);
		return types;
	}
	do {
		type = Parser$_typeDeclaration$LParser$B($this, false);
		if (type == null) {
			return null;
		}
		types.push(type);
		expected$0 = [ ">", "," ];
		token = Parser$_expect$LParser$ASLRegExp$($this, expected$0, null);
		if (token == null) {
			return null;
		}
	} while (token._value === ",");
	return types;
};

Parser._actualTypeArguments$LParser$ = Parser$_actualTypeArguments$LParser$;

function Parser$_typeDeclaration$LParser$B($this, allowVoid) {
	var typeDecl;
	var arrayType$0;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "void" ], null) != null) {
		if (! allowVoid) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "'void' cannot be used here"));
			return null;
		}
		return Type.voidType;
	}
	typeDecl = Parser$_typeDeclarationNoArrayNoVoid$LParser$($this);
	if (typeDecl == null) {
		return null;
	}
	while (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "[" ], null) != null) {
		if (Parser$_expect$LParser$ASLRegExp$($this, [ "]" ], null) == null) {
			return null;
		}
		if (typeDecl instanceof NullableType) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "Nullable.<T> cannot be an array, should be: T[]"));
			return null;
		}
		arrayType$0 = new ParsedObjectType(new QualifiedName(new Token$1("Array", true)), [ typeDecl ]);
		$this._objectTypesUsed.push(arrayType$0);
		typeDecl = arrayType$0;
	}
	return typeDecl;
};

Parser._typeDeclaration$LParser$B = Parser$_typeDeclaration$LParser$B;

function Parser$_typeDeclarationNoArrayNoVoid$LParser$($this) {
	var token;
	var expected$0;
	expected$0 = [ "MayBeUndefined", "Nullable", "variant" ];
	token = Parser$_expectOpt$LParser$ASLRegExp$($this, expected$0, null);
	if (token == null) {
		return Parser$_primaryTypeDeclaration$LParser$($this);
	}
	switch (token._value) {
	case "MayBeUndefined":
		$this._errors.push(new DeprecatedWarning$0($this._filename, $this._lineNumber, $this._columnOffset, "use of 'MayBeUndefined' is deprecated, use 'Nullable' instead"));
	case "Nullable":
		return Parser$_nullableTypeDeclaration$LParser$($this);
	case "variant":
		return Type.variantType;
	default:
		throw new Error("logic flaw");
	}
};

Parser._typeDeclarationNoArrayNoVoid$LParser$ = Parser$_typeDeclarationNoArrayNoVoid$LParser$;

function Parser$_nullableTypeDeclaration$LParser$($this) {
	var baseType;
	var i;
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "." ], null) == null || Parser$_expect$LParser$ASLRegExp$($this, [ "<" ], null) == null) {
		return null;
	}
	baseType = Parser$_typeDeclaration$LParser$B($this, false);
	if (baseType == null) {
		return null;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ">" ], null) == null) {
		return null;
	}
	if (baseType.equals$LType$(Type.variantType)) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "variant cannot be declared as nullable (since it is always nullable)"));
		return null;
	}
	if (baseType instanceof NullableType) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "nested Nullable.<T> is forbidden"));
		return null;
	}
	if ($this._typeArgs != null) {
		for (i = 0; i < $this._typeArgs.length; ++ i) {
			if (baseType.equals$LType$(new ParsedObjectType(new QualifiedName($this._typeArgs[i]), []))) {
				return new NullableType(baseType);
			}
		}
	}
	return (baseType instanceof PrimitiveType ? new NullableType(baseType) : baseType);
};

Parser._nullableTypeDeclaration$LParser$ = Parser$_nullableTypeDeclaration$LParser$;

function Parser$_primaryTypeDeclaration$LParser$($this) {
	var token;
	var expected$0;
	expected$0 = [ "(", "function", "boolean", "int", "number", "string" ];
	token = Parser$_expectOpt$LParser$ASLRegExp$($this, expected$0, null);
	if (token != null) {
		switch (token._value) {
		case "(":
			return Parser$_lightFunctionTypeDeclaration$LParser$LType$($this, null);
		case "function":
			return Parser$_functionTypeDeclaration$LParser$LType$($this, null);
		case "boolean":
			return Type.booleanType;
		case "int":
			return Type.integerType;
		case "number":
			return Type.numberType;
		case "string":
			return Type.stringType;
		default:
			throw new Error("logic flaw");
		}
	} else {
		return Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, null, true, null);
	}
};

Parser._primaryTypeDeclaration$LParser$ = Parser$_primaryTypeDeclaration$LParser$;

function Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, firstToken, allowInner, autoCompleteMatchCb) {
	var token;
	var imprt;
	var qualifiedName;
	var typeArgs;
	var objectType;
	var enclosingType;
	var _value$0;
	if (firstToken == null) {
		if ((token = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, (function (self) {
			return new CompletionCandidatesOfTopLevel(self, autoCompleteMatchCb);
		}))) == null) {
			return null;
		}
	} else {
		token = firstToken;
	}
	if (token._value === "variant") {
		$this._errors.push(new CompileError(token, "cannot use 'variant' as a class name"));
		return null;
	} else {
		if ((_value$0 = token._value) === "Nullable" || _value$0 === "MayBeUndefined") {
			$this._errors.push(new CompileError(token, "cannot use 'Nullable' (or MayBeUndefined) as a class name"));
			return null;
		}
	}
	imprt = Parser$lookupImportAlias$LParser$S($this, token._value);
	if (imprt != null) {
		if (Parser$_expect$LParser$ASLRegExp$($this, [ "." ], null) == null) {
			return null;
		}
		token = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, (function (self) {
			return new _CompletionCandidatesOfNamespace(imprt, autoCompleteMatchCb);
		}));
		if (token == null) {
			return null;
		}
	}
	if (! allowInner) {
		qualifiedName = new QualifiedName$0(token, imprt);
		typeArgs = Parser$_actualTypeArguments$LParser$($this);
		if (typeArgs == null) {
			return null;
		} else {
			if (typeArgs.length !== 0) {
				return Parser$_templateTypeDeclaration$LParser$LQualifiedName$ALType$($this, qualifiedName, typeArgs);
			} else {
				objectType = new ParsedObjectType(qualifiedName, []);
				$this._objectTypesUsed.push(objectType);
				return objectType;
			}
		}
	} else {
		enclosingType = null;
		while (true) {
			qualifiedName = (enclosingType != null ? new QualifiedName$1(token, enclosingType) : new QualifiedName$0(token, imprt));
			typeArgs = Parser$_actualTypeArguments$LParser$($this);
			if (typeArgs == null) {
				return null;
			} else {
				if (typeArgs.length !== 0) {
					enclosingType = Parser$_templateTypeDeclaration$LParser$LQualifiedName$ALType$($this, qualifiedName, typeArgs);
				} else {
					objectType = new ParsedObjectType(qualifiedName, []);
					$this._objectTypesUsed.push(objectType);
					enclosingType = objectType;
				}
			}
			if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "." ], null) == null) {
				break;
			}
			token = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
			if (token == null) {
				return null;
			}
		}
		return enclosingType;
	}
};

Parser._objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$ = Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$;

function Parser$_templateTypeDeclaration$LParser$LQualifiedName$ALType$($this, qualifiedName, typeArgs) {
	var className;
	var objectType;
	var this$0;
	var message$0;
	this$0 = qualifiedName._token;
	className = this$0._value;
	if ((className === "Array" || className === "Map") && typeArgs[0] instanceof NullableType) {
		message$0 = "cannot declare " + className + ".<Nullable.<T>>, should be " + className + ".<T>";
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$0));
		return null;
	}
	objectType = new ParsedObjectType(qualifiedName, typeArgs);
	$this._objectTypesUsed.push(objectType);
	return objectType;
};

Parser._templateTypeDeclaration$LParser$LQualifiedName$ALType$ = Parser$_templateTypeDeclaration$LParser$LQualifiedName$ALType$;

function Parser$_lightFunctionTypeDeclaration$LParser$LType$($this, objectType) {
	var argTypes;
	var isVarArg;
	var argType;
	var token;
	var returnType;
	var expected$0;
	argTypes = [];
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
		do {
			isVarArg = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "..." ], null) != null;
			argType = Parser$_typeDeclaration$LParser$B($this, false);
			if (argType == null) {
				return null;
			}
			if (isVarArg) {
				argTypes.push(new VariableLengthArgumentType(argType));
				if (Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
					return null;
				}
				break;
			}
			argTypes.push(argType);
			expected$0 = [ ")", "," ];
			token = Parser$_expect$LParser$ASLRegExp$($this, expected$0, null);
			if (token == null) {
				return null;
			}
		} while (token._value === ",");
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "->" ], null) == null) {
		return null;
	}
	returnType = Parser$_typeDeclaration$LParser$B($this, true);
	return (returnType == null ? null : objectType != null ? new MemberFunctionType(null, objectType, returnType, argTypes, true) : new StaticFunctionType(null, returnType, argTypes, true));
};

Parser._lightFunctionTypeDeclaration$LParser$LType$ = Parser$_lightFunctionTypeDeclaration$LParser$LType$;

function Parser$_functionTypeDeclaration$LParser$LType$($this, objectType) {
	var argTypes;
	var isVarArg;
	var argType;
	var token;
	var returnType;
	var expected$0;
	Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null) {
		return null;
	}
	argTypes = [];
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
		do {
			isVarArg = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "..." ], null) != null;
			Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
			if (Parser$_expect$LParser$ASLRegExp$($this, [ ":" ], null) == null) {
				return null;
			}
			argType = Parser$_typeDeclaration$LParser$B($this, false);
			if (argType == null) {
				return null;
			}
			if (isVarArg) {
				argTypes.push(new VariableLengthArgumentType(argType));
				if (Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
					return null;
				}
				break;
			}
			argTypes.push(argType);
			expected$0 = [ ")", "," ];
			token = Parser$_expect$LParser$ASLRegExp$($this, expected$0, null);
			if (token == null) {
				return null;
			}
		} while (token._value === ",");
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ":" ], null) == null) {
		return null;
	}
	returnType = Parser$_typeDeclaration$LParser$B($this, true);
	return (returnType == null ? null : objectType != null ? new MemberFunctionType(null, objectType, returnType, argTypes, true) : new StaticFunctionType(null, returnType, argTypes, true));
};

Parser._functionTypeDeclaration$LParser$LType$ = Parser$_functionTypeDeclaration$LParser$LType$;

function Parser$_registerArrayTypeOf$LParser$LToken$LType$($this, token, elementType) {
	var arrayType;
	arrayType = new ParsedObjectType(new QualifiedName(new Token$1("Array", true)), [ elementType ]);
	$this._objectTypesUsed.push(arrayType);
	return arrayType;
};

Parser._registerArrayTypeOf$LParser$LToken$LType$ = Parser$_registerArrayTypeOf$LParser$LToken$LType$;

function Parser$_initializeBlock$LParser$($this) {
	var token;
	var state;
	while ((token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "}" ], null)) == null) {
		state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
		if (! Parser$_constructorInvocationStatement$LParser$($this)) {
			Parser$_restoreState$LParser$LParserState$($this, state);
			return Parser$_block$LParser$($this);
		}
	}
	return token;
};

Parser._initializeBlock$LParser$ = Parser$_initializeBlock$LParser$;

function Parser$_block$LParser$($this) {
	var token;
	while ((token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "}" ], null)) == null) {
		if (! Parser$_expectIsNotEOF$LParser$($this)) {
			return null;
		}
		if (! Parser$_statement$LParser$($this)) {
			Parser$_skipStatement$LParser$($this);
		}
	}
	return token;
};

Parser._block$LParser$ = Parser$_block$LParser$;

function Parser$_statement$LParser$($this) {
	var state;
	var label;
	var token;
	var expr;
	var expected$0;
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	label = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (label != null && Parser$_expectOpt$LParser$ASLRegExp$($this, [ ":" ], null) != null) {
	} else {
		Parser$_restoreState$LParser$LParserState$($this, state);
		label = null;
	}
	expected$0 = [ "{", "var", ";", "if", "do", "while", "for", "continue", "break", "return", "yield", "switch", "throw", "try", "assert", "log", "delete", "debugger", "function", "void" ];
	token = Parser$_expectOpt$LParser$ASLRegExp$($this, expected$0, null);
	if (label != null) {
		if (! (token != null && token._value.match(/^(?:do|while|for|switch)$/) != null)) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "only blocks, iteration statements, and switch statements are allowed after a label"));
			return false;
		}
	}
	if (token != null) {
		switch (token._value) {
		case "{":
			return Parser$_block$LParser$($this) != null;
		case "var":
			return Parser$_variableStatement$LParser$($this);
		case ";":
			return true;
		case "if":
			return Parser$_ifStatement$LParser$LToken$($this, token);
		case "do":
			return Parser$_doWhileStatement$LParser$LToken$LToken$($this, token, label);
		case "while":
			return Parser$_whileStatement$LParser$LToken$LToken$($this, token, label);
		case "for":
			return Parser$_forStatement$LParser$LToken$LToken$($this, token, label);
		case "continue":
			return Parser$_continueStatement$LParser$LToken$($this, token);
		case "break":
			return Parser$_breakStatement$LParser$LToken$($this, token);
		case "return":
			return Parser$_returnStatement$LParser$LToken$($this, token);
		case "yield":
			return Parser$_yieldStatement$LParser$LToken$($this, token);
		case "switch":
			return Parser$_switchStatement$LParser$LToken$LToken$($this, token, label);
		case "throw":
			return Parser$_throwStatement$LParser$LToken$($this, token);
		case "try":
			return Parser$_tryStatement$LParser$LToken$($this, token);
		case "assert":
			return Parser$_assertStatement$LParser$LToken$($this, token);
		case "log":
			return Parser$_logStatement$LParser$LToken$($this, token);
		case "delete":
			return Parser$_deleteStatement$LParser$LToken$($this, token);
		case "debugger":
			$this._statements.push(new DebuggerStatement(token));
			return true;
		case "function":
			return Parser$_functionStatement$LParser$LToken$($this, token);
		case "void":
			break;
		default:
			throw new Error("logic flaw, got " + token._value);
		}
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	$this._statements.push(new ExpressionStatement(expr));
	return (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null ? false : true);
};

Parser._statement$LParser$ = Parser$_statement$LParser$;

function Parser$_constructorInvocationStatement$LParser$($this) {
	var token;
	var classType;
	var i;
	var args;
	var _extendType$0;
	if ((token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "super" ], null)) != null) {
		classType = $this._extendType;
	} else {
		if ((token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "this" ], null)) != null) {
			classType = $this._classType;
		} else {
			if ((classType = Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, null, true, null)) == null) {
				return false;
			}
			token = classType._qualifiedName._token;
			if ($this._classType.equals$LType$(classType)) {
			} else {
				if ((_extendType$0 = $this._extendType) != null && _extendType$0.equals$LType$(classType)) {
				} else {
					for (i = 0; i < $this._implementTypes.length; ++ i) {
						if ($this._implementTypes[i].equals$LType$(classType)) {
							break;
						}
					}
					if (i === $this._implementTypes.length) {
						return false;
					}
				}
			}
		}
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null) {
		return false;
	}
	args = Parser$_argsExpr$LParser$($this);
	if (args == null) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
		return false;
	}
	$this._statements.push(new ConstructorInvocationStatement(token, classType, args));
	return true;
};

Parser._constructorInvocationStatement$LParser$ = Parser$_constructorInvocationStatement$LParser$;

function Parser$_variableStatement$LParser$($this) {
	var succeeded;
	var expr;
	succeeded = [ false ];
	expr = Parser$_variableDeclarations$LParser$BAB($this, false, succeeded);
	if (! succeeded[0]) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
		return false;
	}
	if (expr != null) {
		$this._statements.push(new ExpressionStatement(expr));
	}
	return true;
};

Parser._variableStatement$LParser$ = Parser$_variableStatement$LParser$;

function Parser$_functionStatement$LParser$LToken$($this, token) {
	var name;
	var args;
	var returnType;
	var funcLocal;
	var funcDef;
	name = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (name == null) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null) {
		return false;
	}
	args = Parser$_functionArgumentsExpr$LParser$BBB($this, false, true, false);
	if (args == null) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ":" ], null) == null) {
		return false;
	}
	returnType = Parser$_typeDeclaration$LParser$B($this, true);
	if (returnType == null) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "{" ], null) == null) {
		return false;
	}
	funcLocal = Parser$_registerLocal$LParser$LToken$LType$($this, name, new StaticFunctionType(token, returnType, args.map((function (arg) {
		return arg._type;
	})), false));
	funcDef = Parser$_functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$B($this, token, name, funcLocal, args, returnType, true);
	if (funcDef == null) {
		return false;
	}
	$this._closures.push(funcDef);
	funcDef._funcLocal = funcLocal;
	$this._statements.push(new FunctionStatement(token, funcDef));
	return true;
};

Parser._functionStatement$LParser$LToken$ = Parser$_functionStatement$LParser$LToken$;

function Parser$_ifStatement$LParser$LToken$($this, token) {
	var expr;
	var onTrueStatements;
	var onFalseStatements;
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null) {
		return false;
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
		return false;
	}
	onTrueStatements = Parser$_subStatements$LParser$($this);
	onFalseStatements = [];
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "else" ], null) != null) {
		onFalseStatements = Parser$_subStatements$LParser$($this);
	}
	$this._statements.push(new IfStatement(token, expr, onTrueStatements, onFalseStatements));
	return true;
};

Parser._ifStatement$LParser$LToken$ = Parser$_ifStatement$LParser$LToken$;

function Parser$_doWhileStatement$LParser$LToken$LToken$($this, token, label) {
	var statements;
	var expr;
	statements = Parser$_subStatements$LParser$($this);
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "while" ], null) == null) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null) {
		return false;
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
		return false;
	}
	$this._statements.push(new DoWhileStatement(token, label, expr, statements));
	return true;
};

Parser._doWhileStatement$LParser$LToken$LToken$ = Parser$_doWhileStatement$LParser$LToken$LToken$;

function Parser$_whileStatement$LParser$LToken$LToken$($this, token, label) {
	var expr;
	var statements;
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null) {
		return false;
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
		return false;
	}
	statements = Parser$_subStatements$LParser$($this);
	$this._statements.push(new WhileStatement(token, label, expr, statements));
	return true;
};

Parser._whileStatement$LParser$LToken$LToken$ = Parser$_whileStatement$LParser$LToken$LToken$;

function Parser$_forStatement$LParser$LToken$LToken$($this, token, label) {
	var state;
	var initExpr;
	var succeeded;
	var condExpr;
	var postExpr;
	var statements;
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	switch (Parser$_forInStatement$LParser$LToken$LToken$($this, token, label)) {
	case -1:
		break;
	case 0:
		return false;
	case 1:
		return true;
	}
	Parser$_restoreState$LParser$LParserState$($this, state);
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null) {
		return false;
	}
	initExpr = null;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ";" ], null) != null) {
	} else {
		if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "var" ], null) != null) {
			succeeded = [ false ];
			initExpr = Parser$_variableDeclarations$LParser$BAB($this, true, succeeded);
			if (! succeeded[0]) {
				return false;
			}
			if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
				return false;
			}
		} else {
			if ((initExpr = Parser$_expr$LParser$B($this, true)) == null) {
				return false;
			}
			if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
				return false;
			}
		}
	}
	condExpr = null;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ";" ], null) != null) {
	} else {
		if ((condExpr = Parser$_expr$LParser$B($this, false)) == null) {
			return false;
		}
		if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
			return false;
		}
	}
	postExpr = null;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ")" ], null) != null) {
	} else {
		if ((postExpr = Parser$_expr$LParser$B($this, false)) == null) {
			return false;
		}
		if (Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
			return false;
		}
	}
	statements = Parser$_subStatements$LParser$($this);
	$this._statements.push(new ForStatement(token, label, initExpr, condExpr, postExpr, statements));
	return true;
};

Parser._forStatement$LParser$LToken$LToken$ = Parser$_forStatement$LParser$LToken$LToken$;

function Parser$_forInStatement$LParser$LToken$LToken$($this, token, label) {
	var lhsExpr;
	var listExpr;
	var statements;
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null) {
		return 0;
	}
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "var" ], null) != null) {
		if ((lhsExpr = Parser$_variableDeclaration$LParser$B($this, true)) == null) {
			return -1;
		}
	} else {
		if ((lhsExpr = Parser$_lhsExpr$LParser$($this)) == null) {
			return -1;
		}
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "in" ], null) == null) {
		return -1;
	}
	listExpr = Parser$_expr$LParser$B($this, false);
	if (listExpr == null) {
		return 0;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
		return 0;
	}
	statements = Parser$_subStatements$LParser$($this);
	$this._statements.push(new ForInStatement(token, label, lhsExpr, listExpr, statements));
	return 1;
};

Parser._forInStatement$LParser$LToken$LToken$ = Parser$_forInStatement$LParser$LToken$LToken$;

function Parser$_continueStatement$LParser$LToken$($this, token) {
	var label;
	label = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
		return false;
	}
	$this._statements.push(new ContinueStatement(token, label));
	return true;
};

Parser._continueStatement$LParser$LToken$ = Parser$_continueStatement$LParser$LToken$;

function Parser$_breakStatement$LParser$LToken$($this, token) {
	var label;
	label = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
		return false;
	}
	$this._statements.push(new BreakStatement(token, label));
	return true;
};

Parser._breakStatement$LParser$LToken$ = Parser$_breakStatement$LParser$LToken$;

function Parser$_returnStatement$LParser$LToken$($this, token) {
	var expr;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ";" ], null) != null) {
		$this._statements.push(new ReturnStatement(token, null));
		return true;
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	$this._statements.push(new ReturnStatement(token, expr));
	return (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null ? false : true);
};

Parser._returnStatement$LParser$LToken$ = Parser$_returnStatement$LParser$LToken$;

function Parser$_yieldStatement$LParser$LToken$($this, token) {
	var expr;
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	$this._statements.push(new YieldStatement(token, expr));
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
		return false;
	}
	$this._isGenerator = true;
	return true;
};

Parser._yieldStatement$LParser$LToken$ = Parser$_yieldStatement$LParser$LToken$;

function Parser$_switchStatement$LParser$LToken$LToken$($this, token, label) {
	var expr;
	var foundCaseLabel;
	var foundDefaultLabel;
	var startStatementIndex;
	var caseOrDefaultToken;
	var labelExpr;
	var expected$0;
	var _statements$0;
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null) {
		return false;
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null) == null || Parser$_expect$LParser$ASLRegExp$($this, [ "{" ], null) == null) {
		return null;
	}
	foundCaseLabel = false;
	foundDefaultLabel = false;
	startStatementIndex = $this._statements.length;
	while (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "}" ], null) == null) {
		if (! Parser$_expectIsNotEOF$LParser$($this)) {
			return false;
		}
		if (! foundCaseLabel && ! foundDefaultLabel) {
			if ((caseOrDefaultToken = Parser$_expect$LParser$ASLRegExp$($this, [ "case", "default" ], null)) == null) {
				Parser$_skipStatement$LParser$($this);
				continue;
			}
		} else {
			expected$0 = [ "case", "default" ];
			caseOrDefaultToken = Parser$_expectOpt$LParser$ASLRegExp$($this, expected$0, null);
		}
		if (caseOrDefaultToken != null) {
			if (caseOrDefaultToken._value === "case") {
				labelExpr = Parser$_expr$LParser$B($this, false);
				if (labelExpr == null) {
					Parser$_skipStatement$LParser$($this);
					continue;
				}
				if (Parser$_expect$LParser$ASLRegExp$($this, [ ":" ], null) == null) {
					Parser$_skipStatement$LParser$($this);
					continue;
				}
				$this._statements.push(new CaseStatement(caseOrDefaultToken, labelExpr));
				foundCaseLabel = true;
			} else {
				if (Parser$_expect$LParser$ASLRegExp$($this, [ ":" ], null) == null) {
					Parser$_skipStatement$LParser$($this);
					continue;
				}
				if (foundDefaultLabel) {
					$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "cannot have more than one default statement within one switch block"));
					Parser$_skipStatement$LParser$($this);
					continue;
				}
				$this._statements.push(new DefaultStatement(caseOrDefaultToken));
				foundDefaultLabel = true;
			}
		} else {
			if (! Parser$_statement$LParser$($this)) {
				Parser$_skipStatement$LParser$($this);
			}
		}
	}
	(_statements$0 = $this._statements).push(new SwitchStatement(token, label, expr, _statements$0.splice(startStatementIndex, _statements$0.length - startStatementIndex)));
	return true;
};

Parser._switchStatement$LParser$LToken$LToken$ = Parser$_switchStatement$LParser$LToken$LToken$;

function Parser$_throwStatement$LParser$LToken$($this, token) {
	var expr;
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
		return false;
	}
	$this._statements.push(new ThrowStatement(token, expr));
	return true;
};

Parser._throwStatement$LParser$LToken$ = Parser$_throwStatement$LParser$LToken$;

function Parser$_tryStatement$LParser$LToken$($this, tryToken) {
	var startIndex;
	var tryStatements;
	var catchStatements;
	var catchOrFinallyToken;
	var catchIdentifier;
	var catchType;
	var caughtVariable;
	var finallyStatements;
	var expected$0;
	var _statements$0;
	var _locals$0;
	var _statements$1;
	var _statements$2;
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "{" ], null) == null) {
		return false;
	}
	startIndex = $this._statements.length;
	if (Parser$_block$LParser$($this) == null) {
		return false;
	}
	tryStatements = (_statements$0 = $this._statements).splice(startIndex, _statements$0.length - startIndex);
	catchStatements = [];
	expected$0 = [ "catch", "finally" ];
	catchOrFinallyToken = Parser$_expect$LParser$ASLRegExp$($this, expected$0, null);
	if (catchOrFinallyToken == null) {
		return false;
	}
	for (; catchOrFinallyToken != null && catchOrFinallyToken._value === "catch"; catchOrFinallyToken = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "catch", "finally" ], null)) {
		if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null || (catchIdentifier = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null)) == null || Parser$_expect$LParser$ASLRegExp$($this, [ ":" ], null) == null || (catchType = Parser$_typeDeclaration$LParser$B($this, false)) == null || Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null) == null || Parser$_expect$LParser$ASLRegExp$($this, [ "{" ], null) == null) {
			return false;
		}
		caughtVariable = new CaughtVariable(catchIdentifier, catchType);
		$this._locals.push(caughtVariable);
		try {
			if (Parser$_block$LParser$($this) == null) {
				return false;
			}
		} finally {
			(_locals$0 = $this._locals).splice(_locals$0.indexOf(caughtVariable), 1);
		}
		catchStatements.push(new CatchStatement(catchOrFinallyToken, caughtVariable, (_statements$1 = $this._statements).splice(startIndex, _statements$1.length - startIndex)));
	}
	if (catchOrFinallyToken != null) {
		if (Parser$_expect$LParser$ASLRegExp$($this, [ "{" ], null) == null) {
			return false;
		}
		if (Parser$_block$LParser$($this) == null) {
			return false;
		}
		finallyStatements = (_statements$2 = $this._statements).splice(startIndex, _statements$2.length - startIndex);
	} else {
		finallyStatements = [];
	}
	$this._statements.push(new TryStatement(tryToken, tryStatements, catchStatements, finallyStatements));
	return true;
};

Parser._tryStatement$LParser$LToken$ = Parser$_tryStatement$LParser$LToken$;

function Parser$_assertStatement$LParser$LToken$($this, token) {
	var expr;
	var msgExpr;
	expr = Parser$_assignExpr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	msgExpr = null;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "," ], null) != null) {
		msgExpr = Parser$_assignExpr$LParser$B($this, false);
		if (msgExpr == null) {
			return false;
		}
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
		return false;
	}
	$this._statements.push(new AssertStatement(token, expr, msgExpr));
	return true;
};

Parser._assertStatement$LParser$LToken$ = Parser$_assertStatement$LParser$LToken$;

function Parser$_logStatement$LParser$LToken$($this, token) {
	var exprs;
	var expr;
	exprs = [];
	do {
		expr = Parser$_assignExpr$LParser$B($this, false);
		if (expr == null) {
			return false;
		}
		exprs.push(expr);
	} while (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "," ], null) != null);
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
		return false;
	}
	if (exprs.length === 0) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "no arguments"));
		return false;
	}
	$this._statements.push(new LogStatement(token, exprs));
	return true;
};

Parser._logStatement$LParser$LToken$ = Parser$_logStatement$LParser$LToken$;

function Parser$_deleteStatement$LParser$LToken$($this, token) {
	var expr;
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ ";" ], null) == null) {
		return false;
	}
	$this._statements.push(new DeleteStatement(token, expr));
	return true;
};

Parser._deleteStatement$LParser$LToken$ = Parser$_deleteStatement$LParser$LToken$;

function Parser$_debuggerStatement$LParser$LToken$($this, token) {
	$this._statements.push(new DebuggerStatement(token));
	return true;
};

Parser._debuggerStatement$LParser$LToken$ = Parser$_debuggerStatement$LParser$LToken$;

function Parser$_subStatements$LParser$($this) {
	var statementIndex;
	var _statements$0;
	statementIndex = $this._statements.length;
	if (! Parser$_statement$LParser$($this)) {
		Parser$_skipStatement$LParser$($this);
	}
	return (_statements$0 = $this._statements).splice(statementIndex, _statements$0.length - statementIndex);
};

Parser._subStatements$LParser$ = Parser$_subStatements$LParser$;

function Parser$_variableDeclarations$LParser$BAB($this, noIn, isSuccess) {
	var expr;
	var commaToken;
	var declExpr;
	isSuccess[0] = false;
	expr = null;
	commaToken = null;
	do {
		declExpr = Parser$_variableDeclaration$LParser$B($this, noIn);
		if (declExpr == null) {
			return null;
		}
		if (! (declExpr instanceof LocalExpression)) {
			expr = (expr != null ? new CommaExpression(commaToken, expr, declExpr) : declExpr);
		}
	} while ((commaToken = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "," ], null)) != null);
	isSuccess[0] = true;
	return expr;
};

Parser._variableDeclarations$LParser$BAB = Parser$_variableDeclarations$LParser$BAB;

function Parser$_variableDeclaration$LParser$B($this, noIn) {
	var identifier;
	var type;
	var local;
	var initialValue;
	var assignToken;
	var expr;
	identifier = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (identifier == null) {
		return null;
	}
	type = null;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ":" ], null)) {
		if ((type = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
			return null;
		}
	}
	local = Parser$_registerLocal$LParser$LToken$LType$($this, identifier, type);
	initialValue = null;
	if ((assignToken = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "=" ], null)) != null) {
		if ((initialValue = Parser$_assignExpr$LParser$B($this, noIn)) == null) {
			return null;
		}
	}
	expr = new LocalExpression(identifier, local);
	if (initialValue != null) {
		expr = new AssignmentExpression(assignToken, expr, initialValue);
	}
	return expr;
};

Parser._variableDeclaration$LParser$B = Parser$_variableDeclaration$LParser$B;

function Parser$_expr$LParser$($this) {
	return Parser$_expr$LParser$B($this, false);
};

Parser._expr$LParser$ = Parser$_expr$LParser$;

function Parser$_expr$LParser$B($this, noIn) {
	var expr;
	var commaToken;
	var assignExpr;
	expr = Parser$_assignExpr$LParser$B($this, noIn);
	if (expr == null) {
		return null;
	}
	while ((commaToken = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "," ], null)) != null) {
		assignExpr = Parser$_assignExpr$LParser$B($this, noIn);
		if (assignExpr == null) {
			break;
		}
		expr = new CommaExpression(commaToken, expr, assignExpr);
	}
	return expr;
};

Parser._expr$LParser$B = Parser$_expr$LParser$B;

function Parser$_assignExpr$LParser$($this) {
	return Parser$_assignExpr$LParser$B($this, false);
};

Parser._assignExpr$LParser$ = Parser$_assignExpr$LParser$;

function Parser$_assignExpr$LParser$B($this, noIn) {
	var state;
	var lhsExpr;
	var op;
	var assignExpr;
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	lhsExpr = Parser$_lhsExpr$LParser$($this);
	if (lhsExpr != null) {
		op = Parser$_expect$LParser$ASLRegExp$($this, [ "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", ">>>=", "&=", "^=", "|=" ], /^==/);
		if (op != null) {
			assignExpr = Parser$_assignExpr$LParser$B($this, noIn);
			if (assignExpr == null) {
				return null;
			}
			return new AssignmentExpression(op, lhsExpr, assignExpr);
		}
	}
	Parser$_restoreState$LParser$LParserState$($this, state);
	return Parser$_condExpr$LParser$B($this, noIn);
};

Parser._assignExpr$LParser$B = Parser$_assignExpr$LParser$B;

function Parser$_condExpr$LParser$B($this, noIn) {
	var lorExpr;
	var operatorToken;
	var ifTrueExpr;
	var ifFalseExpr;
	lorExpr = Parser$_lorExpr$LParser$B($this, noIn);
	if (lorExpr == null) {
		return null;
	}
	if ((operatorToken = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "?" ], null)) == null) {
		return lorExpr;
	}
	ifTrueExpr = null;
	ifFalseExpr = null;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ":" ], null) == null) {
		ifTrueExpr = Parser$_assignExpr$LParser$B($this, noIn);
		if (ifTrueExpr == null) {
			return null;
		}
		if (Parser$_expect$LParser$ASLRegExp$($this, [ ":" ], null) == null) {
			return null;
		}
	}
	ifFalseExpr = Parser$_assignExpr$LParser$B($this, noIn);
	return (ifFalseExpr == null ? null : new ConditionalExpression(operatorToken, lorExpr, ifTrueExpr, ifFalseExpr));
};

Parser._condExpr$LParser$B = Parser$_condExpr$LParser$B;

function Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, ops, excludePattern, parseFunc, noIn, builderFunc) {
	var expr;
	var op;
	var rightExpr;
	expr = parseFunc(noIn);
	if (expr == null) {
		return null;
	}
	while (true) {
		op = Parser$_expectOpt$LParser$ASLRegExp$($this, ops, excludePattern);
		if (op == null) {
			break;
		}
		rightExpr = parseFunc(false);
		if (rightExpr == null) {
			return null;
		}
		expr = builderFunc(op, expr, rightExpr);
	}
	return expr;
};

Parser._binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$ = Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$;

function Parser$_lorExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "||" ], null, (function (noIn) {
		return Parser$_landExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new LogicalExpression(op, e1, e2);
	}));
};

Parser._lorExpr$LParser$B = Parser$_lorExpr$LParser$B;

function Parser$_landExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "&&" ], null, (function (noIn) {
		return Parser$_borExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new LogicalExpression(op, e1, e2);
	}));
};

Parser._landExpr$LParser$B = Parser$_landExpr$LParser$B;

function Parser$_borExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "|" ], /^\|\|/, (function (noIn) {
		return Parser$_bxorExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new BinaryNumberExpression(op, e1, e2);
	}));
};

Parser._borExpr$LParser$B = Parser$_borExpr$LParser$B;

function Parser$_bxorExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "^" ], null, (function (noIn) {
		return Parser$_bandExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new BinaryNumberExpression(op, e1, e2);
	}));
};

Parser._bxorExpr$LParser$B = Parser$_bxorExpr$LParser$B;

function Parser$_bandExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "&" ], /^&&/, (function (noIn) {
		return Parser$_eqExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new BinaryNumberExpression(op, e1, e2);
	}));
};

Parser._bandExpr$LParser$B = Parser$_bandExpr$LParser$B;

function Parser$_eqExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "==", "!=" ], null, (function (noIn) {
		return Parser$_relExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new EqualityExpression(op, e1, e2);
	}));
};

Parser._eqExpr$LParser$B = Parser$_eqExpr$LParser$B;

function Parser$_relExpr$LParser$B($this, noIn) {
	var ops;
	ops = [ "<=", ">=", "<", ">" ];
	if (! noIn) {
		ops.push("in");
	}
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, ops, null, (function (noIn) {
		return Parser$_shiftExpr$LParser$($this);
	}), noIn, (function (op, e1, e2) {
		return (op._value === "in" ? new InExpression(op, e1, e2) : new BinaryNumberExpression(op, e1, e2));
	}));
};

Parser._relExpr$LParser$B = Parser$_relExpr$LParser$B;

function Parser$_shiftExpr$LParser$($this) {
	var expr;
	expr = Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ ">>>", "<<", ">>" ], null, (function (noIn) {
		return Parser$_addExpr$LParser$($this);
	}), false, (function (op, e1, e2) {
		return new ShiftExpression(op, e1, e2);
	}));
	return expr;
};

Parser._shiftExpr$LParser$ = Parser$_shiftExpr$LParser$;

function Parser$_addExpr$LParser$($this) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "+", "-" ], /^[+-]{2}/, (function (noIn) {
		return Parser$_mulExpr$LParser$($this);
	}), false, (function (op, e1, e2) {
		return (op._value === "+" ? new AdditiveExpression(op, e1, e2) : new BinaryNumberExpression(op, e1, e2));
	}));
};

Parser._addExpr$LParser$ = Parser$_addExpr$LParser$;

function Parser$_mulExpr$LParser$($this) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "*", "/", "%" ], null, (function (noIn) {
		return Parser$_unaryExpr$LParser$($this);
	}), false, (function (op, e1, e2) {
		return new BinaryNumberExpression(op, e1, e2);
	}));
};

Parser._mulExpr$LParser$ = Parser$_mulExpr$LParser$;

function Parser$_unaryExpr$LParser$($this) {
	var op;
	var expr;
	var expected$0;
	expected$0 = [ "++", "--", "+", "-", "~", "!", "typeof" ];
	op = Parser$_expectOpt$LParser$ASLRegExp$($this, expected$0, null);
	if (op == null) {
		return Parser$_asExpr$LParser$($this);
	}
	expr = Parser$_unaryExpr$LParser$($this);
	if (expr == null) {
		return null;
	}
	switch (op._value) {
	case "++":
	case "--":
		return new PreIncrementExpression(op, expr);
	case "+":
	case "-":
		return new SignExpression(op, expr);
	case "~":
		return new BitwiseNotExpression(op, expr);
	case "!":
		return new LogicalNotExpression(op, expr);
	case "typeof":
		return new TypeofExpression(op, expr);
	default:
		throw new Error("logic flaw");
	}
};

Parser._unaryExpr$LParser$ = Parser$_unaryExpr$LParser$;

function Parser$_asExpr$LParser$($this) {
	var expr;
	var token;
	var noConvert;
	var type;
	expr = Parser$_postfixExpr$LParser$($this);
	if (expr == null) {
		return null;
	}
	while ((token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "as" ], null)) != null) {
		noConvert = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "__noconvert__" ], null);
		type = Parser$_typeDeclaration$LParser$B($this, false);
		if (type == null) {
			return null;
		}
		expr = (noConvert ? new AsNoConvertExpression(token, expr, type) : new AsExpression(token, expr, type));
	}
	return expr;
};

Parser._asExpr$LParser$ = Parser$_asExpr$LParser$;

function Parser$_postfixExpr$LParser$($this) {
	var expr;
	var op;
	var type;
	var expected$0;
	expr = Parser$_lhsExpr$LParser$($this);
	expected$0 = [ "++", "--", "instanceof" ];
	op = Parser$_expectOpt$LParser$ASLRegExp$($this, expected$0, null);
	if (op == null) {
		return expr;
	}
	switch (op._value) {
	case "instanceof":
		type = Parser$_typeDeclaration$LParser$B($this, false);
		if (type == null) {
			return null;
		}
		return new InstanceofExpression(op, expr, type);
	default:
		return new PostIncrementExpression(op, expr);
	}
};

Parser._postfixExpr$LParser$ = Parser$_postfixExpr$LParser$;

function Parser$_lhsExpr$LParser$($this) {
	var state;
	var expr;
	var token;
	var args;
	var index;
	var identifier;
	var typeArgs;
	var expected$0;
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	expected$0 = [ "new", "super", "(", "function" ];
	token = Parser$_expectOpt$LParser$ASLRegExp$($this, expected$0, null);
	if (token != null) {
		switch (token._value) {
		case "super":
			return Parser$_superExpr$LParser$($this);
		case "(":
			expr = Parser$_lambdaExpr$LParser$LToken$($this, token);
			if (expr == null) {
				Parser$_restoreState$LParser$LParserState$($this, state);
				expr = Parser$_primaryExpr$LParser$($this);
				if (expr == null) {
					return null;
				}
			}
			break;
		case "function":
			expr = Parser$_functionExpr$LParser$LToken$($this, token);
			break;
		case "new":
			expr = Parser$_newExpr$LParser$LToken$($this, token);
			break;
		default:
			throw new Error("logic flaw");
		}
	} else {
		expr = Parser$_primaryExpr$LParser$($this);
	}
	if (expr == null) {
		return null;
	}
	while ((token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "(", "[", "." ], null)) != null) {
		switch (token._value) {
		case "(":
			if ((args = Parser$_argsExpr$LParser$($this)) == null) {
				return null;
			}
			expr = new CallExpression(token, expr, args);
			break;
		case "[":
			index = Parser$_expr$LParser$B($this, false);
			if (index == null) {
				return null;
			}
			if (Parser$_expect$LParser$ASLRegExp$($this, [ "]" ], null) == null) {
				return null;
			}
			expr = new ArrayExpression(token, expr, index);
			break;
		case ".":
			identifier = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, (function (self) {
				return new _CompletionCandidatesOfProperty(expr);
			}));
			if (identifier == null) {
				return null;
			}
			typeArgs = Parser$_actualTypeArguments$LParser$($this);
			if (typeArgs == null) {
				return null;
			}
			expr = new PropertyExpression(token, expr, identifier, typeArgs);
			break;
		}
	}
	return expr;
};

Parser._lhsExpr$LParser$ = Parser$_lhsExpr$LParser$;

function Parser$_newExpr$LParser$LToken$($this, newToken) {
	var type;
	var lengthExpr;
	var args;
	var arrayType$0;
	var message$0;
	type = Parser$_typeDeclarationNoArrayNoVoid$LParser$($this);
	if (type == null) {
		return null;
	}
	while (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "[" ], null) != null) {
		if (type instanceof NullableType) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "cannot instantiate an array of an Nullable type"));
			return null;
		}
		arrayType$0 = new ParsedObjectType(new QualifiedName(new Token$1("Array", true)), [ type ]);
		$this._objectTypesUsed.push(arrayType$0);
		type = arrayType$0;
		if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "]" ], null) == null) {
			lengthExpr = Parser$_assignExpr$LParser$B($this, false);
			if (lengthExpr == null) {
				return null;
			}
			if (Parser$_expect$LParser$ASLRegExp$($this, [ "]" ], null) == null) {
				return null;
			}
			return new NewExpression(newToken, type, [ lengthExpr ]);
		}
	}
	if (! (type instanceof ParsedObjectType)) {
		message$0 = "cannot instantiate a primitive type '" + type.toString() + "' using 'new'";
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$0));
		return null;
	}
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "(" ], null) != null) {
		args = Parser$_argsExpr$LParser$($this);
		if (args == null) {
			return null;
		}
	} else {
		args = [];
	}
	return new NewExpression(newToken, type, args);
};

Parser._newExpr$LParser$LToken$ = Parser$_newExpr$LParser$LToken$;

function Parser$_superExpr$LParser$($this) {
	var identifier;
	var token;
	var args;
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "." ], null) == null) {
		return null;
	}
	identifier = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (identifier == null) {
		return null;
	}
	token = Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null);
	if (token == null) {
		return null;
	}
	args = Parser$_argsExpr$LParser$($this);
	return (args == null ? null : new SuperExpression(token, identifier, args));
};

Parser._superExpr$LParser$ = Parser$_superExpr$LParser$;

function Parser$_lambdaExpr$LParser$LToken$($this, token) {
	var args;
	var returnType;
	var funcDef;
	args = Parser$_functionArgumentsExpr$LParser$BBB($this, false, false, false);
	if (args == null) {
		return null;
	}
	returnType = null;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ":" ], null) != null) {
		if ((returnType = Parser$_typeDeclaration$LParser$B($this, true)) == null) {
			return null;
		}
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "->" ], null) == null) {
		return null;
	}
	funcDef = Parser$_functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$B($this, token, null, null, args, returnType, Parser$_expectOpt$LParser$ASLRegExp$($this, [ "{" ], null) != null);
	if (funcDef == null) {
		return null;
	}
	$this._closures.push(funcDef);
	return new FunctionExpression(token, funcDef);
};

Parser._lambdaExpr$LParser$LToken$ = Parser$_lambdaExpr$LParser$LToken$;

function Parser$_functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$B($this, token, name, funcLocal, args, returnType, withBlock) {
	var flags;
	var lastToken;
	var expr;
	var funcDef;
	Parser$_expectOpt$LParser$ASLRegExp$($this, [ "{" ], null);
	Parser$_pushScope$LParser$LLocalVariable$ALArgumentDeclaration$($this, funcLocal, args);
	try {
		flags = 8;
		if (! withBlock) {
			lastToken = null;
			expr = Parser$_assignExpr$LParser$B($this, false);
			$this._statements.push(new ReturnStatement(token, expr));
		} else {
			lastToken = Parser$_block$LParser$($this);
			if (lastToken == null) {
				return null;
			}
			if ($this._isGenerator) {
				flags |= 8192;
			}
		}
		funcDef = new MemberFunctionDefinition(token, name, flags, returnType, args, $this._locals, $this._statements, $this._closures, lastToken, null);
		if (funcLocal != null) {
			funcDef._funcLocal = funcLocal;
		}
		return funcDef;
	} finally {
		Parser$_popScope$LParser$($this);
	}
};

Parser._functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$B = Parser$_functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$B;

function Parser$_functionExpr$LParser$LToken$($this, token) {
	var name;
	var args;
	var returnType;
	var type;
	var argTypes;
	var funcLocal;
	var funcDef;
	name = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "(" ], null) == null) {
		return null;
	}
	args = Parser$_functionArgumentsExpr$LParser$BBB($this, false, false, false);
	if (args == null) {
		return null;
	}
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ":" ], null) != null) {
		returnType = Parser$_typeDeclaration$LParser$B($this, true);
		if (returnType == null) {
			return null;
		}
	} else {
		returnType = null;
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "{" ], null) == null) {
		return null;
	}
	type = null;
	if (returnType != null) {
		argTypes = args.map((function (arg) {
			return arg._type;
		}));
		type = new StaticFunctionType(token, returnType, argTypes, false);
	}
	funcLocal = null;
	if (name != null) {
		funcLocal = new LocalVariable(name, type);
	}
	funcDef = Parser$_functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$B($this, token, name, funcLocal, args, returnType, true);
	if (funcDef == null) {
		return null;
	}
	$this._closures.push(funcDef);
	return new FunctionExpression(token, funcDef);
};

Parser._functionExpr$LParser$LToken$ = Parser$_functionExpr$LParser$LToken$;

function Parser$_forEachScope$LParser$F$LLocalVariable$ALLocalVariable$ALArgumentDeclaration$B$($this, cb) {
	var scope;
	var locals$0;
	if ($this._locals != null) {
		if (! cb($this._funcLocal, $this._locals, $this._arguments)) {
			return false;
		}
		for (scope = $this._prevScope; scope != null; scope = scope.prev) {
			if ((locals$0 = scope.locals) && ! cb(scope.funcLocal, locals$0, scope.arguments)) {
				return false;
			}
		}
	}
	return true;
};

Parser._forEachScope$LParser$F$LLocalVariable$ALLocalVariable$ALArgumentDeclaration$B$ = Parser$_forEachScope$LParser$F$LLocalVariable$ALLocalVariable$ALArgumentDeclaration$B$;

function Parser$_findLocal$LParser$S($this, name) {
	var found;
	found = null;
	Parser$_forEachScope$LParser$F$LLocalVariable$ALLocalVariable$ALArgumentDeclaration$B$($this, (function (funcLocal, locals, args) {
		var i;
		var locals$len$0;
		var args$len$0;
		if (funcLocal != null && funcLocal._name._value === name) {
			found = funcLocal;
			return false;
		}
		for ((i = 0, locals$len$0 = locals.length); i < locals$len$0; ++ i) {
			if (locals[i]._name._value === name) {
				found = locals[i];
				return false;
			}
		}
		if (args != null) {
			for ((i = 0, args$len$0 = args.length); i < args$len$0; ++ i) {
				if (args[i]._name._value === name) {
					found = args[i];
					return false;
				}
			}
		}
		return true;
	}));
	return found;
};

Parser._findLocal$LParser$S = Parser$_findLocal$LParser$S;

function Parser$_primaryExpr$LParser$($this) {
	var token;
	var expr;
	var local;
	var parsedType;
	if ((token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "this", "undefined", "null", "false", "true", "[", "{", "(" ], null)) != null) {
		switch (token._value) {
		case "this":
			return new ThisExpression(token, null);
		case "undefined":
			$this._errors.push(new DeprecatedWarning$0($this._filename, $this._lineNumber, $this._columnOffset, "use of 'undefined' is deprerated, use 'null' instead"));
		case "null":
			return Parser$_nullLiteral$LParser$LToken$($this, token);
		case "false":
			return new BooleanLiteralExpression(token);
		case "true":
			return new BooleanLiteralExpression(token);
		case "[":
			return Parser$_arrayLiteral$LParser$LToken$($this, token);
		case "{":
			return Parser$_mapLiteral$LParser$LToken$($this, token);
		case "(":
			expr = Parser$_expr$LParser$B($this, false);
			if (Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
				return null;
			}
			return expr;
		default:
			throw new Error("logic flaw");
		}
	} else {
		if ((token = Parser$_expectNumberLiteralOpt$LParser$($this)) != null) {
			return new NumberLiteralExpression(token);
		} else {
			if ((token = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, (function (self) {
				return new _CompletionCandidatesWithLocal(self);
			}))) != null) {
				local = Parser$_findLocal$LParser$S($this, token._value);
				if (local != null) {
					return new LocalExpression(token, local);
				} else {
					parsedType = Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, token, false, null);
					if (parsedType == null) {
						return null;
					}
					return new ClassExpression(parsedType._qualifiedName._token, parsedType);
				}
			} else {
				if ((token = Parser$_expectStringLiteralOpt$LParser$($this)) != null) {
					return new StringLiteralExpression(token);
				} else {
					if ((token = Parser$_expectRegExpLiteralOpt$LParser$($this)) != null) {
						return new RegExpLiteralExpression(token);
					} else {
						$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "expected primary expression"));
						return null;
					}
				}
			}
		}
	}
};

Parser._primaryExpr$LParser$ = Parser$_primaryExpr$LParser$;

function Parser$_nullLiteral$LParser$LToken$($this, token) {
	var type;
	var message$0;
	type = Type.nullType;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ":" ], null) != null) {
		if ((type = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
			return null;
		}
		if (type instanceof PrimitiveType) {
			message$0 = "type '" + type.toString() + "' is not nullable";
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$0));
			return null;
		}
	}
	return new NullExpression(token, type);
};

Parser._nullLiteral$LParser$LToken$ = Parser$_nullLiteral$LParser$LToken$;

function Parser$_arrayLiteral$LParser$LToken$($this, token) {
	var exprs;
	var expr;
	var type;
	var expected$0;
	exprs = [];
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "]" ], null) == null) {
		do {
			expr = Parser$_assignExpr$LParser$B($this, false);
			if (expr == null) {
				return null;
			}
			exprs.push(expr);
			expected$0 = [ ",", "]" ];
			token = Parser$_expect$LParser$ASLRegExp$($this, expected$0, null);
			if (token == null) {
				return null;
			}
		} while (token._value === ",");
	}
	type = null;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ":" ], null) != null) {
		if ((type = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
			return null;
		}
	}
	return new ArrayLiteralExpression(token, exprs, type);
};

Parser._arrayLiteral$LParser$LToken$ = Parser$_arrayLiteral$LParser$LToken$;

function Parser$_mapLiteral$LParser$LToken$($this, token) {
	var elements;
	var keyToken;
	var expr;
	var type;
	var message$0;
	elements = [];
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ "}" ], null) == null) {
		do {
			if ((keyToken = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null)) != null || (keyToken = Parser$_expectNumberLiteralOpt$LParser$($this)) != null || (keyToken = Parser$_expectStringLiteralOpt$LParser$($this)) != null) {
			} else {
				message$0 = "expected identifier, number or string but got '" + token._value + "'";
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$0));
			}
			if (Parser$_expect$LParser$ASLRegExp$($this, [ ":" ], null) == null) {
				return null;
			}
			expr = Parser$_assignExpr$LParser$B($this, false);
			if (expr == null) {
				return null;
			}
			elements.push(({_key: keyToken, _expr: expr}));
			if ((token = Parser$_expect$LParser$ASLRegExp$($this, [ ",", "}" ], null)) == null) {
				return null;
			}
		} while (token._value === ",");
	}
	type = null;
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ":" ], null) != null) {
		if ((type = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
			return null;
		}
	}
	return new MapLiteralExpression(token, elements, type);
};

Parser._mapLiteral$LParser$LToken$ = Parser$_mapLiteral$LParser$LToken$;

function Parser$_functionArgumentsExpr$LParser$BBB($this, allowVarArgs, requireTypeDeclaration, allowDefaultValues) {
	var args;
	var token;
	var isVarArg;
	var argName;
	var argType;
	var i;
	var defaultValue;
	var assignToken;
	var expected$0;
	args = [];
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
		token = null;
		do {
			isVarArg = allowVarArgs && Parser$_expectOpt$LParser$ASLRegExp$($this, [ "..." ], null) != null;
			argName = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
			if (argName == null) {
				return null;
			}
			argType = null;
			if (requireTypeDeclaration) {
				if (Parser$_expect$LParser$ASLRegExp$($this, [ ":" ], null) == null) {
					$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "type declarations are mandatory for non-expression function definition"));
					return null;
				}
				if ((argType = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
					return null;
				}
			} else {
				if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ":" ], null) != null) {
					if ((argType = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
						return null;
					}
				}
			}
			for (i = 0; i < args.length; ++ i) {
				if (args[i]._name._value === argName._value) {
					$this._errors.push(new CompileError(argName, "cannot declare an argument with the same name twice"));
					return null;
				}
			}
			if (isVarArg) {
				if (argType == null && isVarArg) {
					throw new Error("not yet implemented!");
				}
				args.push(new ArgumentDeclaration(argName, new VariableLengthArgumentType(argType)));
				if (Parser$_expect$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
					return null;
				}
				break;
			}
			defaultValue = null;
			assignToken = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "=" ], null);
			if (assignToken != null) {
				if ((defaultValue = Parser$_assignExpr$LParser$B($this, true)) == null) {
					return null;
				}
				if (! allowDefaultValues) {
					$this._errors.push(new CompileError(assignToken, "default parameters are only allowed for member functions"));
					return null;
				}
			} else {
				if (args.length !== 0 && args[args.length - 1]._defaultValue != null) {
					$this._errors.push(new CompileError(argName, "required argument cannot be declared after an optional argument"));
					return null;
				}
			}
			args.push(new ArgumentDeclaration$0(argName, argType, defaultValue));
			expected$0 = [ ")", "," ];
			token = Parser$_expect$LParser$ASLRegExp$($this, expected$0, null);
			if (token == null) {
				return null;
			}
		} while (token._value === ",");
	}
	return args;
};

Parser._functionArgumentsExpr$LParser$BBB = Parser$_functionArgumentsExpr$LParser$BBB;

function Parser$_argsExpr$LParser$($this) {
	var args;
	var token;
	var arg;
	var expected$0;
	args = [];
	if (Parser$_expectOpt$LParser$ASLRegExp$($this, [ ")" ], null) == null) {
		token = null;
		do {
			arg = Parser$_assignExpr$LParser$B($this, false);
			if (arg == null) {
				return null;
			}
			args.push(arg);
			expected$0 = [ ")", "," ];
			token = Parser$_expect$LParser$ASLRegExp$($this, expected$0, null);
			if (token == null) {
				return null;
			}
		} while (token._value === ",");
	}
	return args;
};

Parser._argsExpr$LParser$ = Parser$_argsExpr$LParser$;

function Parser$_getCompletionCandidatesOfTopLevel$LParser$F$LClassDefinition$B$($this, autoCompleteMatchCb) {
	return new CompletionCandidatesOfTopLevel($this, autoCompleteMatchCb);
};

Parser._getCompletionCandidatesOfTopLevel$LParser$F$LClassDefinition$B$ = Parser$_getCompletionCandidatesOfTopLevel$LParser$F$LClassDefinition$B$;

function Parser$_getCompletionCandidatesWithLocal$LParser$($this) {
	return new _CompletionCandidatesWithLocal($this);
};

Parser._getCompletionCandidatesWithLocal$LParser$ = Parser$_getCompletionCandidatesWithLocal$LParser$;

function Parser$_getCompletionCandidatesOfNamespace$LParser$LImport$F$LClassDefinition$B$($this, imprt, autoCompleteMatchCb) {
	return new _CompletionCandidatesOfNamespace(imprt, autoCompleteMatchCb);
};

Parser._getCompletionCandidatesOfNamespace$LParser$LImport$F$LClassDefinition$B$ = Parser$_getCompletionCandidatesOfNamespace$LParser$LImport$F$LClassDefinition$B$;

function Parser$_getCompletionCandidatesOfProperty$LParser$LExpression$($this, expr) {
	return new _CompletionCandidatesOfProperty(expr);
};

Parser._getCompletionCandidatesOfProperty$LParser$LExpression$ = Parser$_getCompletionCandidatesOfProperty$LParser$LExpression$;

function Parser$_isReservedClassName$S(name) {
	return $__jsx_ObjectHasOwnProperty.call(_Lexer.builtInClasses, name);
};

Parser._isReservedClassName$S = Parser$_isReservedClassName$S;

function TemplateDefinition() {
};

$__jsx_extend([TemplateDefinition], Object);
TemplateDefinition.prototype.$__jsx_implements_TemplateDefinition = true;

TemplateDefinition.prototype.buildInstantiationContext$ALCompileError$LToken$ALToken$ALType$ = function (errors, token, formalTypeArgs, actualTypeArgs) {
	var typemap;
	var i;
	if (formalTypeArgs.length !== actualTypeArgs.length) {
		errors.push(new CompileError(token, "wrong number of template arguments (expected " + (formalTypeArgs.length + "") + ", got " + (actualTypeArgs.length + "") + ")"));
		return null;
	}
	typemap = {};
	for (i = 0; i < formalTypeArgs.length; ++ i) {
		typemap[formalTypeArgs[i]._value] = actualTypeArgs[i];
	}
	return new InstantiationContext(errors, typemap);
};


function ClassDefinition(token, className, flags, extendType, implementTypes, members, inners, templateInners, objectTypesUsed, docComment) {
	this._stash = {};
	this._baseClassDef = null;
	this._outerClassDef = null;
	this._nativeSource = null;
	this._parser = null;
	this._token = token;
	this._className = className;
	this._flags = flags;
	this._extendType = extendType;
	this._implementTypes = implementTypes;
	this._members = members;
	this._inners = inners;
	this._templateInners = templateInners;
	this._objectTypesUsed = objectTypesUsed;
	this._docComment = docComment;
	ClassDefinition$_resetMembersClassDef$LClassDefinition$(this);
};

$__jsx_extend([ClassDefinition], Object);
$__jsx_merge_interface(ClassDefinition, Stashable);

ClassDefinition.prototype.serialize$ = function () {
	var serializeNullable$v$0;
	return ({ "token": this._token, "name": this._className, "flags": this._flags, "extends": (serializeNullable$v$0 = this._extendType, serializeNullable$v$0 == null ? null : serializeNullable$v$0._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(serializeNullable$v$0._qualifiedName._token._value, serializeNullable$v$0._typeArguments) : serializeNullable$v$0._qualifiedName._token._value), "implements": Serializer$x2E$x3CParsedObjectType$x3E$serializeArray$ALParsedObjectType$(this._implementTypes), "members": Serializer$x2E$x3CMemberDefinition$x3E$serializeArray$ALMemberDefinition$(this._members) });
};


function ClassDefinition$serialize$LClassDefinition$($this) {
	var serializeNullable$v$0;
	return ({ "token": $this._token, "name": $this._className, "flags": $this._flags, "extends": (serializeNullable$v$0 = $this._extendType, serializeNullable$v$0 == null ? null : serializeNullable$v$0._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(serializeNullable$v$0._qualifiedName._token._value, serializeNullable$v$0._typeArguments) : serializeNullable$v$0._qualifiedName._token._value), "implements": Serializer$x2E$x3CParsedObjectType$x3E$serializeArray$ALParsedObjectType$($this._implementTypes), "members": Serializer$x2E$x3CMemberDefinition$x3E$serializeArray$ALMemberDefinition$($this._members) });
};

ClassDefinition.serialize$LClassDefinition$ = ClassDefinition$serialize$LClassDefinition$;

function ClassDefinition$serialize$ALClassDefinition$(classDefs) {
	var s;
	var i;
	s = [];
	for (i = 0; i < classDefs.length; ++ i) {
		s[i] = ClassDefinition$serialize$LClassDefinition$(classDefs[i]);
	}
	return s;
};

ClassDefinition.serialize$ALClassDefinition$ = ClassDefinition$serialize$ALClassDefinition$;

ClassDefinition.prototype.getParser$ = function () {
	return this._parser;
};


function ClassDefinition$getParser$LClassDefinition$($this) {
	return $this._parser;
};

ClassDefinition.getParser$LClassDefinition$ = ClassDefinition$getParser$LClassDefinition$;

ClassDefinition.prototype.setParser$LParser$ = function (parser) {
	this._parser = parser;
};


function ClassDefinition$setParser$LClassDefinition$LParser$($this, parser) {
	$this._parser = parser;
};

ClassDefinition.setParser$LClassDefinition$LParser$ = ClassDefinition$setParser$LClassDefinition$LParser$;

ClassDefinition.prototype.getNativeSource$ = function () {
	return this._nativeSource;
};


function ClassDefinition$getNativeSource$LClassDefinition$($this) {
	return $this._nativeSource;
};

ClassDefinition.getNativeSource$LClassDefinition$ = ClassDefinition$getNativeSource$LClassDefinition$;

ClassDefinition.prototype.setNativeSource$LToken$ = function (nativeSource) {
	this._nativeSource = nativeSource;
};


function ClassDefinition$setNativeSource$LClassDefinition$LToken$($this, nativeSource) {
	$this._nativeSource = nativeSource;
};

ClassDefinition.setNativeSource$LClassDefinition$LToken$ = ClassDefinition$setNativeSource$LClassDefinition$LToken$;

ClassDefinition.prototype.getToken$ = function () {
	return this._token;
};


ClassDefinition.prototype.className$ = function () {
	return this._className;
};


ClassDefinition.prototype.classFullName$ = function () {
	var classFullName$this$0;
	return (this._outerClassDef != null ? (classFullName$this$0 = this._outerClassDef, classFullName$this$0._outerClassDef != null ? ClassDefinition$classFullName$LClassDefinition$(classFullName$this$0._outerClassDef) + "." + classFullName$this$0._className : classFullName$this$0.className$()) + "." + this._className : this.className$());
};


function ClassDefinition$classFullName$LClassDefinition$($this) {
	var classFullName$this$0;
	return ($this._outerClassDef != null ? (classFullName$this$0 = $this._outerClassDef, classFullName$this$0._outerClassDef != null ? ClassDefinition$classFullName$LClassDefinition$(classFullName$this$0._outerClassDef) + "." + classFullName$this$0._className : classFullName$this$0.className$()) + "." + $this._className : $this.className$());
};

ClassDefinition.classFullName$LClassDefinition$ = ClassDefinition$classFullName$LClassDefinition$;

ClassDefinition.prototype.flags$ = function () {
	return this._flags;
};


ClassDefinition.prototype.setFlags$N = function (flags) {
	this._flags = flags;
};


function ClassDefinition$setFlags$LClassDefinition$N($this, flags) {
	$this._flags = flags;
};

ClassDefinition.setFlags$LClassDefinition$N = ClassDefinition$setFlags$LClassDefinition$N;

ClassDefinition.prototype.extendType$ = function () {
	return this._extendType;
};


function ClassDefinition$extendType$LClassDefinition$($this) {
	return $this._extendType;
};

ClassDefinition.extendType$LClassDefinition$ = ClassDefinition$extendType$LClassDefinition$;

ClassDefinition.prototype.implementTypes$ = function () {
	return this._implementTypes;
};


function ClassDefinition$implementTypes$LClassDefinition$($this) {
	return $this._implementTypes;
};

ClassDefinition.implementTypes$LClassDefinition$ = ClassDefinition$implementTypes$LClassDefinition$;

ClassDefinition.prototype.members$ = function () {
	return this._members;
};


function ClassDefinition$members$LClassDefinition$($this) {
	return $this._members;
};

ClassDefinition.members$LClassDefinition$ = ClassDefinition$members$LClassDefinition$;

ClassDefinition.prototype.setOuterClassDef$LClassDefinition$ = function (outer) {
	this._outerClassDef = outer;
};


function ClassDefinition$setOuterClassDef$LClassDefinition$LClassDefinition$($this, outer) {
	$this._outerClassDef = outer;
};

ClassDefinition.setOuterClassDef$LClassDefinition$LClassDefinition$ = ClassDefinition$setOuterClassDef$LClassDefinition$LClassDefinition$;

ClassDefinition.prototype.getOuterClassDef$ = function () {
	return this._outerClassDef;
};


function ClassDefinition$getOuterClassDef$LClassDefinition$($this) {
	return $this._outerClassDef;
};

ClassDefinition.getOuterClassDef$LClassDefinition$ = ClassDefinition$getOuterClassDef$LClassDefinition$;

ClassDefinition.prototype.getInnerClasses$ = function () {
	return this._inners;
};


function ClassDefinition$getInnerClasses$LClassDefinition$($this) {
	return $this._inners;
};

ClassDefinition.getInnerClasses$LClassDefinition$ = ClassDefinition$getInnerClasses$LClassDefinition$;

ClassDefinition.prototype.getTemplateInnerClasses$ = function () {
	return this._templateInners;
};


function ClassDefinition$getTemplateInnerClasses$LClassDefinition$($this) {
	return $this._templateInners;
};

ClassDefinition.getTemplateInnerClasses$LClassDefinition$ = ClassDefinition$getTemplateInnerClasses$LClassDefinition$;

ClassDefinition.prototype.getDocComment$ = function () {
	return this._docComment;
};


function ClassDefinition$getDocComment$LClassDefinition$($this) {
	return $this._docComment;
};

ClassDefinition.getDocComment$LClassDefinition$ = ClassDefinition$getDocComment$LClassDefinition$;

ClassDefinition.prototype.setDocComment$LDocComment$ = function (docComment) {
	this._docComment = docComment;
};


function ClassDefinition$setDocComment$LClassDefinition$LDocComment$($this, docComment) {
	$this._docComment = docComment;
};

ClassDefinition.setDocComment$LClassDefinition$LDocComment$ = ClassDefinition$setDocComment$LClassDefinition$LDocComment$;

ClassDefinition.prototype.forEachClassToBase$F$LClassDefinition$B$ = function (cb) {
	var i;
	if (! cb(this)) {
		return false;
	}
	for (i = this._implementTypes.length - 1; i >= 0; -- i) {
		if (! cb(this._implementTypes[i]._classDef)) {
			return false;
		}
	}
	if (this._extendType != null) {
		if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(this._extendType._classDef, cb)) {
			return false;
		}
	}
	return true;
};


function ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$($this, cb) {
	var i;
	if (! cb($this)) {
		return false;
	}
	for (i = $this._implementTypes.length - 1; i >= 0; -- i) {
		if (! cb($this._implementTypes[i]._classDef)) {
			return false;
		}
	}
	if ($this._extendType != null) {
		if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$($this._extendType._classDef, cb)) {
			return false;
		}
	}
	return true;
};

ClassDefinition.forEachClassToBase$LClassDefinition$F$LClassDefinition$B$ = ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$;

ClassDefinition.prototype.forEachClassFromBase$F$LClassDefinition$B$ = function (cb) {
	var i;
	if (this._extendType != null) {
		if (! ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$(this._extendType._classDef, cb)) {
			return false;
		}
	}
	for (i = 0; i < this._implementTypes.length; ++ i) {
		if (! cb(this._implementTypes[i]._classDef)) {
			return false;
		}
	}
	return (! cb(this) ? false : true);
};


function ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$($this, cb) {
	var i;
	if ($this._extendType != null) {
		if (! ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$($this._extendType._classDef, cb)) {
			return false;
		}
	}
	for (i = 0; i < $this._implementTypes.length; ++ i) {
		if (! cb($this._implementTypes[i]._classDef)) {
			return false;
		}
	}
	return (! cb($this) ? false : true);
};

ClassDefinition.forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$ = ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$;

ClassDefinition.prototype.forEachMember$F$LMemberDefinition$B$ = function (cb) {
	var i;
	for (i = 0; i < this._members.length; ++ i) {
		if (! cb(this._members[i])) {
			return false;
		}
	}
	return true;
};


function ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$($this, cb) {
	var i;
	for (i = 0; i < $this._members.length; ++ i) {
		if (! cb($this._members[i])) {
			return false;
		}
	}
	return true;
};

ClassDefinition.forEachMember$LClassDefinition$F$LMemberDefinition$B$ = ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$;

ClassDefinition.prototype.forEachMemberVariable$F$LMemberVariableDefinition$B$ = function (cb) {
	var i;
	for (i = 0; i < this._members.length; ++ i) {
		if (this._members[i] instanceof MemberVariableDefinition) {
			if (! cb(this._members[i])) {
				return false;
			}
		}
	}
	return true;
};


function ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$($this, cb) {
	var i;
	for (i = 0; i < $this._members.length; ++ i) {
		if ($this._members[i] instanceof MemberVariableDefinition) {
			if (! cb($this._members[i])) {
				return false;
			}
		}
	}
	return true;
};

ClassDefinition.forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$ = ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$;

ClassDefinition.prototype.forEachMemberFunction$F$LMemberFunctionDefinition$B$ = function (cb) {
	var i;
	for (i = 0; i < this._members.length; ++ i) {
		if (this._members[i] instanceof MemberFunctionDefinition) {
			if (! cb(this._members[i])) {
				return false;
			}
		}
	}
	return true;
};


function ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$($this, cb) {
	var i;
	for (i = 0; i < $this._members.length; ++ i) {
		if ($this._members[i] instanceof MemberFunctionDefinition) {
			if (! cb($this._members[i])) {
				return false;
			}
		}
	}
	return true;
};

ClassDefinition.forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$ = ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$;

ClassDefinition.prototype.forEachInnerClass$F$LClassDefinition$B$ = function (cb) {
	var i;
	for (i = 0; i < this._inners.length; ++ i) {
		if (! cb(this._inners[i])) {
			return false;
		}
	}
	return true;
};


function ClassDefinition$forEachInnerClass$LClassDefinition$F$LClassDefinition$B$($this, cb) {
	var i;
	for (i = 0; i < $this._inners.length; ++ i) {
		if (! cb($this._inners[i])) {
			return false;
		}
	}
	return true;
};

ClassDefinition.forEachInnerClass$LClassDefinition$F$LClassDefinition$B$ = ClassDefinition$forEachInnerClass$LClassDefinition$F$LClassDefinition$B$;

ClassDefinition.prototype._resetMembersClassDef$ = function () {
	var $this = this;
	var i;
	var _members$0;
	var _inners$0;
	for (i = 0; i < this._members.length; ++ i) {
		(_members$0 = this._members)[i]._classDef = this;
		MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(_members$0[i], (function setClassDef(funcDef) {
			funcDef._classDef = $this;
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, setClassDef);
		}));
	}
	for (i = 0; i < this._inners.length; ++ i) {
		(_inners$0 = this._inners)[i]._outerClassDef = this;
		ClassDefinition$_resetMembersClassDef$LClassDefinition$(_inners$0[i]);
	}
	for (i = 0; i < this._templateInners.length; ++ i) {
		this._templateInners[i]._outerClassDef = this;
	}
};


function ClassDefinition$_resetMembersClassDef$LClassDefinition$($this) {
	var i;
	var _members$0;
	var _inners$0;
	for (i = 0; i < $this._members.length; ++ i) {
		(_members$0 = $this._members)[i]._classDef = $this;
		MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(_members$0[i], (function setClassDef(funcDef) {
			funcDef._classDef = $this;
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, setClassDef);
		}));
	}
	for (i = 0; i < $this._inners.length; ++ i) {
		(_inners$0 = $this._inners)[i]._outerClassDef = $this;
		ClassDefinition$_resetMembersClassDef$LClassDefinition$(_inners$0[i]);
	}
	for (i = 0; i < $this._templateInners.length; ++ i) {
		$this._templateInners[i]._outerClassDef = $this;
	}
};

ClassDefinition._resetMembersClassDef$LClassDefinition$ = ClassDefinition$_resetMembersClassDef$LClassDefinition$;

ClassDefinition.prototype.getMemberTypeByName$ALCompileError$LToken$SBALType$N = function (errors, token, name, isStatic, typeArgs, mode) {
	var $this = this;
	var types;
	var pushMatchingMember;
	types = [];
	function pushMatchingMember(classDef) {
		var i;
		var member;
		var type;
		var j;
		if (mode !== 2) {
			for (i = 0; i < classDef._members.length; ++ i) {
				member = classDef._members[i];
				if ((member._flags & 4096) !== 0) {
				} else {
					if (((member._flags & 8) !== 0) === isStatic && name === member._nameToken._value) {
						if (member instanceof MemberVariableDefinition) {
							if ((member._flags & 32) === 0) {
								type = member.getType$();
								if (type != null && types.length === 0) {
									types[0] = type;
								}
							}
						} else {
							if (member instanceof MemberFunctionDefinition) {
								if (member instanceof InstantiatedMemberFunctionDefinition) {
								} else {
									if (member instanceof TemplateFunctionDefinition) {
										if ((member = TemplateFunctionDefinition$instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$(member, errors, token, typeArgs)) == null) {
											return;
										}
									}
									if (member._statements != null || mode !== 3 || (member._flags & 18) === 16) {
										for (j = 0; j < types.length; ++ j) {
											if (Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member), types[j]._argTypes)) {
												break;
											}
										}
										if (j === types.length) {
											types.push(member.getType$());
										}
									}
								}
							} else {
								throw new Error("logic flaw");
							}
						}
					}
				}
			}
		} else {
			mode = 3;
		}
		if (mode !== 1) {
			if (classDef._extendType != null) {
				pushMatchingMember(classDef._extendType._classDef);
			}
			for (i = 0; i < classDef._implementTypes.length; ++ i) {
				pushMatchingMember(classDef._implementTypes[i]._classDef);
			}
		}
	}
	pushMatchingMember(this);
	switch (types.length) {
	case 0:
		return null;
	case 1:
		return types[0];
	default:
		return new FunctionChoiceType(types.map((function (t) {
			return t;
		})));
	}
};


function ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N($this, errors, token, name, isStatic, typeArgs, mode) {
	var types;
	var pushMatchingMember;
	types = [];
	function pushMatchingMember(classDef) {
		var i;
		var member;
		var type;
		var j;
		if (mode !== 2) {
			for (i = 0; i < classDef._members.length; ++ i) {
				member = classDef._members[i];
				if ((member._flags & 4096) !== 0) {
				} else {
					if (((member._flags & 8) !== 0) === isStatic && name === member._nameToken._value) {
						if (member instanceof MemberVariableDefinition) {
							if ((member._flags & 32) === 0) {
								type = member.getType$();
								if (type != null && types.length === 0) {
									types[0] = type;
								}
							}
						} else {
							if (member instanceof MemberFunctionDefinition) {
								if (member instanceof InstantiatedMemberFunctionDefinition) {
								} else {
									if (member instanceof TemplateFunctionDefinition) {
										if ((member = TemplateFunctionDefinition$instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$(member, errors, token, typeArgs)) == null) {
											return;
										}
									}
									if (member._statements != null || mode !== 3 || (member._flags & 18) === 16) {
										for (j = 0; j < types.length; ++ j) {
											if (Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member), types[j]._argTypes)) {
												break;
											}
										}
										if (j === types.length) {
											types.push(member.getType$());
										}
									}
								}
							} else {
								throw new Error("logic flaw");
							}
						}
					}
				}
			}
		} else {
			mode = 3;
		}
		if (mode !== 1) {
			if (classDef._extendType != null) {
				pushMatchingMember(classDef._extendType._classDef);
			}
			for (i = 0; i < classDef._implementTypes.length; ++ i) {
				pushMatchingMember(classDef._implementTypes[i]._classDef);
			}
		}
	}
	pushMatchingMember($this);
	switch (types.length) {
	case 0:
		return null;
	case 1:
		return types[0];
	default:
		return new FunctionChoiceType(types.map((function (t) {
			return t;
		})));
	}
};

ClassDefinition.getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N;

ClassDefinition.prototype.lookupInnerClass$S = function (className) {
	var i;
	var inner;
	for (i = 0; i < this._inners.length; ++ i) {
		inner = this._inners[i];
		if (inner.className$() === className) {
			return inner;
		}
	}
	return null;
};


function ClassDefinition$lookupInnerClass$LClassDefinition$S($this, className) {
	var i;
	var inner;
	for (i = 0; i < $this._inners.length; ++ i) {
		inner = $this._inners[i];
		if (inner.className$() === className) {
			return inner;
		}
	}
	return null;
};

ClassDefinition.lookupInnerClass$LClassDefinition$S = ClassDefinition$lookupInnerClass$LClassDefinition$S;

ClassDefinition.prototype.lookupTemplateInnerClass$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = function (errors, request, postInstantiationCallback) {
	var instantiateCallback;
	instantiateCallback = ClassDefinition$createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(this, errors, request, postInstantiationCallback);
	return (instantiateCallback != null ? instantiateCallback(errors, request, postInstantiationCallback) : null);
};


function ClassDefinition$lookupTemplateInnerClass$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback) {
	var instantiateCallback;
	instantiateCallback = ClassDefinition$createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback);
	return (instantiateCallback != null ? instantiateCallback(errors, request, postInstantiationCallback) : null);
};

ClassDefinition.lookupTemplateInnerClass$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = ClassDefinition$lookupTemplateInnerClass$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$;

ClassDefinition.prototype.createGetTemplateClassCallback$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = function (errors, request, postInstantiationCallback) {
	var $this = this;
	var i;
	var classDef;
	var templateDef;
	for (i = 0; i < this._inners.length; ++ i) {
		classDef = this._inners[i];
		if (classDef instanceof InstantiatedClassDefinition && classDef._templateClassDef._className === request._className && Util$typesAreEqual$ALType$ALType$(classDef._typeArguments, request._typeArgs)) {
			return (function (_, __, ___) {
				return classDef;
			});
		}
	}
	for (i = 0; i < this._templateInners.length; ++ i) {
		templateDef = this._templateInners[i];
		if (templateDef._className === request._className) {
			return (function (_, __, ___) {
				var classDef;
				var parser$0;
				var _parser$0;
				classDef = TemplateClassDefinition$instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$(templateDef, errors, request);
				if (classDef == null) {
					return null;
				}
				$this._inners.push(classDef);
				parser$0 = _parser$0 = $this._parser;
				classDef._parser = parser$0;
				ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(classDef, ({errors: errors, parser: _parser$0, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}));
				postInstantiationCallback($this._parser, classDef);
				return classDef;
			});
		}
	}
	return null;
};


function ClassDefinition$createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback) {
	var i;
	var classDef;
	var templateDef;
	for (i = 0; i < $this._inners.length; ++ i) {
		classDef = $this._inners[i];
		if (classDef instanceof InstantiatedClassDefinition && classDef._templateClassDef._className === request._className && Util$typesAreEqual$ALType$ALType$(classDef._typeArguments, request._typeArgs)) {
			return (function (_, __, ___) {
				return classDef;
			});
		}
	}
	for (i = 0; i < $this._templateInners.length; ++ i) {
		templateDef = $this._templateInners[i];
		if (templateDef._className === request._className) {
			return (function (_, __, ___) {
				var classDef;
				var parser$0;
				var _parser$0;
				classDef = TemplateClassDefinition$instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$(templateDef, errors, request);
				if (classDef == null) {
					return null;
				}
				$this._inners.push(classDef);
				parser$0 = _parser$0 = $this._parser;
				classDef._parser = parser$0;
				ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(classDef, ({errors: errors, parser: _parser$0, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}));
				postInstantiationCallback($this._parser, classDef);
				return classDef;
			});
		}
	}
	return null;
};

ClassDefinition.createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = ClassDefinition$createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$;

ClassDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var context;
	var succeeded;
	var members;
	var i;
	var member;
	var inners;
	var inner;
	var templateInners;
	var templateInner;
	var extendType;
	var type;
	var implementTypes;
	context = new InstantiationContext(instantiationContext.errors, instantiationContext.typemap);
	succeeded = true;
	members = [];
	for (i = 0; i < this._members.length; ++ i) {
		member = this._members[i].instantiate$LInstantiationContext$(context);
		if (member == null) {
			succeeded = false;
		}
		members[i] = member;
	}
	inners = [];
	for (i = 0; i < this._inners.length; ++ i) {
		inner = this._inners[i].instantiate$LInstantiationContext$(context);
		if (inner == null) {
			succeeded = false;
		}
		inners[i] = inner;
	}
	templateInners = [];
	for (i = 0; i < this._templateInners.length; ++ i) {
		templateInner = this._templateInners[i].instantiate$LInstantiationContext$(context);
		if (templateInner == null) {
			succeeded = false;
		}
		templateInners[i] = templateInner;
	}
	if (! succeeded) {
		return null;
	}
	extendType = null;
	if (this._extendType != null) {
		type = this._extendType.instantiate$LInstantiationContext$(instantiationContext);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError(this._extendType._qualifiedName._token, "non-object type is not extensible"));
			return null;
		}
		extendType = type;
	}
	implementTypes = [];
	for (i = 0; i < this._implementTypes.length; ++ i) {
		type = this._implementTypes[i].instantiate$LInstantiationContext$(instantiationContext);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError(this._implementTypes[i]._qualifiedName._token, "non-object type is not extensible"));
			return null;
		}
		implementTypes[i] = type;
	}
	return new ClassDefinition(this._token, this._className, this._flags, extendType, implementTypes, members, inners, templateInners, context.objectTypesUsed, this._docComment);
};


ClassDefinition.prototype.normalizeClassDefs$ALCompileError$ = function (errors) {
	var $this = this;
	var x;
	var y;
	var errorMsg;
	var error;
	var note$0;
	var _members$0;
	var _members$1;
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(this, (function (funcDef) {
		MemberFunctionDefinition$generateWrappersForDefaultParameters$LMemberFunctionDefinition$ALCompileError$(funcDef, errors);
		return true;
	}));
	for (x = 0; x < this._members.length; ++ x) {
		for (y = 0; y < x; ++ y) {
			if ((_members$1 = this._members)[x]._nameToken._value === _members$1[y]._nameToken._value && (_members$1[x]._flags & 8) === (_members$1[y]._flags & 8)) {
				errorMsg = null;
				if ((_members$0 = this._members)[x] instanceof MemberFunctionDefinition && _members$0[y] instanceof MemberFunctionDefinition) {
					if (Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._members[x]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._members[y]))) {
						errorMsg = "a " + ((this._members[x]._flags & 8) !== 0 ? "static" : "member") + " function with same name and arguments is already defined";
						errorMsg += ":" + (x + "") + ":" + (MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._members[x]).length + "");
						errorMsg += ":" + (y + "") + ":" + (MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._members[y]).length + "");
					}
				} else {
					errorMsg = "a property with same name already exists (note: only functions may be overloaded)";
				}
				if (errorMsg != null) {
					error = new CompileError(this._members[x]._nameToken, errorMsg);
					note$0 = new CompileNote(this._members[y]._nameToken, "conflicting definition found here");
					error._notes.push(note$0);
					errors.push(error);
					break;
				}
			}
		}
	}
};


function ClassDefinition$normalizeClassDefs$LClassDefinition$ALCompileError$($this, errors) {
	var x;
	var y;
	var errorMsg;
	var error;
	var note$0;
	var _members$0;
	var _members$1;
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$($this, (function (funcDef) {
		MemberFunctionDefinition$generateWrappersForDefaultParameters$LMemberFunctionDefinition$ALCompileError$(funcDef, errors);
		return true;
	}));
	for (x = 0; x < $this._members.length; ++ x) {
		for (y = 0; y < x; ++ y) {
			if ((_members$1 = $this._members)[x]._nameToken._value === _members$1[y]._nameToken._value && (_members$1[x]._flags & 8) === (_members$1[y]._flags & 8)) {
				errorMsg = null;
				if ((_members$0 = $this._members)[x] instanceof MemberFunctionDefinition && _members$0[y] instanceof MemberFunctionDefinition) {
					if (Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._members[x]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._members[y]))) {
						errorMsg = "a " + (($this._members[x]._flags & 8) !== 0 ? "static" : "member") + " function with same name and arguments is already defined";
						errorMsg += ":" + (x + "") + ":" + (MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._members[x]).length + "");
						errorMsg += ":" + (y + "") + ":" + (MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._members[y]).length + "");
					}
				} else {
					errorMsg = "a property with same name already exists (note: only functions may be overloaded)";
				}
				if (errorMsg != null) {
					error = new CompileError($this._members[x]._nameToken, errorMsg);
					note$0 = new CompileNote($this._members[y]._nameToken, "conflicting definition found here");
					error._notes.push(note$0);
					errors.push(error);
					break;
				}
			}
		}
	}
};

ClassDefinition.normalizeClassDefs$LClassDefinition$ALCompileError$ = ClassDefinition$normalizeClassDefs$LClassDefinition$ALCompileError$;

ClassDefinition.prototype.resolveTypes$LAnalysisContext$ = function (context) {
	var $this = this;
	var i;
	var baseClass;
	var j;
	var isNative;
	var func;
	for (i = 0; i < this._objectTypesUsed.length; ++ i) {
		this._objectTypesUsed[i].resolveType$LAnalysisContext$(context);
	}
	for (i = 0; i < this._inners.length; ++ i) {
		ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(this._inners[i], context);
	}
	if (this._extendType != null) {
		baseClass = this._extendType._classDef;
		if (baseClass != null) {
			if ((baseClass.flags$() & 4) !== 0) {
				context.errors.push(new CompileError(this._extendType._qualifiedName._token, "cannot extend a final class"));
			} else {
				if ((baseClass.flags$() & 64) !== 0) {
					context.errors.push(new CompileError(this._extendType._qualifiedName._token, "cannot extend an interface, use the 'implements' keyword"));
				} else {
					if ((baseClass.flags$() & 128) !== 0) {
						context.errors.push(new CompileError(this._extendType._qualifiedName._token, "cannot extend an mixin, use the 'implements' keyword"));
					}
				}
			}
		}
	}
	for (i = 0; i < this._implementTypes.length; ++ i) {
		baseClass = this._implementTypes[i]._classDef;
		if (baseClass != null) {
			if ((baseClass.flags$() & 192) === 0) {
				context.errors.push(new CompileError(this._implementTypes[i]._qualifiedName._token, "cannot implement a class (only interfaces can be implemented)"));
			} else {
				for (j = i + 1; j < this._implementTypes.length; ++ j) {
					if (this._implementTypes[j]._classDef == baseClass) {
						context.errors.push(new CompileError(this._implementTypes[i]._qualifiedName._token, "cannot implement the same interface more than once"));
						break;
					}
				}
			}
		}
	}
	if (ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(this, (function (funcDef) {
		return funcDef._nameToken._value !== "constructor";
	}))) {
		isNative = (this.flags$() & 16) !== 0;
		func = new MemberFunctionDefinition(this._token, new Token$1("constructor", true), 4 | this.flags$() & 16400, Type.voidType, [], isNative ? null : [], isNative ? null : [], [], this._token, null);
		func._classDef = this;
		this._members.push(func);
	}
};


function ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$($this, context) {
	var i;
	var baseClass;
	var j;
	var isNative;
	var func;
	for (i = 0; i < $this._objectTypesUsed.length; ++ i) {
		$this._objectTypesUsed[i].resolveType$LAnalysisContext$(context);
	}
	for (i = 0; i < $this._inners.length; ++ i) {
		ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$($this._inners[i], context);
	}
	if ($this._extendType != null) {
		baseClass = $this._extendType._classDef;
		if (baseClass != null) {
			if ((baseClass.flags$() & 4) !== 0) {
				context.errors.push(new CompileError($this._extendType._qualifiedName._token, "cannot extend a final class"));
			} else {
				if ((baseClass.flags$() & 64) !== 0) {
					context.errors.push(new CompileError($this._extendType._qualifiedName._token, "cannot extend an interface, use the 'implements' keyword"));
				} else {
					if ((baseClass.flags$() & 128) !== 0) {
						context.errors.push(new CompileError($this._extendType._qualifiedName._token, "cannot extend an mixin, use the 'implements' keyword"));
					}
				}
			}
		}
	}
	for (i = 0; i < $this._implementTypes.length; ++ i) {
		baseClass = $this._implementTypes[i]._classDef;
		if (baseClass != null) {
			if ((baseClass.flags$() & 192) === 0) {
				context.errors.push(new CompileError($this._implementTypes[i]._qualifiedName._token, "cannot implement a class (only interfaces can be implemented)"));
			} else {
				for (j = i + 1; j < $this._implementTypes.length; ++ j) {
					if ($this._implementTypes[j]._classDef == baseClass) {
						context.errors.push(new CompileError($this._implementTypes[i]._qualifiedName._token, "cannot implement the same interface more than once"));
						break;
					}
				}
			}
		}
	}
	if (ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$($this, (function (funcDef) {
		return funcDef._nameToken._value !== "constructor";
	}))) {
		isNative = ($this.flags$() & 16) !== 0;
		func = new MemberFunctionDefinition($this._token, new Token$1("constructor", true), 4 | $this.flags$() & 16400, Type.voidType, [], isNative ? null : [], isNative ? null : [], [], $this._token, null);
		func._classDef = $this;
		$this._members.push(func);
	}
};

ClassDefinition.resolveTypes$LClassDefinition$LAnalysisContext$ = ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$;

ClassDefinition.prototype.setAnalysisContextOfVariables$LAnalysisContext$ = function (context) {
	var i;
	var member;
	var this$0$0$0;
	var funcDef$0$0$0;
	for (i = 0; i < this._members.length; ++ i) {
		member = this._members[i];
		if (member instanceof MemberVariableDefinition) {
			this$0$0$0 = ({errors: context.errors, parser: context.parser, postInstantiationCallback: context.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
			funcDef$0$0$0 = context.funcDef;
			this$0$0$0.funcDef = funcDef$0$0$0;
			member._analysisContext = this$0$0$0;
		}
	}
};


function ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$($this, context) {
	var i;
	var member;
	var this$0$0$0;
	var funcDef$0$0$0;
	for (i = 0; i < $this._members.length; ++ i) {
		member = $this._members[i];
		if (member instanceof MemberVariableDefinition) {
			this$0$0$0 = ({errors: context.errors, parser: context.parser, postInstantiationCallback: context.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
			funcDef$0$0$0 = context.funcDef;
			this$0$0$0.funcDef = funcDef$0$0$0;
			member._analysisContext = this$0$0$0;
		}
	}
};

ClassDefinition.setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$ = ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$;

ClassDefinition.prototype.analyze$LAnalysisContext$ = function (context) {
	var token;
	var srcPos;
	try {
		ClassDefinition$_analyzeClassDef$LClassDefinition$LAnalysisContext$(this, context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			token = this.getToken$();
			srcPos = (token != null ? Util$format$SAS(" at file %1, line %2", [ token._filename, token._lineNumber + "" ]) : "");
			$__jsx_catch_0.message = Util$format$SAS("fatal error while analyzing class %1%2\n%3", [ ClassDefinition$classFullName$LClassDefinition$(this), srcPos, $__jsx_catch_0.message ]);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	ClassDefinition$_analyzeMembers$LClassDefinition$LAnalysisContext$(this, context);
};


function ClassDefinition$analyze$LClassDefinition$LAnalysisContext$($this, context) {
	var token;
	var srcPos;
	try {
		ClassDefinition$_analyzeClassDef$LClassDefinition$LAnalysisContext$($this, context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			token = $this.getToken$();
			srcPos = (token != null ? Util$format$SAS(" at file %1, line %2", [ token._filename, token._lineNumber + "" ]) : "");
			$__jsx_catch_0.message = Util$format$SAS("fatal error while analyzing class %1%2\n%3", [ ClassDefinition$classFullName$LClassDefinition$($this), srcPos, $__jsx_catch_0.message ]);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	ClassDefinition$_analyzeMembers$LClassDefinition$LAnalysisContext$($this, context);
};

ClassDefinition.analyze$LClassDefinition$LAnalysisContext$ = ClassDefinition$analyze$LClassDefinition$LAnalysisContext$;

ClassDefinition.prototype._analyzeClassDef$LAnalysisContext$ = function (context) {
	var $this = this;
	var implementClassDefs;
	var i;
	var allMixins;
	var interfaceDef;
	var j;
	var theMixin;
	var overrideFunctions;
	var done;
	var k;
	var abstractMembers;
	var msg;
	var usedNames;
	var _members$0;
	var _members$1;
	var abstractMembers$len$0;
	this._baseClassDef = (this._extendType != null ? this._extendType._classDef : null);
	implementClassDefs = this._implementTypes.map((function (type) {
		return type._classDef;
	}));
	if ((this.flags$() & 192) === 0) {
		if (this._baseClassDef != null) {
			if ((this._baseClassDef.flags$() & 4) !== 0) {
				context.errors.push(new CompileError(this.getToken$(), "cannot extend final class '" + ClassDefinition$classFullName$LClassDefinition$(this._baseClassDef) + "'"));
				return;
			}
			if ((this._baseClassDef.flags$() & 192) !== 0) {
				context.errors.push(new CompileError(this.getToken$(), "interfaces (or mixins) should be implemented, not extended"));
				return;
			}
			if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(this._baseClassDef, (function (classDef) {
				if ($this == classDef) {
					context.errors.push(new CompileError($this.getToken$(), "class inheritance is in loop"));
					return false;
				}
				return true;
			}))) {
				return;
			}
		}
	} else {
		for (i = 0; i < implementClassDefs.length; ++ i) {
			if ((implementClassDefs[i].flags$() & 192) === 0) {
				context.errors.push(new CompileError(this.getToken$(), "class '" + ClassDefinition$classFullName$LClassDefinition$(implementClassDefs[i]) + "' can only be extended, not implemented"));
				return;
			}
			if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(implementClassDefs[i], (function (classDef) {
				if ($this == classDef) {
					context.errors.push(new CompileError($this.getToken$(), "class inheritance is in loop"));
					return false;
				}
				return true;
			}))) {
				return;
			}
		}
	}
	allMixins = [];
	if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(this, (function (classDef) {
		if ((classDef.flags$() & 128) !== 0) {
			if (allMixins.indexOf(classDef) !== -1) {
				context.errors.push(new CompileError($this.getToken$(), "mixin '" + ClassDefinition$classFullName$LClassDefinition$(classDef) + "' is implemented twice"));
				return false;
			}
			allMixins.push(classDef);
		}
		return true;
	}))) {
		return;
	}
	for (i = 0; i < this._members.length; ++ i) {
		ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$(this, context, (_members$0 = this._members)[i], this, _members$0[i]._token);
	}
	for (i = 0; i < this._implementTypes.length; ++ i) {
		interfaceDef = this._implementTypes[i]._classDef;
		for (j = 0; j < interfaceDef._members.length; ++ j) {
			ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$(this, context, interfaceDef._members[j], interfaceDef, this._implementTypes[i]._qualifiedName._token);
		}
	}
	if ((this._flags & 192) === 0) {
		for (i = 0; i < this._members.length; ++ i) {
			if ((_members$1 = this._members)[i] instanceof MemberFunctionDefinition && (_members$1[i]._flags & 32) !== 0) {
				if (ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$(this, context, this._members[i]) == null) {
					context.errors.push(new CompileError(this._members[i]._nameToken, "could not find function definition in base classes / mixins to be overridden"));
				}
			}
		}
		for (i = 0; i < this._implementTypes.length; ++ i) {
			if ((this._implementTypes[i]._classDef.flags$() & 128) === 0) {
				continue;
			}
			theMixin = this._implementTypes[i]._classDef;
			overrideFunctions = [];
			ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$BNN(theMixin, overrideFunctions, true, 32, 32);
			for (j = 0; j < overrideFunctions.length; ++ j) {
				done = false;
				if (this._baseClassDef != null) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$(this._baseClassDef, context, overrideFunctions[j]) != null) {
						done = true;
					}
				}
				for (k = 0; k < i; ++ k) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$(this._implementTypes[k]._classDef, context, overrideFunctions[j]) != null) {
						done = true;
						break;
					}
				}
				for (k = 0; k < theMixin._implementTypes.length; ++ k) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$(theMixin._implementTypes[k]._classDef, context, overrideFunctions[j]) != null) {
						done = true;
						break;
					}
				}
				if (! done) {
					context.errors.push(new CompileError(this.getToken$(), "could not find function definition to be overridden by '" + overrideFunctions[j].getNotation$() + "'"));
				}
			}
		}
	}
	if ((this._flags & 194) === 0) {
		abstractMembers = [];
		ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(this, (function (classDef) {
			return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				var i;
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_ABSTRACT) !== 0) {
					for (i = 0; i < abstractMembers.length; ++ i) {
						if (ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$(abstractMembers[i], member)) {
							break;
						}
					}
					if (i === abstractMembers.length) {
						abstractMembers[i] = member;
					}
				}
				return true;
			}));
		}));
		ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(this, (function (classDef) {
			return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				var i;
				if (abstractMembers.length === 0) {
					return false;
				}
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_ABSTRACT) === 0) {
					for (i = 0; i < abstractMembers.length; ++ i) {
						if (ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$(abstractMembers[i], member)) {
							abstractMembers.splice(i, 1);
							break;
						}
					}
				}
				return true;
			}));
		}));
		if (abstractMembers.length !== 0) {
			msg = "class should be declared as 'abstract' since the following members do not have concrete definition: ";
			for ((i = 0, abstractMembers$len$0 = abstractMembers.length); i < abstractMembers$len$0; ++ i) {
				if (i !== 0) {
					msg += ", ";
				}
				msg += abstractMembers[i].getNotation$();
			}
			context.errors.push(new CompileError(this.getToken$(), msg));
		}
	}
	usedNames = {};
	ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$(this, [  ], (function (member) {
		var existingDef;
		var errMsg;
		if (! (member instanceof MemberFunctionDefinition)) {
			return false;
		}
		if ((member._flags & 16392) !== 16384) {
			return false;
		}
		if (! $__jsx_ObjectHasOwnProperty.call(usedNames, member._nameToken._value)) {
			usedNames[member._nameToken._value] = member;
			return false;
		}
		existingDef = usedNames[member._nameToken._value];
		if (existingDef.getType$().equals$LType$(member.getType$())) {
			return false;
		}
		if (($this._flags & 16384) !== 0 && member._nameToken._value === "constructor") {
			errMsg = "only one constructor is exportable, please mark others using the __noexport__ attribute";
		} else {
			errMsg = "methods with __export__ attribute cannot be overloaded";
		}
		context.errors.push(CompileError$addCompileNote$LCompileError$LCompileNote$(new CompileError(member._token, errMsg), new CompileNote(usedNames[member._nameToken._value]._token, "previously defined here")));
		return false;
	}));
};


function ClassDefinition$_analyzeClassDef$LClassDefinition$LAnalysisContext$($this, context) {
	var implementClassDefs;
	var i;
	var allMixins;
	var interfaceDef;
	var j;
	var theMixin;
	var overrideFunctions;
	var done;
	var k;
	var abstractMembers;
	var msg;
	var usedNames;
	var _members$0;
	var _members$1;
	var abstractMembers$len$0;
	$this._baseClassDef = ($this._extendType != null ? $this._extendType._classDef : null);
	implementClassDefs = $this._implementTypes.map((function (type) {
		return type._classDef;
	}));
	if (($this.flags$() & 192) === 0) {
		if ($this._baseClassDef != null) {
			if (($this._baseClassDef.flags$() & 4) !== 0) {
				context.errors.push(new CompileError($this.getToken$(), "cannot extend final class '" + ClassDefinition$classFullName$LClassDefinition$($this._baseClassDef) + "'"));
				return;
			}
			if (($this._baseClassDef.flags$() & 192) !== 0) {
				context.errors.push(new CompileError($this.getToken$(), "interfaces (or mixins) should be implemented, not extended"));
				return;
			}
			if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$($this._baseClassDef, (function (classDef) {
				if ($this == classDef) {
					context.errors.push(new CompileError($this.getToken$(), "class inheritance is in loop"));
					return false;
				}
				return true;
			}))) {
				return;
			}
		}
	} else {
		for (i = 0; i < implementClassDefs.length; ++ i) {
			if ((implementClassDefs[i].flags$() & 192) === 0) {
				context.errors.push(new CompileError($this.getToken$(), "class '" + ClassDefinition$classFullName$LClassDefinition$(implementClassDefs[i]) + "' can only be extended, not implemented"));
				return;
			}
			if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(implementClassDefs[i], (function (classDef) {
				if ($this == classDef) {
					context.errors.push(new CompileError($this.getToken$(), "class inheritance is in loop"));
					return false;
				}
				return true;
			}))) {
				return;
			}
		}
	}
	allMixins = [];
	if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$($this, (function (classDef) {
		if ((classDef.flags$() & 128) !== 0) {
			if (allMixins.indexOf(classDef) !== -1) {
				context.errors.push(new CompileError($this.getToken$(), "mixin '" + ClassDefinition$classFullName$LClassDefinition$(classDef) + "' is implemented twice"));
				return false;
			}
			allMixins.push(classDef);
		}
		return true;
	}))) {
		return;
	}
	for (i = 0; i < $this._members.length; ++ i) {
		ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$($this, context, (_members$0 = $this._members)[i], $this, _members$0[i]._token);
	}
	for (i = 0; i < $this._implementTypes.length; ++ i) {
		interfaceDef = $this._implementTypes[i]._classDef;
		for (j = 0; j < interfaceDef._members.length; ++ j) {
			ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$($this, context, interfaceDef._members[j], interfaceDef, $this._implementTypes[i]._qualifiedName._token);
		}
	}
	if (($this._flags & 192) === 0) {
		for (i = 0; i < $this._members.length; ++ i) {
			if ((_members$1 = $this._members)[i] instanceof MemberFunctionDefinition && (_members$1[i]._flags & 32) !== 0) {
				if (ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this, context, $this._members[i]) == null) {
					context.errors.push(new CompileError($this._members[i]._nameToken, "could not find function definition in base classes / mixins to be overridden"));
				}
			}
		}
		for (i = 0; i < $this._implementTypes.length; ++ i) {
			if (($this._implementTypes[i]._classDef.flags$() & 128) === 0) {
				continue;
			}
			theMixin = $this._implementTypes[i]._classDef;
			overrideFunctions = [];
			ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$BNN(theMixin, overrideFunctions, true, 32, 32);
			for (j = 0; j < overrideFunctions.length; ++ j) {
				done = false;
				if ($this._baseClassDef != null) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this._baseClassDef, context, overrideFunctions[j]) != null) {
						done = true;
					}
				}
				for (k = 0; k < i; ++ k) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this._implementTypes[k]._classDef, context, overrideFunctions[j]) != null) {
						done = true;
						break;
					}
				}
				for (k = 0; k < theMixin._implementTypes.length; ++ k) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$(theMixin._implementTypes[k]._classDef, context, overrideFunctions[j]) != null) {
						done = true;
						break;
					}
				}
				if (! done) {
					context.errors.push(new CompileError($this.getToken$(), "could not find function definition to be overridden by '" + overrideFunctions[j].getNotation$() + "'"));
				}
			}
		}
	}
	if (($this._flags & 194) === 0) {
		abstractMembers = [];
		ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$($this, (function (classDef) {
			return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				var i;
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_ABSTRACT) !== 0) {
					for (i = 0; i < abstractMembers.length; ++ i) {
						if (ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$(abstractMembers[i], member)) {
							break;
						}
					}
					if (i === abstractMembers.length) {
						abstractMembers[i] = member;
					}
				}
				return true;
			}));
		}));
		ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$($this, (function (classDef) {
			return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				var i;
				if (abstractMembers.length === 0) {
					return false;
				}
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_ABSTRACT) === 0) {
					for (i = 0; i < abstractMembers.length; ++ i) {
						if (ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$(abstractMembers[i], member)) {
							abstractMembers.splice(i, 1);
							break;
						}
					}
				}
				return true;
			}));
		}));
		if (abstractMembers.length !== 0) {
			msg = "class should be declared as 'abstract' since the following members do not have concrete definition: ";
			for ((i = 0, abstractMembers$len$0 = abstractMembers.length); i < abstractMembers$len$0; ++ i) {
				if (i !== 0) {
					msg += ", ";
				}
				msg += abstractMembers[i].getNotation$();
			}
			context.errors.push(new CompileError($this.getToken$(), msg));
		}
	}
	usedNames = {};
	ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$($this, [  ], (function (member) {
		var existingDef;
		var errMsg;
		if (! (member instanceof MemberFunctionDefinition)) {
			return false;
		}
		if ((member._flags & 16392) !== 16384) {
			return false;
		}
		if (! $__jsx_ObjectHasOwnProperty.call(usedNames, member._nameToken._value)) {
			usedNames[member._nameToken._value] = member;
			return false;
		}
		existingDef = usedNames[member._nameToken._value];
		if (existingDef.getType$().equals$LType$(member.getType$())) {
			return false;
		}
		if (($this._flags & 16384) !== 0 && member._nameToken._value === "constructor") {
			errMsg = "only one constructor is exportable, please mark others using the __noexport__ attribute";
		} else {
			errMsg = "methods with __export__ attribute cannot be overloaded";
		}
		context.errors.push(CompileError$addCompileNote$LCompileError$LCompileNote$(new CompileError(member._token, errMsg), new CompileNote(usedNames[member._nameToken._value]._token, "previously defined here")));
		return false;
	}));
};

ClassDefinition._analyzeClassDef$LClassDefinition$LAnalysisContext$ = ClassDefinition$_analyzeClassDef$LClassDefinition$LAnalysisContext$;

ClassDefinition.prototype._analyzeMembers$LAnalysisContext$ = function (context) {
	var i;
	var member;
	var varDef;
	var initialValue$0;
	for (i = 0; i < this._members.length; ++ i) {
		member = this._members[i];
		if (member instanceof MemberFunctionDefinition) {
			if (! (member instanceof TemplateFunctionDefinition)) {
				MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(member, context);
			}
		} else {
			varDef = member;
			if (varDef._initialValue == null && (this.flags$() & 16) !== 16) {
				initialValue$0 = Expression$getDefaultValueExpressionOf$LType$(varDef.getType$());
				varDef._initialValue = initialValue$0;
			}
		}
	}
};


function ClassDefinition$_analyzeMembers$LClassDefinition$LAnalysisContext$($this, context) {
	var i;
	var member;
	var varDef;
	var initialValue$0;
	for (i = 0; i < $this._members.length; ++ i) {
		member = $this._members[i];
		if (member instanceof MemberFunctionDefinition) {
			if (! (member instanceof TemplateFunctionDefinition)) {
				MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(member, context);
			}
		} else {
			varDef = member;
			if (varDef._initialValue == null && ($this.flags$() & 16) !== 16) {
				initialValue$0 = Expression$getDefaultValueExpressionOf$LType$(varDef.getType$());
				varDef._initialValue = initialValue$0;
			}
		}
	}
};

ClassDefinition._analyzeMembers$LClassDefinition$LAnalysisContext$ = ClassDefinition$_analyzeMembers$LClassDefinition$LAnalysisContext$;

ClassDefinition.prototype.analyzeUnusedVariables$ = function () {
	var i;
	var member;
	for (i = 0; i < this._members.length; ++ i) {
		member = this._members[i];
		if (member instanceof MemberVariableDefinition) {
			member.getType$();
		}
	}
};


function ClassDefinition$analyzeUnusedVariables$LClassDefinition$($this) {
	var i;
	var member;
	for (i = 0; i < $this._members.length; ++ i) {
		member = $this._members[i];
		if (member instanceof MemberVariableDefinition) {
			member.getType$();
		}
	}
};

ClassDefinition.analyzeUnusedVariables$LClassDefinition$ = ClassDefinition$analyzeUnusedVariables$LClassDefinition$;

ClassDefinition.prototype.isConvertibleTo$LClassDefinition$ = function (classDef) {
	var i;
	var _extendType$0;
	if (this == classDef) {
		return true;
	}
	if (classDef.className$() === "Object") {
		return true;
	}
	if ((_extendType$0 = this._extendType) != null && ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$(_extendType$0._classDef, classDef)) {
		return true;
	}
	for (i = 0; i < this._implementTypes.length; ++ i) {
		if (ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$(this._implementTypes[i]._classDef, classDef)) {
			return true;
		}
	}
	return false;
};


function ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$($this, classDef) {
	var i;
	var _extendType$0;
	if ($this == classDef) {
		return true;
	}
	if (classDef.className$() === "Object") {
		return true;
	}
	if ((_extendType$0 = $this._extendType) != null && ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$(_extendType$0._classDef, classDef)) {
		return true;
	}
	for (i = 0; i < $this._implementTypes.length; ++ i) {
		if (ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$($this._implementTypes[i]._classDef, classDef)) {
			return true;
		}
	}
	return false;
};

ClassDefinition.isConvertibleTo$LClassDefinition$LClassDefinition$ = ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$;

ClassDefinition.prototype._assertMemberIsDefinable$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$ = function (context, member, memberClassDef, token) {
	var numImplementsToCheck;
	var isCheckingSibling;
	var i;
	var isCheckingInterface;
	var _extendType$0;
	var _extendType$1;
	var _implementTypes$0;
	if ((member._flags & 8) !== 0) {
		return true;
	}
	for (numImplementsToCheck = 0; numImplementsToCheck < this._implementTypes.length; ++ numImplementsToCheck) {
		if (memberClassDef == this._implementTypes[numImplementsToCheck]._classDef) {
			break;
		}
	}
	isCheckingSibling = numImplementsToCheck !== this._implementTypes.length;
	if (member instanceof MemberVariableDefinition) {
		if ((_extendType$0 = this._extendType) != null && ! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$(_extendType$0._classDef, context, member, memberClassDef, token)) {
			return false;
		}
		for (i = 0; i < numImplementsToCheck; ++ i) {
			if (! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$(this._implementTypes[i]._classDef, context, member, memberClassDef, token)) {
				return false;
			}
		}
	} else {
		isCheckingInterface = (memberClassDef.flags$() & 64) !== 0;
		if ((_extendType$1 = this._extendType) != null && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB(_extendType$1._classDef, context, member, memberClassDef, token, false, isCheckingInterface)) {
			return false;
		}
		for (i = 0; i < numImplementsToCheck; ++ i) {
			if (memberClassDef != (_implementTypes$0 = this._implementTypes)[i]._classDef && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB(_implementTypes$0[i]._classDef, context, member, memberClassDef, token, isCheckingSibling, isCheckingInterface)) {
				return false;
			}
		}
	}
	return true;
};


function ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$($this, context, member, memberClassDef, token) {
	var numImplementsToCheck;
	var isCheckingSibling;
	var i;
	var isCheckingInterface;
	var _extendType$0;
	var _extendType$1;
	var _implementTypes$0;
	if ((member._flags & 8) !== 0) {
		return true;
	}
	for (numImplementsToCheck = 0; numImplementsToCheck < $this._implementTypes.length; ++ numImplementsToCheck) {
		if (memberClassDef == $this._implementTypes[numImplementsToCheck]._classDef) {
			break;
		}
	}
	isCheckingSibling = numImplementsToCheck !== $this._implementTypes.length;
	if (member instanceof MemberVariableDefinition) {
		if ((_extendType$0 = $this._extendType) != null && ! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$(_extendType$0._classDef, context, member, memberClassDef, token)) {
			return false;
		}
		for (i = 0; i < numImplementsToCheck; ++ i) {
			if (! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$($this._implementTypes[i]._classDef, context, member, memberClassDef, token)) {
				return false;
			}
		}
	} else {
		isCheckingInterface = (memberClassDef.flags$() & 64) !== 0;
		if ((_extendType$1 = $this._extendType) != null && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB(_extendType$1._classDef, context, member, memberClassDef, token, false, isCheckingInterface)) {
			return false;
		}
		for (i = 0; i < numImplementsToCheck; ++ i) {
			if (memberClassDef != (_implementTypes$0 = $this._implementTypes)[i]._classDef && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB(_implementTypes$0[i]._classDef, context, member, memberClassDef, token, isCheckingSibling, isCheckingInterface)) {
				return false;
			}
		}
	}
	return true;
};

ClassDefinition._assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$ = ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$;

ClassDefinition.prototype._assertMemberVariableIsDefinable$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$ = function (context, member, memberClassDef, token) {
	var i;
	var _extendType$0;
	for (i = 0; i < this._members.length; ++ i) {
		if (this._members[i]._nameToken._value === member._nameToken._value) {
			if ((this._members[i]._flags & 2) === 0) {
				context.errors.push(new CompileError(member._nameToken, Util$format$SAS("cannot define property '%1', the name is already used in class '%2'", [ member.getNotation$(), ClassDefinition$classFullName$LClassDefinition$(this) ])));
				return false;
			}
			if (! this._members[i].getType$().equals$LType$(member.getType$())) {
				context.errors.push(new CompileError(member._nameToken, Util$format$SAS("cannot override property '%1' of type '%2' with different type '%3'", [ member.getNotation$(), this._members[i].getType$().toString(), member.getType$().toString() ])));
				return false;
			}
		}
	}
	if ((_extendType$0 = this._extendType) != null && ! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$(_extendType$0._classDef, context, member, memberClassDef, token)) {
		return false;
	}
	for (i = 0; i < this._implementTypes.length; ++ i) {
		if (! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$(this._implementTypes[i]._classDef, context, member, memberClassDef, token)) {
			return false;
		}
	}
	return true;
};


function ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$($this, context, member, memberClassDef, token) {
	var i;
	var _extendType$0;
	for (i = 0; i < $this._members.length; ++ i) {
		if ($this._members[i]._nameToken._value === member._nameToken._value) {
			if (($this._members[i]._flags & 2) === 0) {
				context.errors.push(new CompileError(member._nameToken, Util$format$SAS("cannot define property '%1', the name is already used in class '%2'", [ member.getNotation$(), ClassDefinition$classFullName$LClassDefinition$($this) ])));
				return false;
			}
			if (! $this._members[i].getType$().equals$LType$(member.getType$())) {
				context.errors.push(new CompileError(member._nameToken, Util$format$SAS("cannot override property '%1' of type '%2' with different type '%3'", [ member.getNotation$(), $this._members[i].getType$().toString(), member.getType$().toString() ])));
				return false;
			}
		}
	}
	if ((_extendType$0 = $this._extendType) != null && ! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$(_extendType$0._classDef, context, member, memberClassDef, token)) {
		return false;
	}
	for (i = 0; i < $this._implementTypes.length; ++ i) {
		if (! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$($this._implementTypes[i]._classDef, context, member, memberClassDef, token)) {
			return false;
		}
	}
	return true;
};

ClassDefinition._assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$ = ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$;

ClassDefinition.prototype._assertMemberFunctionIsDefinable$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB = function (context, member, memberClassDef, token, reportOverridesAsWell, isCheckingInterface) {
	var i;
	var error;
	var note$0;
	var _extendType$0;
	if (member._nameToken._value === "constructor") {
		return true;
	}
	for (i = 0; i < this._members.length; ++ i) {
		if (this._members[i]._nameToken._value !== member._nameToken._value) {
			continue;
		}
		if (this._members[i] instanceof MemberVariableDefinition) {
			error = new CompileError(member._nameToken, "definition of the function conflicts with property '" + this._members[i]._nameToken._value + "'");
			note$0 = new CompileNote(this._members[i]._nameToken, "property with the same name has been found here");
			error._notes.push(note$0);
			context.errors.push(error);
			return false;
		}
		if (! Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._members[i]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member))) {
			continue;
		}
		if (! isCheckingInterface && (member._flags & 32) === 0) {
			context.errors.push(new CompileError(member._nameToken, "overriding functions must have 'override' attribute set (defined in base class '" + ClassDefinition$classFullName$LClassDefinition$(this) + "')"));
			return false;
		}
		if (reportOverridesAsWell && (this._members[i]._flags & 32) !== 0) {
			context.errors.push(new CompileError(member._nameToken, "definition of the function conflicts with sibling mix-in '" + ClassDefinition$classFullName$LClassDefinition$(this) + "'"));
			return false;
		}
		return true;
	}
	if ((_extendType$0 = this._extendType) != null && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB(_extendType$0._classDef, context, member, memberClassDef, token, false, isCheckingInterface)) {
		return false;
	}
	for (i = 0; i < this._implementTypes.length; ++ i) {
		if (! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB(this._implementTypes[i]._classDef, context, member, memberClassDef, token, false, isCheckingInterface)) {
			return false;
		}
	}
	return true;
};


function ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB($this, context, member, memberClassDef, token, reportOverridesAsWell, isCheckingInterface) {
	var i;
	var error;
	var note$0;
	var _extendType$0;
	if (member._nameToken._value === "constructor") {
		return true;
	}
	for (i = 0; i < $this._members.length; ++ i) {
		if ($this._members[i]._nameToken._value !== member._nameToken._value) {
			continue;
		}
		if ($this._members[i] instanceof MemberVariableDefinition) {
			error = new CompileError(member._nameToken, "definition of the function conflicts with property '" + $this._members[i]._nameToken._value + "'");
			note$0 = new CompileNote($this._members[i]._nameToken, "property with the same name has been found here");
			error._notes.push(note$0);
			context.errors.push(error);
			return false;
		}
		if (! Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._members[i]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member))) {
			continue;
		}
		if (! isCheckingInterface && (member._flags & 32) === 0) {
			context.errors.push(new CompileError(member._nameToken, "overriding functions must have 'override' attribute set (defined in base class '" + ClassDefinition$classFullName$LClassDefinition$($this) + "')"));
			return false;
		}
		if (reportOverridesAsWell && ($this._members[i]._flags & 32) !== 0) {
			context.errors.push(new CompileError(member._nameToken, "definition of the function conflicts with sibling mix-in '" + ClassDefinition$classFullName$LClassDefinition$($this) + "'"));
			return false;
		}
		return true;
	}
	if ((_extendType$0 = $this._extendType) != null && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB(_extendType$0._classDef, context, member, memberClassDef, token, false, isCheckingInterface)) {
		return false;
	}
	for (i = 0; i < $this._implementTypes.length; ++ i) {
		if (! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB($this._implementTypes[i]._classDef, context, member, memberClassDef, token, false, isCheckingInterface)) {
			return false;
		}
	}
	return true;
};

ClassDefinition._assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB = ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB;

ClassDefinition.prototype._assertFunctionIsOverridable$LAnalysisContext$LMemberFunctionDefinition$ = function (context, overrideDef) {
	var i;
	var overrideReturnType;
	var memberReturnType;
	var _members$0;
	for (i = 0; i < this._members.length; ++ i) {
		if ((_members$0 = this._members)[i]._nameToken._value === overrideDef._nameToken._value && _members$0[i] instanceof MemberFunctionDefinition && (_members$0[i]._flags & 8) === 0 && Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(_members$0[i]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(overrideDef))) {
			if ((this._members[i]._flags & 4) !== 0) {
				context.errors.push(new CompileError(overrideDef._token, "cannot override final function defined in class '" + ClassDefinition$classFullName$LClassDefinition$(this) + "'"));
				return false;
			}
			overrideReturnType = overrideDef._returnType;
			memberReturnType = this._members[i]._returnType;
			if (! (overrideReturnType.equals$LType$(memberReturnType) || overrideReturnType.isConvertibleTo$LType$(memberReturnType)) || memberReturnType instanceof NullableType && ! (overrideReturnType instanceof NullableType)) {
				context.errors.push(new CompileError(overrideDef._token, "return type '" + overrideReturnType.toString() + "' is not convertible to '" + memberReturnType.toString() + "'"));
				return false;
			} else {
				return true;
			}
		}
	}
	return ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$(this, context, overrideDef);
};


function ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this, context, overrideDef) {
	var i;
	var overrideReturnType;
	var memberReturnType;
	var _members$0;
	for (i = 0; i < $this._members.length; ++ i) {
		if ((_members$0 = $this._members)[i]._nameToken._value === overrideDef._nameToken._value && _members$0[i] instanceof MemberFunctionDefinition && (_members$0[i]._flags & 8) === 0 && Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(_members$0[i]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(overrideDef))) {
			if (($this._members[i]._flags & 4) !== 0) {
				context.errors.push(new CompileError(overrideDef._token, "cannot override final function defined in class '" + ClassDefinition$classFullName$LClassDefinition$($this) + "'"));
				return false;
			}
			overrideReturnType = overrideDef._returnType;
			memberReturnType = $this._members[i]._returnType;
			if (! (overrideReturnType.equals$LType$(memberReturnType) || overrideReturnType.isConvertibleTo$LType$(memberReturnType)) || memberReturnType instanceof NullableType && ! (overrideReturnType instanceof NullableType)) {
				context.errors.push(new CompileError(overrideDef._token, "return type '" + overrideReturnType.toString() + "' is not convertible to '" + memberReturnType.toString() + "'"));
				return false;
			} else {
				return true;
			}
		}
	}
	return ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this, context, overrideDef);
};

ClassDefinition._assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$ = ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$;

ClassDefinition.prototype._assertFunctionIsOverridableInBaseClasses$LAnalysisContext$LMemberFunctionDefinition$ = function (context, member) {
	var ret;
	var i;
	if (this._extendType != null) {
		ret = ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$(this._extendType._classDef, context, member);
		if (ret != null) {
			return ret;
		}
	}
	for (i = 0; i < this._implementTypes.length; ++ i) {
		ret = ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$(this._implementTypes[i]._classDef, context, member);
		if (ret != null) {
			return ret;
		}
	}
	return null;
};


function ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this, context, member) {
	var ret;
	var i;
	if ($this._extendType != null) {
		ret = ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this._extendType._classDef, context, member);
		if (ret != null) {
			return ret;
		}
	}
	for (i = 0; i < $this._implementTypes.length; ++ i) {
		ret = ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this._implementTypes[i]._classDef, context, member);
		if (ret != null) {
			return ret;
		}
	}
	return null;
};

ClassDefinition._assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$ = ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$;

ClassDefinition.prototype._getMembers$ALMemberDefinition$F$LMemberDefinition$B$ = function (list, cb) {
	var i;
	if (this._baseClassDef != null) {
		ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$(this._baseClassDef, list, cb);
	}
	for (i = 0; i < this._implementTypes.length; ++ i) {
		ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$(this._implementTypes[i]._classDef, list, cb);
	}
	for (i = 0; i < this._members.length; ++ i) {
		if (cb(this._members[i])) {
			list.push(this._members[i]);
		}
	}
};


function ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$($this, list, cb) {
	var i;
	if ($this._baseClassDef != null) {
		ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$($this._baseClassDef, list, cb);
	}
	for (i = 0; i < $this._implementTypes.length; ++ i) {
		ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$($this._implementTypes[i]._classDef, list, cb);
	}
	for (i = 0; i < $this._members.length; ++ i) {
		if (cb($this._members[i])) {
			list.push($this._members[i]);
		}
	}
};

ClassDefinition._getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$ = ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$;

ClassDefinition.prototype._getMembers$ALMemberDefinition$BNN = function (list, functionOnly, flagsMask, flagsMaskMatch) {
	var $this = this;
	ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$(this, list, (function (member) {
		var j;
		var list$len$0;
		if (functionOnly && ! (member instanceof MemberFunctionDefinition)) {
			return false;
		}
		if ((member._flags & flagsMask) !== flagsMaskMatch) {
			return false;
		}
		for ((j = 0, list$len$0 = list.length); j < list$len$0; ++ j) {
			if (list[j]._nameToken._value === member._nameToken._value) {
				if (list[j] instanceof MemberVariableDefinition || Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(list[j]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member))) {
					return false;
				}
			}
		}
		return true;
	}));
};


function ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$BNN($this, list, functionOnly, flagsMask, flagsMaskMatch) {
	ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$($this, list, (function (member) {
		var j;
		var list$len$0;
		if (functionOnly && ! (member instanceof MemberFunctionDefinition)) {
			return false;
		}
		if ((member._flags & flagsMask) !== flagsMaskMatch) {
			return false;
		}
		for ((j = 0, list$len$0 = list.length); j < list$len$0; ++ j) {
			if (list[j]._nameToken._value === member._nameToken._value) {
				if (list[j] instanceof MemberVariableDefinition || Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(list[j]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member))) {
					return false;
				}
			}
		}
		return true;
	}));
};

ClassDefinition._getMembers$LClassDefinition$ALMemberDefinition$BNN = ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$BNN;

ClassDefinition.prototype.hasDefaultConstructor$ = function () {
	var hasCtorWithArgs;
	var i;
	var member;
	hasCtorWithArgs = false;
	for (i = 0; i < this._members.length; ++ i) {
		member = this._members[i];
		if (member._nameToken._value === "constructor" && (member._flags & 8) === 0 && member instanceof MemberFunctionDefinition) {
			if (member._args.length === 0) {
				return true;
			}
			hasCtorWithArgs = true;
		}
	}
	return ! hasCtorWithArgs;
};


function ClassDefinition$hasDefaultConstructor$LClassDefinition$($this) {
	var hasCtorWithArgs;
	var i;
	var member;
	hasCtorWithArgs = false;
	for (i = 0; i < $this._members.length; ++ i) {
		member = $this._members[i];
		if (member._nameToken._value === "constructor" && (member._flags & 8) === 0 && member instanceof MemberFunctionDefinition) {
			if (member._args.length === 0) {
				return true;
			}
			hasCtorWithArgs = true;
		}
	}
	return ! hasCtorWithArgs;
};

ClassDefinition.hasDefaultConstructor$LClassDefinition$ = ClassDefinition$hasDefaultConstructor$LClassDefinition$;

function ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$(x, y) {
	if (x._nameToken._value !== y._nameToken._value) {
		return false;
	}
	if (x instanceof MemberFunctionDefinition) {
		if (! (y instanceof MemberFunctionDefinition)) {
			return false;
		}
		if (! Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(x), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(y))) {
			return false;
		}
	} else {
		if (! (y instanceof MemberVariableDefinition)) {
			return false;
		}
	}
	return true;
};

ClassDefinition.membersAreEqual$LMemberDefinition$LMemberDefinition$ = ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$;

function MemberDefinition(token, nameToken, flags, closures, docComment) {
	this._stash = {};
	this._token = token;
	this._nameToken = nameToken;
	this._flags = flags;
	this._closures = closures;
	this._docComment = docComment;
	this._classDef = null;
};

$__jsx_extend([MemberDefinition], Object);
$__jsx_merge_interface(MemberDefinition, Stashable);

MemberDefinition.prototype.getToken$ = function () {
	return this._token;
};


function MemberDefinition$getToken$LMemberDefinition$($this) {
	return $this._token;
};

MemberDefinition.getToken$LMemberDefinition$ = MemberDefinition$getToken$LMemberDefinition$;

MemberDefinition.prototype.getNameToken$ = function () {
	return this._nameToken;
};


function MemberDefinition$getNameToken$LMemberDefinition$($this) {
	return $this._nameToken;
};

MemberDefinition.getNameToken$LMemberDefinition$ = MemberDefinition$getNameToken$LMemberDefinition$;

MemberDefinition.prototype.name$ = function () {
	return this._nameToken._value;
};


function MemberDefinition$name$LMemberDefinition$($this) {
	return $this._nameToken._value;
};

MemberDefinition.name$LMemberDefinition$ = MemberDefinition$name$LMemberDefinition$;

MemberDefinition.prototype.flags$ = function () {
	return this._flags;
};


function MemberDefinition$flags$LMemberDefinition$($this) {
	return $this._flags;
};

MemberDefinition.flags$LMemberDefinition$ = MemberDefinition$flags$LMemberDefinition$;

MemberDefinition.prototype.setFlags$N = function (flags) {
	this._flags = flags;
};


function MemberDefinition$setFlags$LMemberDefinition$N($this, flags) {
	$this._flags = flags;
};

MemberDefinition.setFlags$LMemberDefinition$N = MemberDefinition$setFlags$LMemberDefinition$N;

MemberDefinition.prototype.getClosures$ = function () {
	return this._closures;
};


function MemberDefinition$getClosures$LMemberDefinition$($this) {
	return $this._closures;
};

MemberDefinition.getClosures$LMemberDefinition$ = MemberDefinition$getClosures$LMemberDefinition$;

MemberDefinition.prototype.forEachClosure$F$LMemberFunctionDefinition$B$ = function (cb) {
	var i;
	if (this._closures != null) {
		for (i = 0; i < this._closures.length; ++ i) {
			if (! cb(this._closures[i])) {
				return false;
			}
		}
	}
	return true;
};


function MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$($this, cb) {
	var i;
	if ($this._closures != null) {
		for (i = 0; i < $this._closures.length; ++ i) {
			if (! cb($this._closures[i])) {
				return false;
			}
		}
	}
	return true;
};

MemberDefinition.forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$ = MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$;

MemberDefinition.prototype.getDocComment$ = function () {
	return this._docComment;
};


function MemberDefinition$getDocComment$LMemberDefinition$($this) {
	return $this._docComment;
};

MemberDefinition.getDocComment$LMemberDefinition$ = MemberDefinition$getDocComment$LMemberDefinition$;

MemberDefinition.prototype.setDocComment$LDocComment$ = function (docComment) {
	this._docComment = docComment;
};


function MemberDefinition$setDocComment$LMemberDefinition$LDocComment$($this, docComment) {
	$this._docComment = docComment;
};

MemberDefinition.setDocComment$LMemberDefinition$LDocComment$ = MemberDefinition$setDocComment$LMemberDefinition$LDocComment$;

MemberDefinition.prototype.getClassDef$ = function () {
	return this._classDef;
};


function MemberDefinition$getClassDef$LMemberDefinition$($this) {
	return $this._classDef;
};

MemberDefinition.getClassDef$LMemberDefinition$ = MemberDefinition$getClassDef$LMemberDefinition$;

MemberDefinition.prototype.setClassDef$LClassDefinition$ = function (classDef) {
	this._classDef = classDef;
};


function MemberDefinition$setClassDef$LMemberDefinition$LClassDefinition$($this, classDef) {
	$this._classDef = classDef;
};

MemberDefinition.setClassDef$LMemberDefinition$LClassDefinition$ = MemberDefinition$setClassDef$LMemberDefinition$LClassDefinition$;

MemberDefinition.prototype._instantiateClosures$LInstantiationContext$ = function (instantiationContext) {
	var closures;
	var i;
	closures = [];
	for (i = 0; i < this._closures.length; ++ i) {
		closures[i] = this._closures[i].instantiate$LInstantiationContext$(instantiationContext);
	}
	return closures;
};


function MemberDefinition$_instantiateClosures$LMemberDefinition$LInstantiationContext$($this, instantiationContext) {
	var closures;
	var i;
	closures = [];
	for (i = 0; i < $this._closures.length; ++ i) {
		closures[i] = $this._closures[i].instantiate$LInstantiationContext$(instantiationContext);
	}
	return closures;
};

MemberDefinition._instantiateClosures$LMemberDefinition$LInstantiationContext$ = MemberDefinition$_instantiateClosures$LMemberDefinition$LInstantiationContext$;

MemberDefinition.prototype._updateLinkFromExpressionToClosuresUponInstantiation$LExpression$ALMemberFunctionDefinition$ = function (instantiatedExpr, instantiatedClosures) {
	var $this = this;
	var onExpr;
	function onExpr(expr) {
		var i;
		var funcDef$0;
		if (expr instanceof FunctionExpression) {
			for (i = 0; i < $this._closures.length; ++ i) {
				if ($this._closures[i] == expr._funcDef) {
					break;
				}
			}
			if (i === $this._closures.length) {
				throw new Error("logic flaw, cannot find the closure");
			}
			funcDef$0 = instantiatedClosures[i];
			expr._funcDef = funcDef$0;
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}
	onExpr(instantiatedExpr);
};


function MemberDefinition$_updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$($this, instantiatedExpr, instantiatedClosures) {
	var onExpr;
	function onExpr(expr) {
		var i;
		var funcDef$0;
		if (expr instanceof FunctionExpression) {
			for (i = 0; i < $this._closures.length; ++ i) {
				if ($this._closures[i] == expr._funcDef) {
					break;
				}
			}
			if (i === $this._closures.length) {
				throw new Error("logic flaw, cannot find the closure");
			}
			funcDef$0 = instantiatedClosures[i];
			expr._funcDef = funcDef$0;
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}
	onExpr(instantiatedExpr);
};

MemberDefinition._updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$ = MemberDefinition$_updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$;

function MemberVariableDefinition(token, name, flags, type, initialValue, closures, docComment) {
	MemberDefinition.call(this, token, name, flags, closures, docComment);
	this._type = type;
	this._initialValue = initialValue;
	this._analyzeState = 0;
	this._analysisContext = null;
};

$__jsx_extend([MemberVariableDefinition], MemberDefinition);
MemberVariableDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var type;
	var initialValue;
	var closures;
	type = (this._type != null ? this._type.instantiate$LInstantiationContext$(instantiationContext) : null);
	initialValue = null;
	if (this._initialValue != null) {
		initialValue = this._initialValue.clone$();
		Expression$instantiate$LExpression$LInstantiationContext$(initialValue, instantiationContext);
		closures = MemberDefinition$_instantiateClosures$LMemberDefinition$LInstantiationContext$(this, instantiationContext);
		MemberDefinition$_updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$(this, initialValue, closures);
	} else {
		closures = [  ];
	}
	return new MemberVariableDefinition(this._token, this._nameToken, this._flags, type, initialValue, closures, null);
};


MemberVariableDefinition.prototype.toString = function () {
	return this._nameToken._value + " : " + this._type.toString();
};


MemberVariableDefinition.prototype.serialize$ = function () {
	var serializeNullable$v$0;
	var serializeNullable$v$1;
	var serializeNullable$v$2;
	var serializeNullable$v$3;
	return ({ "token": (serializeNullable$v$0 = this._token, serializeNullable$v$0 == null ? null : [ serializeNullable$v$0._value, serializeNullable$v$0._isIdentifier, serializeNullable$v$0._filename, serializeNullable$v$0._lineNumber, serializeNullable$v$0._columnNumber ]), "nameToken": (serializeNullable$v$1 = this._nameToken, serializeNullable$v$1 == null ? null : [ serializeNullable$v$1._value, serializeNullable$v$1._isIdentifier, serializeNullable$v$1._filename, serializeNullable$v$1._lineNumber, serializeNullable$v$1._columnNumber ]), "flags": this._flags, "type": (serializeNullable$v$2 = this._type, serializeNullable$v$2 == null ? null : serializeNullable$v$2.toString()), "initialValue": (serializeNullable$v$3 = this._initialValue, serializeNullable$v$3 == null ? null : serializeNullable$v$3.serialize$()) });
};


MemberVariableDefinition.prototype.setAnalysisContext$LAnalysisContext$ = function (context) {
	var this$0$0;
	var funcDef$0$0;
	this$0$0 = ({errors: context.errors, parser: context.parser, postInstantiationCallback: context.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
	funcDef$0$0 = context.funcDef;
	this$0$0.funcDef = funcDef$0$0;
	this._analysisContext = this$0$0;
};


function MemberVariableDefinition$setAnalysisContext$LMemberVariableDefinition$LAnalysisContext$($this, context) {
	var this$0$0;
	var funcDef$0$0;
	this$0$0 = ({errors: context.errors, parser: context.parser, postInstantiationCallback: context.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
	funcDef$0$0 = context.funcDef;
	this$0$0.funcDef = funcDef$0$0;
	$this._analysisContext = this$0$0;
};

MemberVariableDefinition.setAnalysisContext$LMemberVariableDefinition$LAnalysisContext$ = MemberVariableDefinition$setAnalysisContext$LMemberVariableDefinition$LAnalysisContext$;

MemberVariableDefinition.prototype.getType$ = function () {
	var ivType;
	var _nameToken$0;
	switch (this._analyzeState) {
	case 0:
		try {
			this._analyzeState = 1;
			if (this._initialValue != null) {
				if (! this._initialValue.analyze$LAnalysisContext$LExpression$(this._analysisContext, null)) {
					return null;
				}
				if (this._initialValue.isClassSpecifier$()) {
					this._analysisContext.errors.push(new CompileError(this._initialValue._token, "cannot assign a class"));
					return null;
				}
				ivType = this._initialValue.getType$();
				if (this._type == null) {
					if (ivType.equals$LType$(Type.nullType)) {
						this._analysisContext.errors.push(new CompileError(this._initialValue._token, "cannot assign null to an unknown type"));
						return null;
					}
					if (ivType.equals$LType$(Type.voidType)) {
						this._analysisContext.errors.push(new CompileError(this._initialValue._token, "cannot assign void"));
						return null;
					}
					this._type = ivType.asAssignableType$();
				} else {
					if (! ivType.isConvertibleTo$LType$(this._type)) {
						this._analysisContext.errors.push(new CompileError(this._nameToken, "the variable is declared as '" + this._type.toString() + "' but initial value is '" + ivType.toString() + "'"));
					}
				}
			}
			this._analyzeState = 2;
		} finally {
			if (this._analyzeState !== 2) {
				this._analyzeState = 3;
			}
		}
		break;
	case 1:
		this._analysisContext.errors.push(new CompileError(_nameToken$0 = this._nameToken, "please declare type of variable '" + _nameToken$0._value + "' (detected recursion while trying to reduce type)"));
		break;
	default:
		break;
	}
	return this._type;
};


MemberVariableDefinition.prototype.getInitialValue$ = function () {
	return this._initialValue;
};


function MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$($this) {
	return $this._initialValue;
};

MemberVariableDefinition.getInitialValue$LMemberVariableDefinition$ = MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$;

MemberVariableDefinition.prototype.setInitialValue$LExpression$ = function (initialValue) {
	this._initialValue = initialValue;
};


function MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$($this, initialValue) {
	$this._initialValue = initialValue;
};

MemberVariableDefinition.setInitialValue$LMemberVariableDefinition$LExpression$ = MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$;

MemberVariableDefinition.prototype.getNotation$ = function () {
	var classDef;
	var s;
	classDef = this._classDef;
	s = (classDef != null ? ClassDefinition$classFullName$LClassDefinition$(classDef) : "<<unknown>>");
	s += ((this._flags & 8) !== 0 ? "." : "#");
	s += this._nameToken._value;
	return s;
};


function MemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
	var i;
	MemberDefinition.call(this, token, name, flags, closures, docComment);
	this._returnType = returnType;
	this._args = args;
	this._locals = locals;
	this._statements = statements;
	this._lastTokenOfBody = lastTokenOfBody;
	this._parent = null;
	this._funcLocal = null;
	this._classDef = null;
	for (i = 0; i < this._closures.length; ++ i) {
		this._closures[i]._parent = this;
	}
};

$__jsx_extend([MemberFunctionDefinition], MemberDefinition);
$__jsx_merge_interface(MemberFunctionDefinition, Block);

MemberFunctionDefinition.prototype.isAnonymous$ = function () {
	return this._nameToken == null;
};


function MemberFunctionDefinition$isAnonymous$LMemberFunctionDefinition$($this) {
	return $this._nameToken == null;
};

MemberFunctionDefinition.isAnonymous$LMemberFunctionDefinition$ = MemberFunctionDefinition$isAnonymous$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.isGenerator$ = function () {
	return (this._flags & 8192) !== 0;
};


function MemberFunctionDefinition$isGenerator$LMemberFunctionDefinition$($this) {
	return ($this._flags & 8192) !== 0;
};

MemberFunctionDefinition.isGenerator$LMemberFunctionDefinition$ = MemberFunctionDefinition$isGenerator$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.getNotation$ = function () {
	var $this = this;
	var classDef;
	var s;
	classDef = this._classDef;
	s = (classDef != null ? ClassDefinition$classFullName$LClassDefinition$(classDef) : "<<unknown>>");
	s += ((this._flags & 8) !== 0 ? "." : "#");
	s += (this._nameToken != null ? this._nameToken._value : "$" + (this._token._lineNumber + "") + "_" + (this._token._columnNumber + ""));
	s += "(";
	s += this._args.map((function (arg) {
		return ":" + arg._type.toString();
	})).join(",");
	s += ")";
	return s;
};


MemberFunctionDefinition.prototype.toString = function () {
	var $this = this;
	var argsText;
	argsText = this._args.map((function (arg) {
		return arg._name._value + " : " + arg._type.toString();
	})).join(", ");
	return "function " + this._nameToken._value + "(" + argsText + ") : " + this._returnType.toString();
};


MemberFunctionDefinition.prototype.clone$ = function () {
	var $this = this;
	var stashesUsed;
	var getStash;
	var cloneFuncDef;
	var clonedFuncDef;
	var i;
	var stash;
	var stashesUsed$len$0;
	stashesUsed = [];
	function getStash(stashable) {
		var stash;
		stash = stashable.getStash$S("CLONE-FUNC-DEF");
		if (stash == null) {
			stash = stashable.setStash$SLStash$("CLONE-FUNC-DEF", new MemberFunctionDefinition$x2E_CloneStash());
		}
		stashesUsed.push(stash);
		return stash;
	}
	function cloneFuncDef(funcDef) {
		var statements;
		var closures;
		var funcLocal;
		var newFuncLocal;
		var args;
		var locals;
		var clonedFuncDef;
		statements = Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(funcDef._statements);
		closures = funcDef._closures.map((function (funcDef) {
			var newFuncDef;
			newFuncDef = cloneFuncDef(funcDef);
			getStash(funcDef).newFuncDef = newFuncDef;
			return newFuncDef;
		}));
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var newFuncDef;
			if (statement instanceof FunctionStatement) {
				if ((newFuncDef = getStash(FunctionStatement$getFuncDef$LFunctionStatement$(statement)).newFuncDef) != null) {
					FunctionStatement$setFuncDef$LFunctionStatement$LMemberFunctionDefinition$(statement, newFuncDef);
				}
				return true;
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				var newFuncDef;
				if (expr instanceof FunctionExpression) {
					if ((newFuncDef = getStash(FunctionExpression$getFuncDef$LFunctionExpression$(expr)).newFuncDef) != null) {
						FunctionExpression$setFuncDef$LFunctionExpression$LMemberFunctionDefinition$(expr, newFuncDef);
					}
					return true;
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && statement.forEachStatement$F$LStatement$B$(onStatement);
		}), statements);
		funcLocal = funcDef._funcLocal;
		if (funcLocal != null) {
			if ((newFuncLocal = getStash(funcLocal).newLocal) != null) {
			} else {
				newFuncLocal = new LocalVariable(funcLocal._name, funcLocal._type);
				getStash(funcLocal).newLocal = newFuncLocal;
			}
			funcLocal = newFuncLocal;
		}
		args = funcDef._args.map((function (arg) {
			var newArg;
			newArg = ArgumentDeclaration$clone$LArgumentDeclaration$(arg);
			getStash(arg).newLocal = newArg;
			return newArg;
		}));
		locals = funcDef._locals.map((function (local) {
			var newLocal;
			if ((newLocal = getStash(local).newLocal) != null) {
				return newLocal;
			}
			newLocal = new LocalVariable(LocalVariable$getName$LLocalVariable$(local), LocalVariable$getType$LLocalVariable$(local));
			getStash(local).newLocal = newLocal;
			return newLocal;
		}));
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var caughtVar;
			if (statement instanceof CatchStatement) {
				caughtVar = CaughtVariable$clone$LCaughtVariable$(CatchStatement$getLocal$LCatchStatement$(statement));
				getStash(CatchStatement$getLocal$LCatchStatement$(statement)).newLocal = caughtVar;
				CatchStatement$setLocal$LCatchStatement$LCaughtVariable$(statement, caughtVar);
			} else {
				if (statement instanceof FunctionStatement) {
					MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionStatement$getFuncDef$LFunctionStatement$(statement), onStatement);
				}
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				if (expr instanceof FunctionExpression) {
					return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && statement.forEachStatement$F$LStatement$B$(onStatement);
		}), statements);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			if (statement instanceof FunctionStatement) {
				MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionStatement$getFuncDef$LFunctionStatement$(statement), onStatement);
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				var newLocal;
				if (expr instanceof LocalExpression) {
					if ((newLocal = getStash(LocalExpression$getLocal$LLocalExpression$(expr)).newLocal) != null) {
						LocalExpression$setLocal$LLocalExpression$LLocalVariable$(expr, newLocal);
					}
				} else {
					if (expr instanceof FunctionExpression) {
						return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
					}
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && statement.forEachStatement$F$LStatement$B$(onStatement);
		}), statements);
		clonedFuncDef = new MemberFunctionDefinition(funcDef._token, funcDef._nameToken, funcDef._flags, funcDef._returnType, args, locals, statements, closures, funcDef._lastTokenOfBody, null);
		clonedFuncDef._funcLocal = funcLocal;
		return clonedFuncDef;
	}
	clonedFuncDef = cloneFuncDef(this);
	for ((i = 0, stashesUsed$len$0 = stashesUsed.length); i < stashesUsed$len$0; ++ i) {
		stash = stashesUsed[i];
		stash.newLocal = null;
		stash.newFuncDef = null;
	}
	return clonedFuncDef;
};


function MemberFunctionDefinition$clone$LMemberFunctionDefinition$($this) {
	var stashesUsed;
	var getStash;
	var cloneFuncDef;
	var clonedFuncDef;
	var i;
	var stash;
	var stashesUsed$len$0;
	stashesUsed = [];
	function getStash(stashable) {
		var stash;
		stash = stashable.getStash$S("CLONE-FUNC-DEF");
		if (stash == null) {
			stash = stashable.setStash$SLStash$("CLONE-FUNC-DEF", new MemberFunctionDefinition$x2E_CloneStash());
		}
		stashesUsed.push(stash);
		return stash;
	}
	function cloneFuncDef(funcDef) {
		var statements;
		var closures;
		var funcLocal;
		var newFuncLocal;
		var args;
		var locals;
		var clonedFuncDef;
		statements = Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(funcDef._statements);
		closures = funcDef._closures.map((function (funcDef) {
			var newFuncDef;
			newFuncDef = cloneFuncDef(funcDef);
			getStash(funcDef).newFuncDef = newFuncDef;
			return newFuncDef;
		}));
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var newFuncDef;
			if (statement instanceof FunctionStatement) {
				if ((newFuncDef = getStash(FunctionStatement$getFuncDef$LFunctionStatement$(statement)).newFuncDef) != null) {
					FunctionStatement$setFuncDef$LFunctionStatement$LMemberFunctionDefinition$(statement, newFuncDef);
				}
				return true;
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				var newFuncDef;
				if (expr instanceof FunctionExpression) {
					if ((newFuncDef = getStash(FunctionExpression$getFuncDef$LFunctionExpression$(expr)).newFuncDef) != null) {
						FunctionExpression$setFuncDef$LFunctionExpression$LMemberFunctionDefinition$(expr, newFuncDef);
					}
					return true;
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && statement.forEachStatement$F$LStatement$B$(onStatement);
		}), statements);
		funcLocal = funcDef._funcLocal;
		if (funcLocal != null) {
			if ((newFuncLocal = getStash(funcLocal).newLocal) != null) {
			} else {
				newFuncLocal = new LocalVariable(funcLocal._name, funcLocal._type);
				getStash(funcLocal).newLocal = newFuncLocal;
			}
			funcLocal = newFuncLocal;
		}
		args = funcDef._args.map((function (arg) {
			var newArg;
			newArg = ArgumentDeclaration$clone$LArgumentDeclaration$(arg);
			getStash(arg).newLocal = newArg;
			return newArg;
		}));
		locals = funcDef._locals.map((function (local) {
			var newLocal;
			if ((newLocal = getStash(local).newLocal) != null) {
				return newLocal;
			}
			newLocal = new LocalVariable(LocalVariable$getName$LLocalVariable$(local), LocalVariable$getType$LLocalVariable$(local));
			getStash(local).newLocal = newLocal;
			return newLocal;
		}));
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var caughtVar;
			if (statement instanceof CatchStatement) {
				caughtVar = CaughtVariable$clone$LCaughtVariable$(CatchStatement$getLocal$LCatchStatement$(statement));
				getStash(CatchStatement$getLocal$LCatchStatement$(statement)).newLocal = caughtVar;
				CatchStatement$setLocal$LCatchStatement$LCaughtVariable$(statement, caughtVar);
			} else {
				if (statement instanceof FunctionStatement) {
					MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionStatement$getFuncDef$LFunctionStatement$(statement), onStatement);
				}
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				if (expr instanceof FunctionExpression) {
					return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && statement.forEachStatement$F$LStatement$B$(onStatement);
		}), statements);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			if (statement instanceof FunctionStatement) {
				MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionStatement$getFuncDef$LFunctionStatement$(statement), onStatement);
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				var newLocal;
				if (expr instanceof LocalExpression) {
					if ((newLocal = getStash(LocalExpression$getLocal$LLocalExpression$(expr)).newLocal) != null) {
						LocalExpression$setLocal$LLocalExpression$LLocalVariable$(expr, newLocal);
					}
				} else {
					if (expr instanceof FunctionExpression) {
						return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
					}
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && statement.forEachStatement$F$LStatement$B$(onStatement);
		}), statements);
		clonedFuncDef = new MemberFunctionDefinition(funcDef._token, funcDef._nameToken, funcDef._flags, funcDef._returnType, args, locals, statements, closures, funcDef._lastTokenOfBody, null);
		clonedFuncDef._funcLocal = funcLocal;
		return clonedFuncDef;
	}
	clonedFuncDef = cloneFuncDef($this);
	for ((i = 0, stashesUsed$len$0 = stashesUsed.length); i < stashesUsed$len$0; ++ i) {
		stash = stashesUsed[i];
		stash.newLocal = null;
		stash.newFuncDef = null;
	}
	return clonedFuncDef;
};

MemberFunctionDefinition.clone$LMemberFunctionDefinition$ = MemberFunctionDefinition$clone$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var $this = this;
	return MemberFunctionDefinition$_instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$(this, instantiationContext, (function (token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
		return new MemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment);
	}));
};


MemberFunctionDefinition.prototype._instantiateCore$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$ = function (instantiationContext, constructCallback) {
	var $this = this;
	var args;
	var i;
	var locals;
	var caughtVariables;
	var statements;
	var closures;
	var returnType;
	args = [];
	for (i = 0; i < this._args.length; ++ i) {
		args[i] = this._args[i].instantiateAndPush$LInstantiationContext$(instantiationContext);
	}
	if (this._statements != null) {
		locals = [];
		for (i = 0; i < this._locals.length; ++ i) {
			locals[i] = this._locals[i].instantiateAndPush$LInstantiationContext$(instantiationContext);
		}
		caughtVariables = [];
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			if (statement instanceof CatchStatement) {
				caughtVariables.push(statement._local.instantiateAndPush$LInstantiationContext$(instantiationContext));
			}
			return statement.forEachStatement$F$LStatement$B$(onStatement);
		}), this._statements);
		statements = [];
		for (i = 0; i < this._statements.length; ++ i) {
			if (this._statements[i] instanceof ConstructorInvocationStatement) {
				statements[i] = ConstructorInvocationStatement$instantiate$LConstructorInvocationStatement$LInstantiationContext$(this._statements[i], instantiationContext);
			} else {
				statements[i] = this._statements[i].clone$();
			}
		}
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var local$0;
			if (statement instanceof CatchStatement) {
				if (caughtVariables.length === 0) {
					throw new Error("logic flaw");
				}
				local$0 = caughtVariables.shift();
				statement._local = local$0;
			}
			Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
				return Expression$instantiate$LExpression$LInstantiationContext$(expr, instantiationContext);
			}));
			return statement.forEachStatement$F$LStatement$B$(onStatement);
		}), statements);
		closures = MemberDefinition$_instantiateClosures$LMemberDefinition$LInstantiationContext$(this, instantiationContext);
		for (i = 0; i < this._locals.length; ++ i) {
			if (this._locals[i].isInstantiated) {
				throw new Error("logic flaw");
			}
			this._locals[i]._instantiated.pop();
		}
		if (caughtVariables.length !== 0) {
			throw new Error("logic flaw");
		}
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var this$0;
			if (statement instanceof CatchStatement) {
				this$0 = statement._local;
				this$0._instantiated.pop();
			}
			return statement.forEachStatement$F$LStatement$B$(onStatement);
		}), this._statements);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var i;
			var funcDef$0;
			if (statement instanceof FunctionStatement) {
				for (i = 0; i < $this._closures.length; ++ i) {
					if ($this._closures[i] == statement._funcDef) {
						break;
					}
				}
				if (i === $this._closures.length) {
					throw new Error("logic flaw, cannot find the closure");
				}
				funcDef$0 = closures[i];
				statement._funcDef = funcDef$0;
				return true;
			}
			Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
				MemberDefinition$_updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$($this, expr, closures);
				return true;
			}));
			return statement.forEachStatement$F$LStatement$B$(onStatement);
		}), statements);
	} else {
		locals = null;
		statements = null;
		closures = [];
	}
	for (i = 0; i < this._args.length; ++ i) {
		this._args[i]._instantiated.pop();
	}
	if (this._returnType != null) {
		returnType = this._returnType.instantiate$LInstantiationContext$(instantiationContext);
		if (returnType == null) {
			return null;
		}
	} else {
		returnType = null;
	}
	return constructCallback(this._token, this._nameToken, this._flags, returnType, args, locals, statements, closures, this._lastTokenOfBody, this._docComment);
};


function MemberFunctionDefinition$_instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$($this, instantiationContext, constructCallback) {
	var args;
	var i;
	var locals;
	var caughtVariables;
	var statements;
	var closures;
	var returnType;
	args = [];
	for (i = 0; i < $this._args.length; ++ i) {
		args[i] = $this._args[i].instantiateAndPush$LInstantiationContext$(instantiationContext);
	}
	if ($this._statements != null) {
		locals = [];
		for (i = 0; i < $this._locals.length; ++ i) {
			locals[i] = $this._locals[i].instantiateAndPush$LInstantiationContext$(instantiationContext);
		}
		caughtVariables = [];
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			if (statement instanceof CatchStatement) {
				caughtVariables.push(statement._local.instantiateAndPush$LInstantiationContext$(instantiationContext));
			}
			return statement.forEachStatement$F$LStatement$B$(onStatement);
		}), $this._statements);
		statements = [];
		for (i = 0; i < $this._statements.length; ++ i) {
			if ($this._statements[i] instanceof ConstructorInvocationStatement) {
				statements[i] = ConstructorInvocationStatement$instantiate$LConstructorInvocationStatement$LInstantiationContext$($this._statements[i], instantiationContext);
			} else {
				statements[i] = $this._statements[i].clone$();
			}
		}
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var local$0;
			if (statement instanceof CatchStatement) {
				if (caughtVariables.length === 0) {
					throw new Error("logic flaw");
				}
				local$0 = caughtVariables.shift();
				statement._local = local$0;
			}
			Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
				return Expression$instantiate$LExpression$LInstantiationContext$(expr, instantiationContext);
			}));
			return statement.forEachStatement$F$LStatement$B$(onStatement);
		}), statements);
		closures = MemberDefinition$_instantiateClosures$LMemberDefinition$LInstantiationContext$($this, instantiationContext);
		for (i = 0; i < $this._locals.length; ++ i) {
			if ($this._locals[i].isInstantiated) {
				throw new Error("logic flaw");
			}
			$this._locals[i]._instantiated.pop();
		}
		if (caughtVariables.length !== 0) {
			throw new Error("logic flaw");
		}
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var this$0;
			if (statement instanceof CatchStatement) {
				this$0 = statement._local;
				this$0._instantiated.pop();
			}
			return statement.forEachStatement$F$LStatement$B$(onStatement);
		}), $this._statements);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var i;
			var funcDef$0;
			if (statement instanceof FunctionStatement) {
				for (i = 0; i < $this._closures.length; ++ i) {
					if ($this._closures[i] == statement._funcDef) {
						break;
					}
				}
				if (i === $this._closures.length) {
					throw new Error("logic flaw, cannot find the closure");
				}
				funcDef$0 = closures[i];
				statement._funcDef = funcDef$0;
				return true;
			}
			Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
				MemberDefinition$_updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$($this, expr, closures);
				return true;
			}));
			return statement.forEachStatement$F$LStatement$B$(onStatement);
		}), statements);
	} else {
		locals = null;
		statements = null;
		closures = [];
	}
	for (i = 0; i < $this._args.length; ++ i) {
		$this._args[i]._instantiated.pop();
	}
	if ($this._returnType != null) {
		returnType = $this._returnType.instantiate$LInstantiationContext$(instantiationContext);
		if (returnType == null) {
			return null;
		}
	} else {
		returnType = null;
	}
	return constructCallback($this._token, $this._nameToken, $this._flags, returnType, args, locals, statements, closures, $this._lastTokenOfBody, $this._docComment);
};

MemberFunctionDefinition._instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$ = MemberFunctionDefinition$_instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$;

MemberFunctionDefinition.prototype.serialize$ = function () {
	var serializeNullable$v$0;
	var serializeNullable$v$1;
	var serializeNullable$v$2;
	return ({ "token": (serializeNullable$v$0 = this._token, serializeNullable$v$0 == null ? null : [ serializeNullable$v$0._value, serializeNullable$v$0._isIdentifier, serializeNullable$v$0._filename, serializeNullable$v$0._lineNumber, serializeNullable$v$0._columnNumber ]), "nameToken": (serializeNullable$v$1 = this._nameToken, serializeNullable$v$1 == null ? null : [ serializeNullable$v$1._value, serializeNullable$v$1._isIdentifier, serializeNullable$v$1._filename, serializeNullable$v$1._lineNumber, serializeNullable$v$1._columnNumber ]), "flags": this._flags, "returnType": (serializeNullable$v$2 = this._returnType, serializeNullable$v$2 == null ? null : serializeNullable$v$2.toString()), "args": Serializer$x2E$x3CArgumentDeclaration$x3E$serializeArray$ALArgumentDeclaration$(this._args), "locals": Serializer$x2E$x3CLocalVariable$x3E$serializeArray$ALLocalVariable$(this._locals), "statements": Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this._statements) });
};


MemberFunctionDefinition.prototype.analyze$LAnalysisContext$ = function (outerContext) {
	var $this = this;
	var docComment;
	var args;
	var context;
	var i;
	var stack$0;
	var stack$1;
	var type$0;
	var this$0$0;
	var blockStack$0;
	var blockStack$1;
	var blockStack$2;
	var _nameToken$0;
	if ((this._flags & 32768) === 0) {
		docComment = this._docComment;
		if (docComment) {
			args = this._args;
			docComment._params.forEach((function (docParam, i) {
				var _token$0;
				var args$len$0;
				for (args$len$0 = args.length; i < args$len$0; ++ i) {
					if (args[i]._name._value === docParam._token._value) {
						return;
					}
				}
				outerContext.errors.push(new CompileError(_token$0 = docParam._token, 'invalid parameter name "' + _token$0._value + '" for ' + $this._nameToken._value + "()"));
			}));
		}
	}
	if (this._statements == null) {
		return;
	}
	this$0$0 = ({errors: outerContext.errors, parser: outerContext.parser, postInstantiationCallback: outerContext.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
	this$0$0.funcDef = this;
	context = this$0$0;
	if (this._parent == null) {
		stack$0 = [ ({localVariableStatuses: new LocalVariableStatuses(this, null), block: this}) ];
		context.blockStack = stack$0;
	} else {
		stack$1 = blockStack$1 = outerContext.blockStack;
		blockStack$0 = context.blockStack = stack$1;
		blockStack$0.push(({localVariableStatuses: new LocalVariableStatuses(this, blockStack$1[blockStack$1.length - 1].localVariableStatuses), block: this}));
		if (! (this._nameToken == null)) {
			if (this._returnType != null) {
				context.blockStack[context.blockStack.length - 1].localVariableStatuses._statuses[this._nameToken._value] = 1;
			} else {
				context.blockStack[context.blockStack.length - 1].localVariableStatuses._statuses[this._nameToken._value] = -1;
			}
		}
	}
	try {
		for (i = 0; i < this._statements.length; ++ i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
				break;
			}
		}
		if (this._returnType == null) {
			this._returnType = Type.voidType;
		}
		if ((this._flags & 8192) !== 0) {
		} else {
			if (! this._returnType.equals$LType$(Type.voidType) && (blockStack$2 = context.blockStack)[blockStack$2.length - 1].localVariableStatuses._isReachable) {
				context.errors.push(new CompileError(this._lastTokenOfBody, "missing return statement"));
			}
		}
		if (this._parent == null && (_nameToken$0 = this._nameToken) != null && _nameToken$0._value === "constructor") {
			MemberFunctionDefinition$_fixupConstructor$LMemberFunctionDefinition$LAnalysisContext$(this, context);
		}
	} finally {
		context.blockStack.pop();
	}
	if (this._funcLocal != null) {
		type$0 = this.getType$();
		this._funcLocal._type = type$0;
	}
};


function MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$($this, outerContext) {
	var docComment;
	var args;
	var context;
	var i;
	var stack$0;
	var stack$1;
	var type$0;
	var this$0$0;
	var blockStack$0;
	var blockStack$1;
	var blockStack$2;
	var _nameToken$0;
	if (($this._flags & 32768) === 0) {
		docComment = $this._docComment;
		if (docComment) {
			args = $this._args;
			docComment._params.forEach((function (docParam, i) {
				var _token$0;
				var args$len$0;
				for (args$len$0 = args.length; i < args$len$0; ++ i) {
					if (args[i]._name._value === docParam._token._value) {
						return;
					}
				}
				outerContext.errors.push(new CompileError(_token$0 = docParam._token, 'invalid parameter name "' + _token$0._value + '" for ' + $this._nameToken._value + "()"));
			}));
		}
	}
	if ($this._statements == null) {
		return;
	}
	this$0$0 = ({errors: outerContext.errors, parser: outerContext.parser, postInstantiationCallback: outerContext.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
	this$0$0.funcDef = $this;
	context = this$0$0;
	if ($this._parent == null) {
		stack$0 = [ ({localVariableStatuses: new LocalVariableStatuses($this, null), block: $this}) ];
		context.blockStack = stack$0;
	} else {
		stack$1 = blockStack$1 = outerContext.blockStack;
		blockStack$0 = context.blockStack = stack$1;
		blockStack$0.push(({localVariableStatuses: new LocalVariableStatuses($this, blockStack$1[blockStack$1.length - 1].localVariableStatuses), block: $this}));
		if (! ($this._nameToken == null)) {
			if ($this._returnType != null) {
				context.blockStack[context.blockStack.length - 1].localVariableStatuses._statuses[$this._nameToken._value] = 1;
			} else {
				context.blockStack[context.blockStack.length - 1].localVariableStatuses._statuses[$this._nameToken._value] = -1;
			}
		}
	}
	try {
		for (i = 0; i < $this._statements.length; ++ i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$($this._statements[i], context)) {
				break;
			}
		}
		if ($this._returnType == null) {
			$this._returnType = Type.voidType;
		}
		if (($this._flags & 8192) !== 0) {
		} else {
			if (! $this._returnType.equals$LType$(Type.voidType) && (blockStack$2 = context.blockStack)[blockStack$2.length - 1].localVariableStatuses._isReachable) {
				context.errors.push(new CompileError($this._lastTokenOfBody, "missing return statement"));
			}
		}
		if ($this._parent == null && (_nameToken$0 = $this._nameToken) != null && _nameToken$0._value === "constructor") {
			MemberFunctionDefinition$_fixupConstructor$LMemberFunctionDefinition$LAnalysisContext$($this, context);
		}
	} finally {
		context.blockStack.pop();
	}
	if ($this._funcLocal != null) {
		type$0 = $this.getType$();
		$this._funcLocal._type = type$0;
	}
};

MemberFunctionDefinition.analyze$LMemberFunctionDefinition$LAnalysisContext$ = MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$;

MemberFunctionDefinition.prototype.generateWrappersForDefaultParameters$ALCompileError$ = function (errors) {
	var $this = this;
	var origArgIndex;
	var formalArgs;
	var argExprs;
	var i;
	var defVal;
	var statement;
	var invocant;
	var methodRef;
	var callExpression;
	var wrapper;
	var this$0;
	var classDef$0;
	var _classDef$0;
	for (origArgIndex = 0; origArgIndex !== this._args.length; ++ origArgIndex) {
		if (this._args[origArgIndex]._defaultValue != null) {
			break;
		}
	}
	for (; origArgIndex !== this._args.length; ++ origArgIndex) {
		formalArgs = this._args.slice(0, origArgIndex).map((function (arg) {
			return new ArgumentDeclaration(arg._name, arg._type);
		}));
		argExprs = formalArgs.map((function (arg) {
			return new LocalExpression(arg._name, arg);
		}));
		for (i = origArgIndex; i !== this._args.length; ++ i) {
			this$0 = this._args[i];
			defVal = this$0._defaultValue;
			argExprs.push(defVal.clone$());
		}
		if (this._nameToken._value === "constructor") {
			statement = new ConstructorInvocationStatement(new Token$1("this", false), new ObjectType(this._classDef), argExprs);
		} else {
			invocant = ((this._flags & 8) === 0 ? new ThisExpression(new Token$1("this", false), this._classDef) : new ClassExpression(new Token$1(this._classDef.className$(), true), new ObjectType(this._classDef)));
			methodRef = new PropertyExpression(new Token$1(".", false), invocant, this._nameToken, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this));
			callExpression = new CallExpression(new Token$1("(", false), methodRef, argExprs);
			if (this._returnType != Type.voidType) {
				statement = new ReturnStatement(new Token$1("return", false), callExpression);
			} else {
				statement = new ExpressionStatement(callExpression);
			}
		}
		wrapper = new MemberFunctionDefinition(this._token, this._nameToken, this._flags | 1024 | 32768, this._returnType, formalArgs, [], [ statement ], [], this._lastTokenOfBody, this._docComment);
		classDef$0 = _classDef$0 = this._classDef;
		wrapper._classDef = classDef$0;
		_classDef$0._members.push(wrapper);
	}
};


function MemberFunctionDefinition$generateWrappersForDefaultParameters$LMemberFunctionDefinition$ALCompileError$($this, errors) {
	var origArgIndex;
	var formalArgs;
	var argExprs;
	var i;
	var defVal;
	var statement;
	var invocant;
	var methodRef;
	var callExpression;
	var wrapper;
	var this$0;
	var classDef$0;
	var _classDef$0;
	for (origArgIndex = 0; origArgIndex !== $this._args.length; ++ origArgIndex) {
		if ($this._args[origArgIndex]._defaultValue != null) {
			break;
		}
	}
	for (; origArgIndex !== $this._args.length; ++ origArgIndex) {
		formalArgs = $this._args.slice(0, origArgIndex).map((function (arg) {
			return new ArgumentDeclaration(arg._name, arg._type);
		}));
		argExprs = formalArgs.map((function (arg) {
			return new LocalExpression(arg._name, arg);
		}));
		for (i = origArgIndex; i !== $this._args.length; ++ i) {
			this$0 = $this._args[i];
			defVal = this$0._defaultValue;
			argExprs.push(defVal.clone$());
		}
		if ($this._nameToken._value === "constructor") {
			statement = new ConstructorInvocationStatement(new Token$1("this", false), new ObjectType($this._classDef), argExprs);
		} else {
			invocant = (($this._flags & 8) === 0 ? new ThisExpression(new Token$1("this", false), $this._classDef) : new ClassExpression(new Token$1($this._classDef.className$(), true), new ObjectType($this._classDef)));
			methodRef = new PropertyExpression(new Token$1(".", false), invocant, $this._nameToken, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this));
			callExpression = new CallExpression(new Token$1("(", false), methodRef, argExprs);
			if ($this._returnType != Type.voidType) {
				statement = new ReturnStatement(new Token$1("return", false), callExpression);
			} else {
				statement = new ExpressionStatement(callExpression);
			}
		}
		wrapper = new MemberFunctionDefinition($this._token, $this._nameToken, $this._flags | 1024 | 32768, $this._returnType, formalArgs, [], [ statement ], [], $this._lastTokenOfBody, $this._docComment);
		classDef$0 = _classDef$0 = $this._classDef;
		wrapper._classDef = classDef$0;
		_classDef$0._members.push(wrapper);
	}
};

MemberFunctionDefinition.generateWrappersForDefaultParameters$LMemberFunctionDefinition$ALCompileError$ = MemberFunctionDefinition$generateWrappersForDefaultParameters$LMemberFunctionDefinition$ALCompileError$;

MemberFunctionDefinition.prototype._fixupConstructor$LAnalysisContext$ = function (context) {
	var $this = this;
	var success;
	var isAlternate;
	var stmtIndex;
	var baseIndex;
	var baseClassType;
	var ctorStmt;
	var normalStatementFromIndex;
	var initProperties;
	var i;
	var onExpr;
	var canContinue;
	var insertStmtAt;
	var _statements$0;
	var _statements$1;
	success = true;
	isAlternate = false;
	if ((this._flags & 8192) !== 0) {
		context.errors.push(new CompileError(this._token, "constructor must not be a generator"));
		return;
	}
	stmtIndex = 0;
	if (0 < (_statements$1 = this._statements).length && _statements$1[0] instanceof ConstructorInvocationStatement && _statements$1[0]._ctorClassType.getClassDef$() == this._classDef) {
		isAlternate = true;
		++ stmtIndex;
	} else {
		for (baseIndex = 0; baseIndex <= this._classDef._implementTypes.length; ++ baseIndex) {
			baseClassType = (baseIndex === 0 ? this._classDef._extendType : this._classDef._implementTypes[baseIndex - 1]);
			if (baseClassType != null) {
				if (stmtIndex < (_statements$0 = this._statements).length && _statements$0[stmtIndex] instanceof ConstructorInvocationStatement && baseClassType._classDef == _statements$0[stmtIndex]._ctorClassType.getClassDef$()) {
					if (baseClassType._qualifiedName._token._value === "Object") {
						this._statements.splice(stmtIndex, 1);
					} else {
						++ stmtIndex;
					}
				} else {
					if (baseClassType._classDef.className$() === "Object") {
					} else {
						if (ClassDefinition$hasDefaultConstructor$LClassDefinition$(baseClassType._classDef)) {
							ctorStmt = new ConstructorInvocationStatement(this._token, baseClassType, []);
							this._statements.splice(stmtIndex, 0, ctorStmt);
							if (! Statement$analyze$LStatement$LAnalysisContext$(ctorStmt, context)) {
								throw new Error("logic flaw");
							}
							++ stmtIndex;
						} else {
							if (stmtIndex < this._statements.length) {
								context.errors.push(new CompileError(this._statements[stmtIndex].getToken$(), "constructor of class '" + (baseClassType._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(baseClassType._qualifiedName._token._value, baseClassType._typeArguments) : baseClassType._qualifiedName._token._value) + "' should be called prior to the statement"));
							} else {
								context.errors.push(new CompileError(this._token, "super class '" + (baseClassType._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(baseClassType._qualifiedName._token._value, baseClassType._typeArguments) : baseClassType._qualifiedName._token._value) + "' should be initialized explicitely (no default constructor)"));
							}
							success = false;
						}
					}
				}
			}
		}
	}
	for (; stmtIndex < this._statements.length; ++ stmtIndex) {
		if (! (this._statements[stmtIndex] instanceof ConstructorInvocationStatement)) {
			break;
		}
		context.errors.push(new CompileError(this._statements[stmtIndex].getToken$(), "constructors should be invoked in the order they are implemented"));
		success = false;
	}
	if (! success) {
		return;
	}
	if (isAlternate) {
		return;
	}
	normalStatementFromIndex = stmtIndex;
	initProperties = {};
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(this._classDef, (function (member) {
		if ((member._flags & 10) === 0) {
			initProperties[member._nameToken._value] = true;
		}
		return true;
	}));
	for (i = normalStatementFromIndex; i < this._statements.length; ++ i) {
		if (! (this._statements[i] instanceof ExpressionStatement)) {
			break;
		}
		function onExpr(expr) {
			var lhsExpr;
			if (expr instanceof AssignmentExpression && expr._token._value === "=" && (lhsExpr = expr._expr1) instanceof PropertyExpression && lhsExpr._expr instanceof ThisExpression) {
				initProperties[lhsExpr._identifierToken._value] = false;
				return true;
			} else {
				if (expr instanceof ThisExpression || expr instanceof FunctionExpression) {
					return false;
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}
		canContinue = Statement$forEachExpression$LStatement$F$LExpression$B$(this._statements[i], onExpr);
		if (! canContinue) {
			break;
		}
	}
	insertStmtAt = normalStatementFromIndex;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(this._classDef, (function (member) {
		var stmt;
		if ((member._flags & 10) === 0) {
			if (initProperties[member._nameToken._value]) {
				stmt = new ExpressionStatement(new AssignmentExpression(new Token$1("=", false), new PropertyExpression$0(new Token$1(".", false), new ThisExpression(new Token$1("this", false), $this._classDef), member._nameToken, [], member.getType$()), member._initialValue));
				$this._statements.splice(insertStmtAt++, 0, stmt);
			}
		}
		return true;
	}));
};


function MemberFunctionDefinition$_fixupConstructor$LMemberFunctionDefinition$LAnalysisContext$($this, context) {
	var success;
	var isAlternate;
	var stmtIndex;
	var baseIndex;
	var baseClassType;
	var ctorStmt;
	var normalStatementFromIndex;
	var initProperties;
	var i;
	var onExpr;
	var canContinue;
	var insertStmtAt;
	var _statements$0;
	var _statements$1;
	success = true;
	isAlternate = false;
	if (($this._flags & 8192) !== 0) {
		context.errors.push(new CompileError($this._token, "constructor must not be a generator"));
		return;
	}
	stmtIndex = 0;
	if (0 < (_statements$1 = $this._statements).length && _statements$1[0] instanceof ConstructorInvocationStatement && _statements$1[0]._ctorClassType.getClassDef$() == $this._classDef) {
		isAlternate = true;
		++ stmtIndex;
	} else {
		for (baseIndex = 0; baseIndex <= $this._classDef._implementTypes.length; ++ baseIndex) {
			baseClassType = (baseIndex === 0 ? $this._classDef._extendType : $this._classDef._implementTypes[baseIndex - 1]);
			if (baseClassType != null) {
				if (stmtIndex < (_statements$0 = $this._statements).length && _statements$0[stmtIndex] instanceof ConstructorInvocationStatement && baseClassType._classDef == _statements$0[stmtIndex]._ctorClassType.getClassDef$()) {
					if (baseClassType._qualifiedName._token._value === "Object") {
						$this._statements.splice(stmtIndex, 1);
					} else {
						++ stmtIndex;
					}
				} else {
					if (baseClassType._classDef.className$() === "Object") {
					} else {
						if (ClassDefinition$hasDefaultConstructor$LClassDefinition$(baseClassType._classDef)) {
							ctorStmt = new ConstructorInvocationStatement($this._token, baseClassType, []);
							$this._statements.splice(stmtIndex, 0, ctorStmt);
							if (! Statement$analyze$LStatement$LAnalysisContext$(ctorStmt, context)) {
								throw new Error("logic flaw");
							}
							++ stmtIndex;
						} else {
							if (stmtIndex < $this._statements.length) {
								context.errors.push(new CompileError($this._statements[stmtIndex].getToken$(), "constructor of class '" + (baseClassType._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(baseClassType._qualifiedName._token._value, baseClassType._typeArguments) : baseClassType._qualifiedName._token._value) + "' should be called prior to the statement"));
							} else {
								context.errors.push(new CompileError($this._token, "super class '" + (baseClassType._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(baseClassType._qualifiedName._token._value, baseClassType._typeArguments) : baseClassType._qualifiedName._token._value) + "' should be initialized explicitely (no default constructor)"));
							}
							success = false;
						}
					}
				}
			}
		}
	}
	for (; stmtIndex < $this._statements.length; ++ stmtIndex) {
		if (! ($this._statements[stmtIndex] instanceof ConstructorInvocationStatement)) {
			break;
		}
		context.errors.push(new CompileError($this._statements[stmtIndex].getToken$(), "constructors should be invoked in the order they are implemented"));
		success = false;
	}
	if (! success) {
		return;
	}
	if (isAlternate) {
		return;
	}
	normalStatementFromIndex = stmtIndex;
	initProperties = {};
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$($this._classDef, (function (member) {
		if ((member._flags & 10) === 0) {
			initProperties[member._nameToken._value] = true;
		}
		return true;
	}));
	for (i = normalStatementFromIndex; i < $this._statements.length; ++ i) {
		if (! ($this._statements[i] instanceof ExpressionStatement)) {
			break;
		}
		function onExpr(expr) {
			var lhsExpr;
			if (expr instanceof AssignmentExpression && expr._token._value === "=" && (lhsExpr = expr._expr1) instanceof PropertyExpression && lhsExpr._expr instanceof ThisExpression) {
				initProperties[lhsExpr._identifierToken._value] = false;
				return true;
			} else {
				if (expr instanceof ThisExpression || expr instanceof FunctionExpression) {
					return false;
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}
		canContinue = Statement$forEachExpression$LStatement$F$LExpression$B$($this._statements[i], onExpr);
		if (! canContinue) {
			break;
		}
	}
	insertStmtAt = normalStatementFromIndex;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$($this._classDef, (function (member) {
		var stmt;
		if ((member._flags & 10) === 0) {
			if (initProperties[member._nameToken._value]) {
				stmt = new ExpressionStatement(new AssignmentExpression(new Token$1("=", false), new PropertyExpression$0(new Token$1(".", false), new ThisExpression(new Token$1("this", false), $this._classDef), member._nameToken, [], member.getType$()), member._initialValue));
				$this._statements.splice(insertStmtAt++, 0, stmt);
			}
		}
		return true;
	}));
};

MemberFunctionDefinition._fixupConstructor$LMemberFunctionDefinition$LAnalysisContext$ = MemberFunctionDefinition$_fixupConstructor$LMemberFunctionDefinition$LAnalysisContext$;

MemberFunctionDefinition.prototype.getReturnType$ = function () {
	return this._returnType;
};


function MemberFunctionDefinition$getReturnType$LMemberFunctionDefinition$($this) {
	return $this._returnType;
};

MemberFunctionDefinition.getReturnType$LMemberFunctionDefinition$ = MemberFunctionDefinition$getReturnType$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.setReturnType$LType$ = function (type) {
	this._returnType = type;
};


function MemberFunctionDefinition$setReturnType$LMemberFunctionDefinition$LType$($this, type) {
	$this._returnType = type;
};

MemberFunctionDefinition.setReturnType$LMemberFunctionDefinition$LType$ = MemberFunctionDefinition$setReturnType$LMemberFunctionDefinition$LType$;

MemberFunctionDefinition.prototype.getArguments$ = function () {
	return this._args;
};


function MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$($this) {
	return $this._args;
};

MemberFunctionDefinition.getArguments$LMemberFunctionDefinition$ = MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.getArgumentTypes$ = function () {
	var argTypes;
	var i;
	argTypes = [];
	for (i = 0; i < this._args.length; ++ i) {
		argTypes[i] = this._args[i]._type;
	}
	return argTypes;
};


function MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this) {
	var argTypes;
	var i;
	argTypes = [];
	for (i = 0; i < $this._args.length; ++ i) {
		argTypes[i] = $this._args[i]._type;
	}
	return argTypes;
};

MemberFunctionDefinition.getArgumentTypes$LMemberFunctionDefinition$ = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.getFuncLocal$ = function () {
	return this._funcLocal;
};


function MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$($this) {
	return $this._funcLocal;
};

MemberFunctionDefinition.getFuncLocal$LMemberFunctionDefinition$ = MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.setFuncLocal$LLocalVariable$ = function (funcLocal) {
	this._funcLocal = funcLocal;
};


function MemberFunctionDefinition$setFuncLocal$LMemberFunctionDefinition$LLocalVariable$($this, funcLocal) {
	$this._funcLocal = funcLocal;
};

MemberFunctionDefinition.setFuncLocal$LMemberFunctionDefinition$LLocalVariable$ = MemberFunctionDefinition$setFuncLocal$LMemberFunctionDefinition$LLocalVariable$;

MemberFunctionDefinition.prototype.getParent$ = function () {
	return this._parent;
};


function MemberFunctionDefinition$getParent$LMemberFunctionDefinition$($this) {
	return $this._parent;
};

MemberFunctionDefinition.getParent$LMemberFunctionDefinition$ = MemberFunctionDefinition$getParent$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.setParent$LMemberFunctionDefinition$ = function (parent) {
	this._parent = parent;
};


function MemberFunctionDefinition$setParent$LMemberFunctionDefinition$LMemberFunctionDefinition$($this, parent) {
	$this._parent = parent;
};

MemberFunctionDefinition.setParent$LMemberFunctionDefinition$LMemberFunctionDefinition$ = MemberFunctionDefinition$setParent$LMemberFunctionDefinition$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.getLocals$ = function () {
	return this._locals;
};


function MemberFunctionDefinition$getLocals$LMemberFunctionDefinition$($this) {
	return $this._locals;
};

MemberFunctionDefinition.getLocals$LMemberFunctionDefinition$ = MemberFunctionDefinition$getLocals$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.getStatements$ = function () {
	return this._statements;
};


function MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$($this) {
	return $this._statements;
};

MemberFunctionDefinition.getStatements$LMemberFunctionDefinition$ = MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.getLocal$LAnalysisContext$S = function (context, name) {
	var i;
	var block;
	var j;
	var local;
	var arg;
	for (i = context.blockStack.length - 1; i >= 0; -- i) {
		block = context.blockStack[i].block;
		if (block instanceof MemberFunctionDefinition) {
			for (j = 0; j < block._locals.length; ++ j) {
				local = block._locals[j];
				if (local._name._value === name) {
					return local;
				}
			}
			for (j = 0; j < block._args.length; ++ j) {
				arg = block._args[j];
				if (arg._name._value === name) {
					return arg;
				}
			}
		} else {
			if (block instanceof CatchStatement) {
				local = block._local;
				if (local._name._value === name) {
					return local;
				}
			}
		}
	}
	return null;
};


function MemberFunctionDefinition$getLocal$LMemberFunctionDefinition$LAnalysisContext$S($this, context, name) {
	var i;
	var block;
	var j;
	var local;
	var arg;
	for (i = context.blockStack.length - 1; i >= 0; -- i) {
		block = context.blockStack[i].block;
		if (block instanceof MemberFunctionDefinition) {
			for (j = 0; j < block._locals.length; ++ j) {
				local = block._locals[j];
				if (local._name._value === name) {
					return local;
				}
			}
			for (j = 0; j < block._args.length; ++ j) {
				arg = block._args[j];
				if (arg._name._value === name) {
					return arg;
				}
			}
		} else {
			if (block instanceof CatchStatement) {
				local = block._local;
				if (local._name._value === name) {
					return local;
				}
			}
		}
	}
	return null;
};

MemberFunctionDefinition.getLocal$LMemberFunctionDefinition$LAnalysisContext$S = MemberFunctionDefinition$getLocal$LMemberFunctionDefinition$LAnalysisContext$S;

MemberFunctionDefinition.prototype.getType$ = function () {
	return ((this._flags & 8) !== 0 ? new StaticFunctionType(this._token, this._returnType, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this), false) : new MemberFunctionType(this._token, new ObjectType(this._classDef), this._returnType, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this), false));
};


MemberFunctionDefinition.prototype.deductTypeIfUnknown$LAnalysisContext$LResolvedFunctionType$ = function (context, type) {
	var i;
	var type$0;
	var type$1;
	var type$2;
	var _args$0;
	for (i = 0; i < this._args.length; ++ i) {
		if (this._args[i]._type == null) {
			break;
		}
	}
	if (i === this._args.length && this._returnType != null) {
		if (this._funcLocal != null) {
			type$0 = this.getType$();
			this._funcLocal._type = type$0;
		}
		return true;
	}
	if (type._argTypes.length !== this._args.length) {
		context.errors.push(new CompileError(this._token, "expected the function to have " + (type._argTypes.length + "") + " arguments, but found " + (this._args.length + "")));
		return false;
	} else {
		if ((_args$0 = this._args).length !== 0 && type._argTypes[_args$0.length - 1] instanceof VariableLengthArgumentType) {
			context.errors.push(new CompileError(this._token, "could not deduct function argument (left hand expression is a function with an variable-length argument)"));
			return false;
		}
	}
	for (i = 0; i < this._args.length; ++ i) {
		if (this._args[i]._type != null) {
			if (! this._args[i]._type.equals$LType$(type._argTypes[i])) {
				context.errors.push(new CompileError(this._token, "detected type conflict for argument '" + this._args[i]._name._value + "' (expected '" + type._argTypes[i].toString() + "' but found '" + this._args[i]._type.toString() + "'"));
				return false;
			}
		} else {
			type$1 = type._argTypes[i];
			this._args[i]._type = type$1;
		}
	}
	if (this._returnType != null) {
		if (! this._returnType.equals$LType$(type._returnType)) {
			context.errors.push(new CompileError(this._token, "detected return type conflict, expected '" + type._returnType.toString() + "' but found '" + this._returnType.toString() + "'"));
			return false;
		}
	} else {
		this._returnType = type._returnType;
	}
	if (this._funcLocal != null) {
		type$2 = this.getType$();
		this._funcLocal._type = type$2;
	}
	return true;
};


function MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$($this, context, type) {
	var i;
	var type$0;
	var type$1;
	var type$2;
	var _args$0;
	for (i = 0; i < $this._args.length; ++ i) {
		if ($this._args[i]._type == null) {
			break;
		}
	}
	if (i === $this._args.length && $this._returnType != null) {
		if ($this._funcLocal != null) {
			type$0 = $this.getType$();
			$this._funcLocal._type = type$0;
		}
		return true;
	}
	if (type._argTypes.length !== $this._args.length) {
		context.errors.push(new CompileError($this._token, "expected the function to have " + (type._argTypes.length + "") + " arguments, but found " + ($this._args.length + "")));
		return false;
	} else {
		if ((_args$0 = $this._args).length !== 0 && type._argTypes[_args$0.length - 1] instanceof VariableLengthArgumentType) {
			context.errors.push(new CompileError($this._token, "could not deduct function argument (left hand expression is a function with an variable-length argument)"));
			return false;
		}
	}
	for (i = 0; i < $this._args.length; ++ i) {
		if ($this._args[i]._type != null) {
			if (! $this._args[i]._type.equals$LType$(type._argTypes[i])) {
				context.errors.push(new CompileError($this._token, "detected type conflict for argument '" + $this._args[i]._name._value + "' (expected '" + type._argTypes[i].toString() + "' but found '" + $this._args[i]._type.toString() + "'"));
				return false;
			}
		} else {
			type$1 = type._argTypes[i];
			$this._args[i]._type = type$1;
		}
	}
	if ($this._returnType != null) {
		if (! $this._returnType.equals$LType$(type._returnType)) {
			context.errors.push(new CompileError($this._token, "detected return type conflict, expected '" + type._returnType.toString() + "' but found '" + $this._returnType.toString() + "'"));
			return false;
		}
	} else {
		$this._returnType = type._returnType;
	}
	if ($this._funcLocal != null) {
		type$2 = $this.getType$();
		$this._funcLocal._type = type$2;
	}
	return true;
};

MemberFunctionDefinition.deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$ = MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$;

MemberFunctionDefinition.prototype.forEachStatement$F$LStatement$B$ = function (cb) {
	return Util$forEachStatement$F$LStatement$B$ALStatement$(cb, this._statements);
};


function MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$($this, cb) {
	return Util$forEachStatement$F$LStatement$B$ALStatement$(cb, $this._statements);
};

MemberFunctionDefinition.forEachStatement$LMemberFunctionDefinition$F$LStatement$B$ = MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$;

function InstantiatedMemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
	MemberFunctionDefinition.call(this, token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment);
};

$__jsx_extend([InstantiatedMemberFunctionDefinition], MemberFunctionDefinition);
function TemplateFunctionDefinition(token, name, flags, typeArgs, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
	var $this = this;
	MemberFunctionDefinition.call(this, token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment);
	this._typeArgs = typeArgs.concat([]);
	this._instantiatedDefs = ({_list: [], _equalsCallback: (function (x, y) {
		var i;
		var x$len$0;
		for ((i = 0, x$len$0 = x.length); i < x$len$0; ++ i) {
			if (! x[i].equals$LType$(y[i])) {
				return false;
			}
		}
		return true;
	})});
	this._resolvedTypemap = {};
};

$__jsx_extend([TemplateFunctionDefinition], MemberFunctionDefinition);
$__jsx_merge_interface(TemplateFunctionDefinition, TemplateDefinition);

TemplateFunctionDefinition.prototype.getTypeArguments$ = function () {
	return this._typeArgs;
};


function TemplateFunctionDefinition$getTypeArguments$LTemplateFunctionDefinition$($this) {
	return $this._typeArgs;
};

TemplateFunctionDefinition.getTypeArguments$LTemplateFunctionDefinition$ = TemplateFunctionDefinition$getTypeArguments$LTemplateFunctionDefinition$;

TemplateFunctionDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var instantiated;
	var k;
	instantiated = new TemplateFunctionDefinition(this._token, this._nameToken, this._flags, this._typeArgs.concat([]), this._returnType, this._args.concat([]), this._locals, this._statements, this._closures, this._lastTokenOfBody, this._docComment);
	for (k in this._resolvedTypemap) {
		instantiated._resolvedTypemap[k] = this._resolvedTypemap[k];
	}
	for (k in instantiationContext.typemap) {
		instantiated._resolvedTypemap[k] = instantiationContext.typemap[k];
	}
	return instantiated;
};


TemplateFunctionDefinition.prototype.instantiateTemplateFunction$ALCompileError$LToken$ALType$ = function (errors, token, typeArgs) {
	var $this = this;
	var instantiated;
	var instantiationContext;
	var k;
	var analysisContext;
	var i;
	var classDef$0;
	var _classDef$0;
	instantiated = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$get$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$(this._instantiatedDefs, typeArgs);
	if (instantiated != null) {
		return instantiated;
	}
	instantiationContext = this.buildInstantiationContext$ALCompileError$LToken$ALToken$ALType$(errors, token, this._typeArgs, typeArgs);
	if (instantiationContext == null) {
		return null;
	}
	for (k in this._resolvedTypemap) {
		instantiationContext.typemap[k] = this._resolvedTypemap[k];
	}
	instantiated = MemberFunctionDefinition$_instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$(this, instantiationContext, (function (token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
		return new InstantiatedMemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment);
	}));
	if (instantiated == null) {
		return null;
	}
	classDef$0 = _classDef$0 = this._classDef;
	instantiated._classDef = classDef$0;
	_classDef$0._members.push(instantiated);
	analysisContext = ({errors: errors, parser: this._classDef._parser, postInstantiationCallback: (function (parser, classDef) {
		throw new Error("not implemented");
	}), funcDef: null, blockStack: null, statement: null});
	for (i = 0; i < instantiationContext.objectTypesUsed.length; ++ i) {
		instantiationContext.objectTypesUsed[i].resolveType$LAnalysisContext$(analysisContext);
	}
	MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(instantiated, analysisContext);
	TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$set$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$LMemberFunctionDefinition$(this._instantiatedDefs, typeArgs.concat([]), instantiated);
	return instantiated;
};


function TemplateFunctionDefinition$instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$($this, errors, token, typeArgs) {
	var instantiated;
	var instantiationContext;
	var k;
	var analysisContext;
	var i;
	var classDef$0;
	var _classDef$0;
	instantiated = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$get$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$($this._instantiatedDefs, typeArgs);
	if (instantiated != null) {
		return instantiated;
	}
	instantiationContext = $this.buildInstantiationContext$ALCompileError$LToken$ALToken$ALType$(errors, token, $this._typeArgs, typeArgs);
	if (instantiationContext == null) {
		return null;
	}
	for (k in $this._resolvedTypemap) {
		instantiationContext.typemap[k] = $this._resolvedTypemap[k];
	}
	instantiated = MemberFunctionDefinition$_instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$($this, instantiationContext, (function (token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
		return new InstantiatedMemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment);
	}));
	if (instantiated == null) {
		return null;
	}
	classDef$0 = _classDef$0 = $this._classDef;
	instantiated._classDef = classDef$0;
	_classDef$0._members.push(instantiated);
	analysisContext = ({errors: errors, parser: $this._classDef._parser, postInstantiationCallback: (function (parser, classDef) {
		throw new Error("not implemented");
	}), funcDef: null, blockStack: null, statement: null});
	for (i = 0; i < instantiationContext.objectTypesUsed.length; ++ i) {
		instantiationContext.objectTypesUsed[i].resolveType$LAnalysisContext$(analysisContext);
	}
	MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(instantiated, analysisContext);
	TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$set$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$LMemberFunctionDefinition$($this._instantiatedDefs, typeArgs.concat([]), instantiated);
	return instantiated;
};

TemplateFunctionDefinition.instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$ = TemplateFunctionDefinition$instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$;

function TemplateClassDefinition(token, className, flags, typeArgs, extendType, implementTypes, members, inners, templateInners, objectTypesUsed, docComment) {
	ClassDefinition.call(this, token, className, flags, extendType, implementTypes, members, inners, templateInners, objectTypesUsed, docComment);
	this._token = token;
	this._className = className;
	this._flags = flags;
	this._typeArgs = typeArgs.concat([]);
	ClassDefinition$_resetMembersClassDef$LClassDefinition$(this);
};

$__jsx_extend([TemplateClassDefinition], ClassDefinition);
$__jsx_merge_interface(TemplateClassDefinition, TemplateDefinition);

TemplateClassDefinition.prototype.getToken$ = function () {
	return this._token;
};


TemplateClassDefinition.prototype.className$ = function () {
	return this._className;
};


TemplateClassDefinition.prototype.flags$ = function () {
	return this._flags;
};


TemplateClassDefinition.prototype.getTypeArguments$ = function () {
	return this._typeArgs;
};


function TemplateClassDefinition$getTypeArguments$LTemplateClassDefinition$($this) {
	return $this._typeArgs;
};

TemplateClassDefinition.getTypeArguments$LTemplateClassDefinition$ = TemplateClassDefinition$getTypeArguments$LTemplateClassDefinition$;

TemplateClassDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var typemap;
	var key;
	var i;
	var context;
	var succeeded;
	var members;
	var member;
	var inners;
	var inner;
	var templateInners;
	var templateInner;
	var extendType;
	var type;
	var implementTypes;
	typemap = {};
	for (key in instantiationContext.typemap) {
		typemap[key] = instantiationContext.typemap[key];
	}
	for (i = 0; i < this._typeArgs.length; ++ i) {
		delete typemap[this._typeArgs[i]._value];
	}
	context = new InstantiationContext(instantiationContext.errors, typemap);
	succeeded = true;
	members = [];
	for (i = 0; i < this._members.length; ++ i) {
		member = this._members[i].instantiate$LInstantiationContext$(context);
		if (member == null) {
			succeeded = false;
		}
		members[i] = member;
	}
	inners = [];
	for (i = 0; i < this._inners.length; ++ i) {
		inner = this._inners[i].instantiate$LInstantiationContext$(context);
		if (inner == null) {
			succeeded = false;
		}
		inners[i] = inner;
	}
	templateInners = [];
	for (i = 0; i < this._templateInners.length; ++ i) {
		templateInner = this._templateInners[i].instantiate$LInstantiationContext$(context);
		if (templateInner == null) {
			succeeded = false;
		}
		templateInners[i] = templateInner;
	}
	if (! succeeded) {
		return null;
	}
	extendType = null;
	if (this._extendType != null) {
		type = this._extendType.instantiate$LInstantiationContext$(instantiationContext);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError(this._extendType._qualifiedName._token, "non-object type is not extensible"));
			return null;
		}
		extendType = type;
	}
	implementTypes = [];
	for (i = 0; i < this._implementTypes.length; ++ i) {
		type = this._implementTypes[i].instantiate$LInstantiationContext$(instantiationContext);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError(this._implementTypes[i]._qualifiedName._token, "non-object type is not extensible"));
			return null;
		}
		implementTypes[i] = type;
	}
	return new TemplateClassDefinition(this._token, this._className, this._flags, this._typeArgs, extendType, implementTypes, members, inners, templateInners, context.objectTypesUsed, this._docComment);
};


TemplateClassDefinition.prototype.instantiateTemplateClass$ALCompileError$LTemplateInstantiationRequest$ = function (errors, request) {
	var instantiationContext;
	var succeeded;
	var members;
	var i;
	var member;
	var inners;
	var inner;
	var templateInners;
	var templateInner;
	var extendType;
	var type;
	var implementTypes;
	var instantiatedDef;
	instantiationContext = this.buildInstantiationContext$ALCompileError$LToken$ALToken$ALType$(errors, request._token, this._typeArgs, request._typeArgs);
	if (instantiationContext == null) {
		return null;
	}
	succeeded = true;
	members = [];
	for (i = 0; i < this._members.length; ++ i) {
		member = this._members[i].instantiate$LInstantiationContext$(instantiationContext);
		if (member == null) {
			succeeded = false;
		}
		members[i] = member;
	}
	inners = [];
	for (i = 0; i < this._inners.length; ++ i) {
		inner = this._inners[i].instantiate$LInstantiationContext$(instantiationContext);
		if (inner == null) {
			succeeded = false;
		}
		inners[i] = inner;
	}
	templateInners = [];
	for (i = 0; i < this._templateInners.length; ++ i) {
		templateInner = this._templateInners[i].instantiate$LInstantiationContext$(instantiationContext);
		if (templateInner == null) {
			succeeded = false;
		}
		templateInners[i] = templateInner;
	}
	if (! succeeded) {
		return null;
	}
	extendType = null;
	if (this._extendType != null) {
		type = this._extendType.instantiate$LInstantiationContext$(instantiationContext);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError(this._extendType._qualifiedName._token, "non-object type is not extensible"));
			return null;
		}
		extendType = type;
	}
	implementTypes = [];
	for (i = 0; i < this._implementTypes.length; ++ i) {
		type = this._implementTypes[i].instantiate$LInstantiationContext$(instantiationContext);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError(this._implementTypes[i]._qualifiedName._token, "non-object type is not extensible"));
			return null;
		}
		implementTypes[i] = type;
	}
	instantiatedDef = new InstantiatedClassDefinition(this, request._typeArgs, extendType, implementTypes, members, inners, templateInners, instantiationContext.objectTypesUsed);
	return instantiatedDef;
};


function TemplateClassDefinition$instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$($this, errors, request) {
	var instantiationContext;
	var succeeded;
	var members;
	var i;
	var member;
	var inners;
	var inner;
	var templateInners;
	var templateInner;
	var extendType;
	var type;
	var implementTypes;
	var instantiatedDef;
	instantiationContext = $this.buildInstantiationContext$ALCompileError$LToken$ALToken$ALType$(errors, request._token, $this._typeArgs, request._typeArgs);
	if (instantiationContext == null) {
		return null;
	}
	succeeded = true;
	members = [];
	for (i = 0; i < $this._members.length; ++ i) {
		member = $this._members[i].instantiate$LInstantiationContext$(instantiationContext);
		if (member == null) {
			succeeded = false;
		}
		members[i] = member;
	}
	inners = [];
	for (i = 0; i < $this._inners.length; ++ i) {
		inner = $this._inners[i].instantiate$LInstantiationContext$(instantiationContext);
		if (inner == null) {
			succeeded = false;
		}
		inners[i] = inner;
	}
	templateInners = [];
	for (i = 0; i < $this._templateInners.length; ++ i) {
		templateInner = $this._templateInners[i].instantiate$LInstantiationContext$(instantiationContext);
		if (templateInner == null) {
			succeeded = false;
		}
		templateInners[i] = templateInner;
	}
	if (! succeeded) {
		return null;
	}
	extendType = null;
	if ($this._extendType != null) {
		type = $this._extendType.instantiate$LInstantiationContext$(instantiationContext);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError($this._extendType._qualifiedName._token, "non-object type is not extensible"));
			return null;
		}
		extendType = type;
	}
	implementTypes = [];
	for (i = 0; i < $this._implementTypes.length; ++ i) {
		type = $this._implementTypes[i].instantiate$LInstantiationContext$(instantiationContext);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError($this._implementTypes[i]._qualifiedName._token, "non-object type is not extensible"));
			return null;
		}
		implementTypes[i] = type;
	}
	instantiatedDef = new InstantiatedClassDefinition($this, request._typeArgs, extendType, implementTypes, members, inners, templateInners, instantiationContext.objectTypesUsed);
	return instantiatedDef;
};

TemplateClassDefinition.instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$ = TemplateClassDefinition$instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$;

function InstantiatedClassDefinition(templateClassDef, typeArguments, extendType, implementTypes, members, inners, templateInners, objectTypesUsed) {
	ClassDefinition.call(this, null, Type$templateTypeToString$SALType$(ClassDefinition$classFullName$LClassDefinition$(templateClassDef), typeArguments), templateClassDef._flags, extendType, implementTypes, members, inners, templateInners, objectTypesUsed, null);
	this._templateClassDef = templateClassDef;
	this._typeArguments = typeArguments;
};

$__jsx_extend([InstantiatedClassDefinition], ClassDefinition);
InstantiatedClassDefinition.prototype.getTemplateClass$ = function () {
	return this._templateClassDef;
};


function InstantiatedClassDefinition$getTemplateClass$LInstantiatedClassDefinition$($this) {
	return $this._templateClassDef;
};

InstantiatedClassDefinition.getTemplateClass$LInstantiatedClassDefinition$ = InstantiatedClassDefinition$getTemplateClass$LInstantiatedClassDefinition$;

InstantiatedClassDefinition.prototype.getTemplateClassName$ = function () {
	return this._templateClassDef._className;
};


function InstantiatedClassDefinition$getTemplateClassName$LInstantiatedClassDefinition$($this) {
	return $this._templateClassDef._className;
};

InstantiatedClassDefinition.getTemplateClassName$LInstantiatedClassDefinition$ = InstantiatedClassDefinition$getTemplateClassName$LInstantiatedClassDefinition$;

InstantiatedClassDefinition.prototype.getTypeArguments$ = function () {
	return this._typeArguments;
};


function InstantiatedClassDefinition$getTypeArguments$LInstantiatedClassDefinition$($this) {
	return $this._typeArguments;
};

InstantiatedClassDefinition.getTypeArguments$LInstantiatedClassDefinition$ = InstantiatedClassDefinition$getTypeArguments$LInstantiatedClassDefinition$;

InstantiatedClassDefinition.prototype.typeArgumentsAreEqual$ALType$ = function (typeArgs) {
	var i;
	var typeArgs$len$0;
	if (! (this._typeArguments.length === typeArgs.length)) {
		return false;
	}
	for ((i = 0, typeArgs$len$0 = typeArgs.length); i < typeArgs$len$0; ++ i) {
		if (! this._typeArguments[i].equals$LType$(typeArgs[i])) {
			return false;
		}
	}
	return true;
};


function InstantiatedClassDefinition$typeArgumentsAreEqual$LInstantiatedClassDefinition$ALType$($this, typeArgs) {
	var i;
	var typeArgs$len$0;
	if (! ($this._typeArguments.length === typeArgs.length)) {
		return false;
	}
	for ((i = 0, typeArgs$len$0 = typeArgs.length); i < typeArgs$len$0; ++ i) {
		if (! $this._typeArguments[i].equals$LType$(typeArgs[i])) {
			return false;
		}
	}
	return true;
};

InstantiatedClassDefinition.typeArgumentsAreEqual$LInstantiatedClassDefinition$ALType$ = InstantiatedClassDefinition$typeArgumentsAreEqual$LInstantiatedClassDefinition$ALType$;

InstantiatedClassDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	throw new Error("logic flaw");
};


function Type() {
};

$__jsx_extend([Type], Object);
Type.prototype.serialize$ = function () {
	return this.toString();
};


function Type$serialize$LType$($this) {
	return $this.toString();
};

Type.serialize$LType$ = Type$serialize$LType$;

Type.prototype.equals$LType$ = function (x) {
	return this == x;
};


Type.prototype.resolveIfNullable$ = function () {
	return (this instanceof NullableType ? this._baseType : this);
};


function Type$resolveIfNullable$LType$($this) {
	return ($this instanceof NullableType ? $this._baseType : $this);
};

Type.resolveIfNullable$LType$ = Type$resolveIfNullable$LType$;

Type.prototype.asAssignableType$ = function () {
	return this;
};


Type.prototype.toNullableType$ = function () {
	return (this instanceof PrimitiveType ? new NullableType(this) : this);
};


function Type$toNullableType$LType$($this) {
	return ($this instanceof PrimitiveType ? new NullableType($this) : $this);
};

Type.toNullableType$LType$ = Type$toNullableType$LType$;

Type.prototype.toNullableType$B = function (force) {
	return (force || this instanceof PrimitiveType ? new NullableType(this) : this);
};


function Type$toNullableType$LType$B($this, force) {
	return (force || $this instanceof PrimitiveType ? new NullableType($this) : $this);
};

Type.toNullableType$LType$B = Type$toNullableType$LType$B;

function Type$templateTypeToString$SALType$(parameterizedTypeName, typeArgs) {
	var s;
	var i;
	var typeArgs$len$0;
	s = parameterizedTypeName + ".<";
	for ((i = 0, typeArgs$len$0 = typeArgs.length); i < typeArgs$len$0; ++ i) {
		if (i !== 0) {
			s += ",";
		}
		s += typeArgs[i].toString();
	}
	s += ">";
	return s;
};

Type.templateTypeToString$SALType$ = Type$templateTypeToString$SALType$;

function Type$isIntegerOrNumber$LType$(type) {
	return type instanceof IntegerType || type instanceof NumberType;
};

Type.isIntegerOrNumber$LType$ = Type$isIntegerOrNumber$LType$;

function Type$calcLeastCommonAncestor$LType$LType$(type1, type2) {
	return Type$calcLeastCommonAncestor$LType$LType$B(type1, type2, false);
};

Type.calcLeastCommonAncestor$LType$LType$ = Type$calcLeastCommonAncestor$LType$LType$;

function Type$calcLeastCommonAncestor$LType$LType$B(type1, type2, acceptVariant) {
	var obj1;
	var obj2;
	var ifaces1;
	var candidates;
	var i;
	var iface;
	var uniquify;
	var isIntegerOrNumber$type$0;
	var isIntegerOrNumber$type$1;
	var this$0;
	if (type1.equals$LType$(type2)) {
		return type1;
	}
	if ((type1 instanceof IntegerType || type1 instanceof NumberType) && (type2 instanceof IntegerType || type2 instanceof NumberType)) {
		return Type.numberType;
	}
	if (Type.voidType.equals$LType$(type1) || Type.voidType.equals$LType$(type2)) {
		return null;
	}
	if (Type.variantType.equals$LType$(type1) || Type.variantType.equals$LType$(type2)) {
		return Type.variantType;
	}
	if (Type.nullType.equals$LType$(type1)) {
		return ((Type.nullType, type2 instanceof NullableType || type2 instanceof ObjectType || type2 instanceof VariantType || type2 instanceof StaticFunctionType) ? type2 : new NullableType(type2));
	}
	if (Type.nullType.equals$LType$(type2)) {
		return ((Type.nullType, type1 instanceof NullableType || type1 instanceof ObjectType || type1 instanceof VariantType || type1 instanceof StaticFunctionType) ? type1 : new NullableType(type1));
	}
	if ((type1 instanceof NullableType ? type1._baseType : type1) instanceof PrimitiveType || (type2 instanceof NullableType ? type2._baseType : type2) instanceof PrimitiveType) {
		if ((type1 instanceof NullableType ? type1._baseType : type1).equals$LType$(type2 instanceof NullableType ? type2._baseType : type2)) {
			return new NullableType(type1);
		} else {
			if ((isIntegerOrNumber$type$0 = (type1 instanceof NullableType ? type1._baseType : type1), isIntegerOrNumber$type$0 instanceof IntegerType || isIntegerOrNumber$type$0 instanceof NumberType) && (isIntegerOrNumber$type$1 = (type2 instanceof NullableType ? type2._baseType : type2), isIntegerOrNumber$type$1 instanceof IntegerType || isIntegerOrNumber$type$1 instanceof NumberType)) {
				return new NullableType(Type.numberType);
			} else {
				return (acceptVariant ? Type.variantType : null);
			}
		}
	}
	if ((type1 instanceof NullableType ? type1._baseType : type1) instanceof ObjectType && (type2 instanceof NullableType ? type2._baseType : type2) instanceof ObjectType) {
		obj1 = (type1 instanceof NullableType ? type1._baseType : type1);
		obj2 = (type2 instanceof NullableType ? type2._baseType : type2);
		ifaces1 = [];
		for (; ; ) {
			ifaces1 = ifaces1.concat(obj1._classDef._implementTypes.map((function (t) {
				return t;
			})));
			if (obj2.isConvertibleTo$LType$(obj1)) {
				break;
			}
			this$0 = obj1._classDef;
			obj1 = this$0._extendType;
		}
		if (obj1._classDef.className$() !== "Object") {
			return obj1;
		}
		candidates = [];
		for (i in ifaces1) {
			iface = ifaces1[i];
			do {
				if (obj2.isConvertibleTo$LType$(iface)) {
					candidates.push(iface);
					break;
				}
			} while (iface = iface._classDef._extendType);
		}
		function uniquify(list) {
			var result;
			var i;
			var j;
			result = [];
			for (i = 0; i < list.length; ++ i) {
				result.push(list[i]);
				for (j = i + 1; j < list.length; ++ j) {
					if (list[i].equals$LType$(list[j])) {
						result.pop();
						break;
					}
				}
			}
			return result;
		}
		candidates = uniquify(candidates);
		switch (candidates.length) {
		case 0:
			return obj1;
		case 1:
			return candidates[0];
		default:
			return null;
		}
	}
	return ((type1 instanceof NullableType ? type1._baseType : type1) instanceof FunctionType && (type2 instanceof NullableType ? type2._baseType : type2) instanceof FunctionType ? null : acceptVariant ? Type.variantType : null);
};

Type.calcLeastCommonAncestor$LType$LType$B = Type$calcLeastCommonAncestor$LType$LType$B;

function Type$calcLeastCommonAncestor$ALType$(types) {
	return Type$calcLeastCommonAncestor$ALType$B(types, false);
};

Type.calcLeastCommonAncestor$ALType$ = Type$calcLeastCommonAncestor$ALType$;

function Type$calcLeastCommonAncestor$ALType$B(types, acceptVariant) {
	var type;
	var i;
	var types$len$0;
	if (types.length === 0) {
		return null;
	}
	type = types[0];
	for ((i = 1, types$len$0 = types.length); i < types$len$0; ++ i) {
		type = Type$calcLeastCommonAncestor$LType$LType$B(type, types[i], acceptVariant);
		if (type == null) {
			return null;
		}
	}
	return type;
};

Type.calcLeastCommonAncestor$ALType$B = Type$calcLeastCommonAncestor$ALType$B;

function VoidType() {
};

$__jsx_extend([VoidType], Type);
VoidType.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	return this;
};


VoidType.prototype.isAssignable$ = function () {
	return false;
};


VoidType.prototype.isConvertibleTo$LType$ = function (type) {
	return false;
};


VoidType.prototype.getClassDef$ = function () {
	throw new Error("VoidType#getClassDef() is not supported");
};


VoidType.prototype.toString = function () {
	return "void";
};


function NullType() {
};

$__jsx_extend([NullType], Type);
NullType.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	return this;
};


NullType.prototype.isAssignable$ = function () {
	return false;
};


NullType.prototype.isConvertibleTo$LType$ = function (type) {
	return type instanceof NullableType || type instanceof ObjectType || type instanceof VariantType || type instanceof StaticFunctionType;
};


NullType.prototype.getClassDef$ = function () {
	throw new Error("NullType#getClassDef() is not supported");
};


NullType.prototype.toString = function () {
	return "null";
};


function PrimitiveType() {
};

$__jsx_extend([PrimitiveType], Type);
PrimitiveType.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	return this;
};


PrimitiveType.prototype.isAssignable$ = function () {
	return true;
};


function BooleanType() {
};

$__jsx_extend([BooleanType], PrimitiveType);
BooleanType.prototype.isConvertibleTo$LType$ = function (type) {
	type = (type instanceof NullableType ? type._baseType : type);
	return type instanceof BooleanType || type instanceof VariantType;
};


BooleanType.prototype.getClassDef$ = function () {
	return BooleanType._classDef;
};


BooleanType.prototype.toString = function () {
	return "boolean";
};


function IntegerType() {
};

$__jsx_extend([IntegerType], PrimitiveType);
IntegerType.prototype.isConvertibleTo$LType$ = function (type) {
	type = (type instanceof NullableType ? type._baseType : type);
	return type instanceof IntegerType || type instanceof NumberType || type instanceof VariantType;
};


IntegerType.prototype.getClassDef$ = function () {
	return NumberType._classDef;
};


IntegerType.prototype.toString = function () {
	return "int";
};


function NumberType() {
};

$__jsx_extend([NumberType], PrimitiveType);
NumberType.prototype.isConvertibleTo$LType$ = function (type) {
	type = (type instanceof NullableType ? type._baseType : type);
	return type instanceof IntegerType || type instanceof NumberType || type instanceof VariantType;
};


NumberType.prototype.getClassDef$ = function () {
	return NumberType._classDef;
};


NumberType.prototype.toString = function () {
	return "number";
};


function StringType() {
};

$__jsx_extend([StringType], PrimitiveType);
StringType.prototype.isConvertibleTo$LType$ = function (type) {
	type = (type instanceof NullableType ? type._baseType : type);
	return type instanceof StringType || type instanceof VariantType;
};


StringType.prototype.getClassDef$ = function () {
	return StringType._classDef;
};


StringType.prototype.toString = function () {
	return "string";
};


function VariantType() {
};

$__jsx_extend([VariantType], Type);
VariantType.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	return this;
};


VariantType.prototype.isAssignable$ = function () {
	return true;
};


VariantType.prototype.isConvertibleTo$LType$ = function (type) {
	type = (type instanceof NullableType ? type._baseType : type);
	return type instanceof VariantType;
};


VariantType.prototype.getClassDef$ = function () {
	throw new Error("VariantType#getClassDef() is not supported");
};


VariantType.prototype.toString = function () {
	return "variant";
};


function NullableType(type) {
	this._baseType = null;
	if (type.equals$LType$(Type.variantType)) {
		throw new Error("logic flaw, cannot create Nullable.<variant>");
	}
	this._baseType = (type instanceof NullableType ? type._baseType : type);
};

$__jsx_extend([NullableType], Type);
NullableType.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var baseType;
	var resolveIfNullable$this$0;
	baseType = (resolveIfNullable$this$0 = this._baseType, resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0).instantiate$LInstantiationContext$(instantiationContext);
	return (baseType instanceof PrimitiveType ? new NullableType(baseType) : baseType);
};


NullableType.prototype.equals$LType$ = function (x) {
	return x instanceof NullableType && this._baseType.equals$LType$(x._baseType);
};


NullableType.prototype.isConvertibleTo$LType$ = function (type) {
	return this._baseType.isConvertibleTo$LType$(type instanceof NullableType ? type._baseType : type);
};


NullableType.prototype.isAssignable$ = function () {
	return true;
};


NullableType.prototype.getClassDef$ = function () {
	return this._baseType.getClassDef$();
};


NullableType.prototype.getBaseType$ = function () {
	return this._baseType;
};


function NullableType$getBaseType$LNullableType$($this) {
	return $this._baseType;
};

NullableType.getBaseType$LNullableType$ = NullableType$getBaseType$LNullableType$;

NullableType.prototype.toString = function () {
	return "Nullable.<" + this._baseType.toString() + ">";
};


function VariableLengthArgumentType(type) {
	this._baseType = null;
	if (type instanceof VariableLengthArgumentType) {
		throw new Error("logic flaw");
	}
	this._baseType = type;
};

$__jsx_extend([VariableLengthArgumentType], Type);
VariableLengthArgumentType.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var baseType;
	baseType = this._baseType.instantiate$LInstantiationContext$(instantiationContext);
	return new VariableLengthArgumentType(baseType);
};


VariableLengthArgumentType.prototype.equals$LType$ = function (x) {
	return x instanceof VariableLengthArgumentType && this._baseType.equals$LType$(x._baseType);
};


VariableLengthArgumentType.prototype.isConvertibleTo$LType$ = function (type) {
	throw new Error("logic flaw");
};


VariableLengthArgumentType.prototype.isAssignable$ = function () {
	throw new Error("logic flaw");
};


VariableLengthArgumentType.prototype.getClassDef$ = function () {
	throw new Error("logic flaw");
};


VariableLengthArgumentType.prototype.getBaseType$ = function () {
	return this._baseType;
};


function VariableLengthArgumentType$getBaseType$LVariableLengthArgumentType$($this) {
	return $this._baseType;
};

VariableLengthArgumentType.getBaseType$LVariableLengthArgumentType$ = VariableLengthArgumentType$getBaseType$LVariableLengthArgumentType$;

VariableLengthArgumentType.prototype.toString = function () {
	return "..." + this._baseType.toString();
};


function ObjectType(classDef) {
	this._classDef = classDef;
};

$__jsx_extend([ObjectType], Type);
ObjectType.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	throw new Error("logic flaw; ObjectType is created during semantic analysis, after template instantiation");
};


ObjectType.prototype.equals$LType$ = function (x) {
	var that;
	var a;
	var b;
	if (! (x instanceof ObjectType)) {
		return false;
	}
	that = x;
	if (this instanceof ParsedObjectType && x instanceof ParsedObjectType && (this._classDef == null || that._classDef == null)) {
		a = this;
		b = that;
		return QualifiedName$equals$LQualifiedName$LQualifiedName$(a._qualifiedName, b._qualifiedName) && Util$typesAreEqual$ALType$ALType$(a._typeArguments, b._typeArguments);
	}
	return this._classDef == that._classDef;
};


ObjectType.prototype.resolveType$LAnalysisContext$ = function (context) {
	if (this._classDef == null) {
		throw new Error("logic flaw");
	}
};


ObjectType.prototype.isConvertibleTo$LType$ = function (type) {
	type = (type instanceof NullableType ? type._baseType : type);
	return (type instanceof VariantType ? true : ! (type instanceof ObjectType) ? false : this._classDef == null ? false : type._classDef == null ? false : ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$(this._classDef, type._classDef));
};


ObjectType.prototype.isAssignable$ = function () {
	return true;
};


ObjectType.prototype.getClassDef$ = function () {
	return this._classDef;
};


ObjectType.prototype.toString = function () {
	return (this._classDef != null ? this._classDef.className$() : "(null)");
};


function ParsedObjectType(qualifiedName, typeArgs) {
	ObjectType.call(this, null);
	this._qualifiedName = qualifiedName;
	this._typeArguments = typeArgs;
};

$__jsx_extend([ParsedObjectType], ObjectType);
ParsedObjectType.prototype.getToken$ = function () {
	return this._qualifiedName._token;
};


function ParsedObjectType$getToken$LParsedObjectType$($this) {
	return $this._qualifiedName._token;
};

ParsedObjectType.getToken$LParsedObjectType$ = ParsedObjectType$getToken$LParsedObjectType$;

ParsedObjectType.prototype.getQualifiedName$ = function () {
	return this._qualifiedName;
};


function ParsedObjectType$getQualifiedName$LParsedObjectType$($this) {
	return $this._qualifiedName;
};

ParsedObjectType.getQualifiedName$LParsedObjectType$ = ParsedObjectType$getQualifiedName$LParsedObjectType$;

ParsedObjectType.prototype.getTypeArguments$ = function () {
	return this._typeArguments;
};


function ParsedObjectType$getTypeArguments$LParsedObjectType$($this) {
	return $this._typeArguments;
};

ParsedObjectType.getTypeArguments$LParsedObjectType$ = ParsedObjectType$getTypeArguments$LParsedObjectType$;

ParsedObjectType.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var enclosingType;
	var actualType;
	var qualifiedName;
	var actualEnclosingType;
	var typeArgs;
	var i;
	var templateClassName;
	var objectType;
	var this$0;
	var _typeArguments$0;
	enclosingType = this._qualifiedName._enclosingType;
	if (enclosingType == null && this._typeArguments.length === 0) {
		actualType = instantiationContext.typemap[this._qualifiedName._token._value];
		if (actualType != null) {
			return actualType;
		}
		if (this._classDef == null) {
			instantiationContext.objectTypesUsed.push(this);
		}
		return this;
	}
	qualifiedName = this._qualifiedName;
	if (enclosingType != null) {
		actualEnclosingType = this._qualifiedName._enclosingType.instantiate$LInstantiationContext$(instantiationContext);
		if (! this._qualifiedName._enclosingType.equals$LType$(actualEnclosingType)) {
			qualifiedName = new QualifiedName$1(this._qualifiedName._token, actualEnclosingType);
		}
	}
	typeArgs = [];
	for (i = 0; i < this._typeArguments.length; ++ i) {
		if ((_typeArguments$0 = this._typeArguments)[i] instanceof ParsedObjectType && _typeArguments$0[i]._typeArguments.length !== 0) {
			actualType = this._typeArguments[i].instantiate$LInstantiationContext$(instantiationContext);
		} else {
			actualType = instantiationContext.typemap[this._typeArguments[i].toString()];
		}
		typeArgs[i] = (actualType != null ? actualType : this._typeArguments[i]);
		if (typeArgs[i] instanceof NullableType) {
			this$0 = qualifiedName._token;
			templateClassName = this$0._value;
			if (templateClassName === "Array" || templateClassName === "Map") {
				typeArgs[i] = typeArgs[i]._baseType;
			}
		}
	}
	objectType = new ParsedObjectType(qualifiedName, typeArgs);
	instantiationContext.objectTypesUsed.push(objectType);
	return objectType;
};


ParsedObjectType.prototype.resolveType$LAnalysisContext$ = function (context) {
	if (this._classDef == null) {
		this._classDef = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$(this._qualifiedName, context, this._typeArguments);
	}
};


ParsedObjectType.prototype.toString = function () {
	return (this._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$(this._qualifiedName._token._value, this._typeArguments) : this._qualifiedName._token._value);
};


function FunctionType() {
};

$__jsx_extend([FunctionType], Type);
FunctionType.prototype.isConvertibleTo$LType$ = function (type) {
	return false;
};


FunctionType.prototype.getClassDef$ = function () {
	return FunctionType._classDef;
};


FunctionType.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	throw new Error("logic flaw");
};


function FunctionChoiceType(types) {
	this._types = types;
};

$__jsx_extend([FunctionChoiceType], FunctionType);
FunctionChoiceType.prototype.isAssignable$ = function () {
	return false;
};


FunctionChoiceType.prototype.asAssignableType$ = function () {
	throw new Error("logic flaw");
};


FunctionChoiceType.prototype.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B = function (context, operatorToken, argTypes, isStatic) {
	var types;
	var i;
	var matched;
	var notes;
	var errors$0;
	types = this._types;
	for (i = 0; i < types.length; ++ i) {
		if (ResolvedFunctionType$_deduceByArgumentTypes$LResolvedFunctionType$LToken$ALType$BBALCompileNote$(types[i], types[i]._token, argTypes, isStatic, true, [  ])) {
			return types[i];
		}
	}
	matched = [];
	notes = [];
	for (i = 0; i < types.length; ++ i) {
		if (ResolvedFunctionType$_deduceByArgumentTypes$LResolvedFunctionType$LToken$ALType$BBALCompileNote$(types[i], types[i]._token, argTypes, isStatic, false, notes)) {
			matched.push(types[i]);
		}
	}
	switch (matched.length) {
	case 0:
		context.errors.push(new CompileError(operatorToken, (operatorToken._value === "[" ? "operator [] of type " + argTypes[0].toString() + " is not applicable to " + this.getObjectType$().toString() : "no function with matching arguments")));
		break;
	case 1:
		return matched[0];
	default:
		context.errors.push(new CompileError(operatorToken, "result of function resolution using the arguments is ambiguous"));
		break;
	}
	CompileError$addCompileNotes$LCompileError$ALCompileNote$((errors$0 = context.errors)[errors$0.length - 1], notes);
	return null;
};


FunctionChoiceType.prototype.getExpectedTypes$NB = function (numberOfArgs, isStatic) {
	var expected;
	var i;
	expected = [];
	for (i = 0; i < this._types.length; ++ i) {
		ResolvedFunctionType$_getExpectedTypes$LResolvedFunctionType$AALType$NB(this._types[i], expected, numberOfArgs, isStatic);
	}
	return expected;
};


FunctionChoiceType.prototype.toString = function () {
	var $this = this;
	return (this._types.length === 1 ? this._types[0].toString() : "<<multiple choices: " + this._types.map((function (f) {
		return f.toString();
	})).join(" | ") + ">>");
};


FunctionChoiceType.prototype.getObjectType$ = function () {
	throw new Error("logic flaw");
};


function ResolvedFunctionType(token, returnType, argTypes, isAssignable) {
	this._token = token;
	this._returnType = returnType;
	this._argTypes = argTypes;
	this._isAssignable = isAssignable;
};

$__jsx_extend([ResolvedFunctionType], FunctionType);
ResolvedFunctionType.prototype.setIsAssignable$B = function (isAssignable) {
	this._isAssignable = isAssignable;
	return this;
};


function ResolvedFunctionType$setIsAssignable$LResolvedFunctionType$B($this, isAssignable) {
	$this._isAssignable = isAssignable;
	return $this;
};

ResolvedFunctionType.setIsAssignable$LResolvedFunctionType$B = ResolvedFunctionType$setIsAssignable$LResolvedFunctionType$B;

ResolvedFunctionType.prototype.isAssignable$ = function () {
	return this._isAssignable;
};


ResolvedFunctionType.prototype.asAssignableType$ = function () {
	var this$0;
	this$0 = this._clone$();
	this$0._isAssignable = true;
	return this$0;
};


ResolvedFunctionType.prototype.getToken$ = function () {
	return this._token;
};


function ResolvedFunctionType$getToken$LResolvedFunctionType$($this) {
	return $this._token;
};

ResolvedFunctionType.getToken$LResolvedFunctionType$ = ResolvedFunctionType$getToken$LResolvedFunctionType$;

ResolvedFunctionType.prototype.getReturnType$ = function () {
	return this._returnType;
};


function ResolvedFunctionType$getReturnType$LResolvedFunctionType$($this) {
	return $this._returnType;
};

ResolvedFunctionType.getReturnType$LResolvedFunctionType$ = ResolvedFunctionType$getReturnType$LResolvedFunctionType$;

ResolvedFunctionType.prototype.getArgumentTypes$ = function () {
	return this._argTypes;
};


function ResolvedFunctionType$getArgumentTypes$LResolvedFunctionType$($this) {
	return $this._argTypes;
};

ResolvedFunctionType.getArgumentTypes$LResolvedFunctionType$ = ResolvedFunctionType$getArgumentTypes$LResolvedFunctionType$;

ResolvedFunctionType.prototype.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B = function (context, operatorToken, argTypes, isStatic) {
	var notes;
	var error;
	notes = [];
	if (! ResolvedFunctionType$_deduceByArgumentTypes$LResolvedFunctionType$LToken$ALType$BBALCompileNote$(this, this._token != null ? this._token : operatorToken, argTypes, isStatic, false, notes)) {
		error = new CompileError(operatorToken, (operatorToken._value === "[" ? "operator [] of type " + argTypes[0].toString() + " is not applicable to " + this.getObjectType$().toString() : "no function with matching arguments"));
		CompileError$addCompileNotes$LCompileError$ALCompileNote$(error, notes);
		context.errors.push(error);
		return null;
	}
	return this;
};


ResolvedFunctionType.prototype._deduceByArgumentTypes$LToken$ALType$BBALCompileNote$ = function (token, argTypes, isStatic, exact, notes) {
	var $this = this;
	var compareArg;
	var vargType;
	var i;
	var _argTypes$0;
	var _argTypes$1;
	compareArg = (function (formal, actual) {
		return (formal.equals$LType$(actual) ? true : ! exact && actual.isConvertibleTo$LType$(formal) ? true : false);
	});
	if (this instanceof StaticFunctionType !== isStatic) {
		if (isStatic) {
			notes.push(new CompileNote(token, 'candidate function not viable: expected a static function, but got a member function'));
		} else {
			notes.push(new CompileNote(token, 'candidate function not viable: expected a member function, but got a static function'));
		}
		return false;
	}
	if ((_argTypes$1 = this._argTypes).length !== 0 && _argTypes$1[_argTypes$1.length - 1] instanceof VariableLengthArgumentType) {
		vargType = (_argTypes$0 = this._argTypes)[_argTypes$0.length - 1];
		if (argTypes.length < _argTypes$0.length - 1) {
			notes.push(new CompileNote(token, 'candidate function not viable: wrong number of arguments'));
			return false;
		}
		for (i = 0; i < this._argTypes.length - 1; ++ i) {
			if (! compareArg(this._argTypes[i], argTypes[i])) {
				notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ argTypes[i].toString(), this._argTypes[i].toString(), Util$toOrdinal$N(i + 1) ])));
				return false;
			}
		}
		if (argTypes[i] instanceof VariableLengthArgumentType && argTypes.length === this._argTypes.length) {
			if (! compareArg(this._argTypes[i]._baseType, argTypes[i]._baseType)) {
				notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ argTypes[i]._baseType.toString(), this._argTypes[i]._baseType.toString(), Util$toOrdinal$N(i + 1) ])));
				return false;
			}
		} else {
			for (; i < argTypes.length; ++ i) {
				if (! compareArg(vargType._baseType, argTypes[i])) {
					notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ argTypes[i].toString(), vargType._baseType.toString(), Util$toOrdinal$N(i + 1) ])));
					return false;
				}
			}
		}
	} else {
		if (argTypes.length !== this._argTypes.length) {
			notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: wrong number of arguments (%1 for %2)', [ argTypes.length + "", this._argTypes.length + "" ])));
			return false;
		}
		for (i = 0; i < argTypes.length; ++ i) {
			if (! compareArg(this._argTypes[i], argTypes[i])) {
				notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ argTypes[i].toString(), this._argTypes[i].toString(), Util$toOrdinal$N(i + 1) ])));
				return false;
			}
		}
	}
	return true;
};


function ResolvedFunctionType$_deduceByArgumentTypes$LResolvedFunctionType$LToken$ALType$BBALCompileNote$($this, token, argTypes, isStatic, exact, notes) {
	var compareArg;
	var vargType;
	var i;
	var _argTypes$0;
	var _argTypes$1;
	compareArg = (function (formal, actual) {
		return (formal.equals$LType$(actual) ? true : ! exact && actual.isConvertibleTo$LType$(formal) ? true : false);
	});
	if ($this instanceof StaticFunctionType !== isStatic) {
		if (isStatic) {
			notes.push(new CompileNote(token, 'candidate function not viable: expected a static function, but got a member function'));
		} else {
			notes.push(new CompileNote(token, 'candidate function not viable: expected a member function, but got a static function'));
		}
		return false;
	}
	if ((_argTypes$1 = $this._argTypes).length !== 0 && _argTypes$1[_argTypes$1.length - 1] instanceof VariableLengthArgumentType) {
		vargType = (_argTypes$0 = $this._argTypes)[_argTypes$0.length - 1];
		if (argTypes.length < _argTypes$0.length - 1) {
			notes.push(new CompileNote(token, 'candidate function not viable: wrong number of arguments'));
			return false;
		}
		for (i = 0; i < $this._argTypes.length - 1; ++ i) {
			if (! compareArg($this._argTypes[i], argTypes[i])) {
				notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ argTypes[i].toString(), $this._argTypes[i].toString(), Util$toOrdinal$N(i + 1) ])));
				return false;
			}
		}
		if (argTypes[i] instanceof VariableLengthArgumentType && argTypes.length === $this._argTypes.length) {
			if (! compareArg($this._argTypes[i]._baseType, argTypes[i]._baseType)) {
				notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ argTypes[i]._baseType.toString(), $this._argTypes[i]._baseType.toString(), Util$toOrdinal$N(i + 1) ])));
				return false;
			}
		} else {
			for (; i < argTypes.length; ++ i) {
				if (! compareArg(vargType._baseType, argTypes[i])) {
					notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ argTypes[i].toString(), vargType._baseType.toString(), Util$toOrdinal$N(i + 1) ])));
					return false;
				}
			}
		}
	} else {
		if (argTypes.length !== $this._argTypes.length) {
			notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: wrong number of arguments (%1 for %2)', [ argTypes.length + "", $this._argTypes.length + "" ])));
			return false;
		}
		for (i = 0; i < argTypes.length; ++ i) {
			if (! compareArg($this._argTypes[i], argTypes[i])) {
				notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ argTypes[i].toString(), $this._argTypes[i].toString(), Util$toOrdinal$N(i + 1) ])));
				return false;
			}
		}
	}
	return true;
};

ResolvedFunctionType._deduceByArgumentTypes$LResolvedFunctionType$LToken$ALType$BBALCompileNote$ = ResolvedFunctionType$_deduceByArgumentTypes$LResolvedFunctionType$LToken$ALType$BBALCompileNote$;

ResolvedFunctionType.prototype.getExpectedTypes$NB = function (numberOfArgs, isStatic) {
	var expected;
	expected = [];
	ResolvedFunctionType$_getExpectedTypes$LResolvedFunctionType$AALType$NB(this, expected, numberOfArgs, isStatic);
	return expected;
};


ResolvedFunctionType.prototype._getExpectedTypes$AALType$NB = function (expected, numberOfArgs, isStatic) {
	var $this = this;
	var argTypes;
	var i;
	var hasCallback;
	var callbackArgTypes;
	var _argTypes$0;
	if (this instanceof StaticFunctionType !== isStatic) {
		return;
	}
	argTypes = [];
	if ((_argTypes$0 = this._argTypes).length > 0 && numberOfArgs >= _argTypes$0.length && _argTypes$0[_argTypes$0.length - 1] instanceof VariableLengthArgumentType) {
		for (i = 0; i < numberOfArgs; ++ i) {
			if (i < this._argTypes.length - 1) {
				argTypes[i] = this._argTypes[i];
			} else {
				argTypes[i] = this._argTypes[this._argTypes.length - 1]._baseType;
			}
		}
	} else {
		if (this._argTypes.length === numberOfArgs) {
			argTypes = this._argTypes;
		} else {
			return;
		}
	}
	hasCallback = false;
	callbackArgTypes = argTypes.map((function (argType) {
		var typeName;
		var getTemplateClassName$this$0;
		typeName = '';
		if (argType instanceof StaticFunctionType || argType instanceof ObjectType && argType.getClassDef$() instanceof InstantiatedClassDefinition && ((typeName = (getTemplateClassName$this$0 = argType.getClassDef$(), getTemplateClassName$this$0._templateClassDef._className)) === 'Array' || typeName === 'Map')) {
			hasCallback = true;
			return argType;
		} else {
			return null;
		}
	}));
	if (hasCallback) {
		expected.push(callbackArgTypes);
	}
};


function ResolvedFunctionType$_getExpectedTypes$LResolvedFunctionType$AALType$NB($this, expected, numberOfArgs, isStatic) {
	var argTypes;
	var i;
	var hasCallback;
	var callbackArgTypes;
	var _argTypes$0;
	if ($this instanceof StaticFunctionType !== isStatic) {
		return;
	}
	argTypes = [];
	if ((_argTypes$0 = $this._argTypes).length > 0 && numberOfArgs >= _argTypes$0.length && _argTypes$0[_argTypes$0.length - 1] instanceof VariableLengthArgumentType) {
		for (i = 0; i < numberOfArgs; ++ i) {
			if (i < $this._argTypes.length - 1) {
				argTypes[i] = $this._argTypes[i];
			} else {
				argTypes[i] = $this._argTypes[$this._argTypes.length - 1]._baseType;
			}
		}
	} else {
		if ($this._argTypes.length === numberOfArgs) {
			argTypes = $this._argTypes;
		} else {
			return;
		}
	}
	hasCallback = false;
	callbackArgTypes = argTypes.map((function (argType) {
		var typeName;
		var getTemplateClassName$this$0;
		typeName = '';
		if (argType instanceof StaticFunctionType || argType instanceof ObjectType && argType.getClassDef$() instanceof InstantiatedClassDefinition && ((typeName = (getTemplateClassName$this$0 = argType.getClassDef$(), getTemplateClassName$this$0._templateClassDef._className)) === 'Array' || typeName === 'Map')) {
			hasCallback = true;
			return argType;
		} else {
			return null;
		}
	}));
	if (hasCallback) {
		expected.push(callbackArgTypes);
	}
};

ResolvedFunctionType._getExpectedTypes$LResolvedFunctionType$AALType$NB = ResolvedFunctionType$_getExpectedTypes$LResolvedFunctionType$AALType$NB;

ResolvedFunctionType.prototype.toString = function () {
	var args;
	var i;
	var s;
	args = [];
	for (i = 0; i < this._argTypes.length; ++ i) {
		if (this._argTypes[i] == null) {
		} else {
			if (this._argTypes[i] instanceof VariableLengthArgumentType) {
				args[i] = "... : " + this._argTypes[i]._baseType.toString();
			} else {
				args[i] = ": " + this._argTypes[i].toString();
			}
		}
	}
	s = this._toStringPrefix$() + "function (" + args.join(", ") + ")";
	if (this._returnType != null) {
		s += " : " + this._returnType.toString();
	}
	return s;
};


ResolvedFunctionType.prototype.getObjectType$ = function () {
	throw new Error("logic flaw");
};


function StaticFunctionType(token, returnType, argTypes, isAssignable) {
	this._token = token;
	this._returnType = returnType;
	this._argTypes = argTypes;
	this._isAssignable = isAssignable;
};

$__jsx_extend([StaticFunctionType], ResolvedFunctionType);
StaticFunctionType.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var returnType;
	var argTypes;
	var i;
	returnType = this._returnType.instantiate$LInstantiationContext$(instantiationContext);
	if (returnType == null) {
		return null;
	}
	argTypes = [];
	for (i = 0; i < this._argTypes.length; ++ i) {
		if ((argTypes[i] = this._argTypes[i].instantiate$LInstantiationContext$(instantiationContext)) == null) {
			return null;
		}
	}
	return new StaticFunctionType(this._token, returnType, argTypes, this._isAssignable);
};


StaticFunctionType.prototype.equals$LType$ = function (x) {
	return x instanceof StaticFunctionType && this._returnType.equals$LType$(x._returnType) && Util$typesAreEqual$ALType$ALType$(this._argTypes, x._argTypes);
};


StaticFunctionType.prototype._clone$ = function () {
	return new StaticFunctionType(this._token, this._returnType, this._argTypes, this._isAssignable);
};


StaticFunctionType.prototype.isConvertibleTo$LType$ = function (type) {
	type = (type instanceof NullableType ? type._baseType : type);
	return (type instanceof VariantType ? true : ! (type instanceof StaticFunctionType) ? false : ! this._returnType.equals$LType$(type._returnType) ? false : ResolvedFunctionType$_deduceByArgumentTypes$LResolvedFunctionType$LToken$ALType$BBALCompileNote$(this, type._token, type._argTypes, true, true, [  ]));
};


StaticFunctionType.prototype._toStringPrefix$ = function () {
	return "";
};


StaticFunctionType.prototype.getObjectType$ = function () {
	throw new Error("logic flaw");
};


function MemberFunctionType(token, objectType, returnType, argTypes, isAssignable) {
	this._token = token;
	this._returnType = returnType;
	this._argTypes = argTypes;
	this._isAssignable = isAssignable;
	this._objectType = objectType;
};

$__jsx_extend([MemberFunctionType], ResolvedFunctionType);
MemberFunctionType.prototype.equals$LType$ = function (x) {
	return x instanceof MemberFunctionType && this._objectType == x._objectType && this._returnType.equals$LType$(x._returnType) && Util$typesAreEqual$ALType$ALType$(this._argTypes, x._argTypes);
};


MemberFunctionType.prototype._clone$ = function () {
	return new MemberFunctionType(this._token, this._objectType, this._returnType, this._argTypes, this._isAssignable);
};


MemberFunctionType.prototype._toStringPrefix$ = function () {
	return this._objectType.toString() + ".";
};


MemberFunctionType.prototype.getObjectType$ = function () {
	return this._objectType;
};


function CompletionRequest(lineNumber, columnOffset) {
	this._lineNumber = lineNumber;
	this._columnOffest = columnOffset;
	this._candidates = [];
};

$__jsx_extend([CompletionRequest], Object);
function CompletionRequest$getLineNumber$LCompletionRequest$($this) {
	return $this._lineNumber;
};

CompletionRequest.getLineNumber$LCompletionRequest$ = CompletionRequest$getLineNumber$LCompletionRequest$;

function CompletionRequest$getColumnOffset$LCompletionRequest$($this) {
	return $this._columnOffest;
};

CompletionRequest.getColumnOffset$LCompletionRequest$ = CompletionRequest$getColumnOffset$LCompletionRequest$;

function CompletionRequest$isInRange$LCompletionRequest$NNN($this, lineNumber, columnOffset, length) {
	return (lineNumber !== $this._lineNumber ? -1 : columnOffset <= $this._columnOffest && $this._columnOffest <= columnOffset + length ? $this._columnOffest - columnOffset : -1);
};

CompletionRequest.isInRange$LCompletionRequest$NNN = CompletionRequest$isInRange$LCompletionRequest$NNN;

function CompletionRequest$pushCandidates$LCompletionRequest$LCompletionCandidates$($this, candidates) {
	$this._candidates.push(candidates);
};

CompletionRequest.pushCandidates$LCompletionRequest$LCompletionCandidates$ = CompletionRequest$pushCandidates$LCompletionRequest$LCompletionCandidates$;

function CompletionRequest$getCandidates$LCompletionRequest$($this) {
	var seen;
	var results;
	var this$0;
	var i$0;
	seen = {};
	results = [];
	this$0 = $this._candidates;
	for (i$0 in this$0) {
		(function (candidates) {
			var rawCandidates;
			var prefix;
			var i$0;
			rawCandidates = [];
			candidates.getCandidates$AHX(rawCandidates);
			prefix = candidates._prefix;
			for (i$0 in rawCandidates) {
				(function (s) {
					var word;
					var left;
					var identity;
					word = s.word + "";
					if (prefix === "" && word.substring(0, 2) === "__" && word !== "__noconvert__" && word !== "undefined") {
					} else {
						if (word.substring(0, prefix.length) === prefix) {
							left = word.substring(prefix.length);
							if (left.length === 0) {
								return;
							}
							identity = JSON.stringify([ left, s.args ]);
							if (! $__jsx_ObjectHasOwnProperty.call(seen, identity)) {
								seen[identity] = true;
								if (word !== left) {
									s.partialWord = left;
								}
								delete s.kind;
								results.push(s);
							}
						}
					}
				})(rawCandidates[i$0]);
			}
		})(this$0[i$0]);
	}
	return results;
};

CompletionRequest.getCandidates$LCompletionRequest$ = CompletionRequest$getCandidates$LCompletionRequest$;

function CompletionCandidates() {
	this._prefix = null;
};

$__jsx_extend([CompletionCandidates], Object);
CompletionCandidates.prototype.getPrefix$ = function () {
	return this._prefix;
};


function CompletionCandidates$getPrefix$LCompletionCandidates$($this) {
	return $this._prefix;
};

CompletionCandidates.getPrefix$LCompletionCandidates$ = CompletionCandidates$getPrefix$LCompletionCandidates$;

CompletionCandidates.prototype.setPrefix$S = function (prefix) {
	this._prefix = prefix;
	return this;
};


function CompletionCandidates$setPrefix$LCompletionCandidates$S($this, prefix) {
	$this._prefix = prefix;
	return $this;
};

CompletionCandidates.setPrefix$LCompletionCandidates$S = CompletionCandidates$setPrefix$LCompletionCandidates$S;

function CompletionCandidates$makeClassCandidate$LClassDefinition$(classDef) {
	var data;
	var docComment;
	var this$0;
	var this$1;
	data = {};
	data.word = classDef.className$();
	this$0 = classDef.getToken$();
	data.definedFilename = this$0._filename;
	this$1 = classDef.getToken$();
	data.definedLineNumber = this$1._lineNumber;
	if ((classDef.flags$() & 64) !== 0) {
		data.kind = "interface";
	} else {
		if ((classDef.flags$() & 128) !== 0) {
			data.kind = "mixin";
		} else {
			data.kind = "class";
		}
	}
	docComment = classDef._docComment;
	if (docComment) {
		data.doc = docComment.getDescription$();
	}
	return data;
};

CompletionCandidates.makeClassCandidate$LClassDefinition$ = CompletionCandidates$makeClassCandidate$LClassDefinition$;

function CompletionCandidates$_addClasses$AHXLParser$F$LClassDefinition$B$(candidates, parser, autoCompleteMatchCb) {
	var this$0;
	var i$0;
	var this$1;
	var i$1;
	this$0 = parser._classDefs;
	for (i$0 in this$0) {
		(function (classDef) {
			if (classDef instanceof InstantiatedClassDefinition) {
			} else {
				if (autoCompleteMatchCb == null || autoCompleteMatchCb(classDef)) {
					candidates.push(CompletionCandidates$makeClassCandidate$LClassDefinition$(classDef));
				}
			}
		})(this$0[i$0]);
	}
	this$1 = parser._templateClassDefs;
	for (i$1 in this$1) {
		(function (classDef) {
			if (autoCompleteMatchCb == null || autoCompleteMatchCb(classDef)) {
				candidates.push(CompletionCandidates$makeClassCandidate$LClassDefinition$(classDef));
			}
		})(this$1[i$1]);
	}
};

CompletionCandidates._addClasses$AHXLParser$F$LClassDefinition$B$ = CompletionCandidates$_addClasses$AHXLParser$F$LClassDefinition$B$;

function CompletionCandidates$_addImportedClasses$AHXLImport$F$LClassDefinition$B$(candidates, imprt, autoCompleteMatchCb) {
	var classNames;
	var i$0;
	var this$0;
	var i$1;
	var className$0;
	var data$0;
	var parser$0;
	classNames = Import$getClassNames$LImport$(imprt);
	if (classNames != null) {
		for (i$0 in classNames) {
			className$0 = classNames[i$0];
			data$0 = {};
			data$0.word = className$0;
			data$0.kind = "class";
			candidates.push(data$0);
		}
	} else {
		this$0 = imprt._sourceParsers;
		for (i$1 in this$0) {
			parser$0 = this$0[i$1];
			CompletionCandidates$_addClasses$AHXLParser$F$LClassDefinition$B$(candidates, parser$0, autoCompleteMatchCb);
		}
	}
};

CompletionCandidates._addImportedClasses$AHXLImport$F$LClassDefinition$B$ = CompletionCandidates$_addImportedClasses$AHXLImport$F$LClassDefinition$B$;

function KeywordCompletionCandidate(expected) {
	this._prefix = null;
	this._expected = expected;
};

$__jsx_extend([KeywordCompletionCandidate], CompletionCandidates);
KeywordCompletionCandidate.prototype.getCandidates$AHX = function (candidates) {
	var data;
	data = {};
	data.word = this._expected;
	data.kind = "keyword";
	candidates.push(data);
};


function CompletionCandidatesOfTopLevel(parser, autoCompleteMatchCb) {
	this._prefix = null;
	this._parser = parser;
	this._autoCompleteMatchCb = autoCompleteMatchCb;
};

$__jsx_extend([CompletionCandidatesOfTopLevel], CompletionCandidates);
CompletionCandidatesOfTopLevel.prototype.getCandidates$AHX = function (candidates) {
	var i;
	var imprt;
	var alias;
	var data;
	CompletionCandidates$_addClasses$AHXLParser$F$LClassDefinition$B$(candidates, this._parser, this._autoCompleteMatchCb);
	for (i = 0; i < this._parser._imports.length; ++ i) {
		imprt = this._parser._imports[i];
		alias = (imprt._aliasToken ? imprt._aliasToken._value : null);
		if (alias != null) {
			data = {};
			data.word = alias;
			data.kind = "alias";
			candidates.push(data);
		} else {
			CompletionCandidates$_addImportedClasses$AHXLImport$F$LClassDefinition$B$(candidates, imprt, this._autoCompleteMatchCb);
		}
	}
};


function _CompletionCandidatesWithLocal(parser) {
	var $this = this;
	CompletionCandidatesOfTopLevel.call(this, parser, null);
	this._locals = [];
	Parser$_forEachScope$LParser$F$LLocalVariable$ALLocalVariable$ALArgumentDeclaration$B$(parser, (function (funcName, locals, args) {
		var i;
		if (funcName != null) {
			$this._locals = $this._locals.concat([ funcName ]);
		}
		$this._locals = $this._locals.concat(locals);
		for (i in args) {
			$this._locals.push(args[i]);
		}
		return true;
	}));
};

$__jsx_extend([_CompletionCandidatesWithLocal], CompletionCandidatesOfTopLevel);
_CompletionCandidatesWithLocal.prototype.getCandidates$AHX = function (candidates) {
	var $this = this;
	var this$0;
	var i$0;
	this$0 = this._locals;
	for (i$0 in this$0) {
		(function (local) {
			var data;
			var type;
			var this$0;
			var this$1;
			var this$2;
			data = {};
			this$0 = local._name;
			data.word = this$0._value;
			data.kind = 'variable';
			this$1 = local._name;
			data.definedFilename = this$1._filename;
			this$2 = local._name;
			data.definedLineNumber = this$2._lineNumber;
			type = local._type;
			if (type != null) {
				data.type = type.toString();
			}
			candidates.push(data);
		})(this$0[i$0]);
	}
	CompletionCandidatesOfTopLevel.prototype.getCandidates$AHX.call(this, candidates);
};


function _CompletionCandidatesOfNamespace(imprt, autoCompleteMatchCb) {
	this._prefix = null;
	this._import = imprt;
	this._autoCompleteMatchCb = autoCompleteMatchCb;
};

$__jsx_extend([_CompletionCandidatesOfNamespace], CompletionCandidates);
_CompletionCandidatesOfNamespace.prototype.getCandidates$AHX = function (candidates) {
	CompletionCandidates$_addImportedClasses$AHXLImport$F$LClassDefinition$B$(candidates, this._import, this._autoCompleteMatchCb);
};


function _CompletionCandidatesOfProperty(expr) {
	this._prefix = null;
	this._expr = expr;
};

$__jsx_extend([_CompletionCandidatesOfProperty], CompletionCandidates);
_CompletionCandidatesOfProperty.prototype.getCandidates$AHX = function (candidates) {
	var $this = this;
	var type;
	var classDef;
	var isStatic;
	type = this._expr.getType$();
	if (type == null) {
		return;
	}
	type = (type instanceof NullableType ? type._baseType : type);
	if (type.equals$LType$(Type.voidType) || type.equals$LType$(Type.nullType) || type.equals$LType$(Type.variantType)) {
		return;
	}
	classDef = type.getClassDef$();
	if (classDef == null) {
		return;
	}
	isStatic = this._expr.isClassSpecifier$();
	ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(classDef, (function (c) {
		ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(c, (function (member) {
			if (((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_STATIC) !== 0) === isStatic) {
				if (! isStatic && MemberDefinition$name$LMemberDefinition$(member) === "constructor") {
					return true;
				}
				candidates.push(_CompletionCandidatesOfProperty$_makeMemberCandidate$LMemberDefinition$(member));
			}
			return true;
		}));
		return true;
	}));
};


function _CompletionCandidatesOfProperty$_makeMemberCandidate$LMemberDefinition$(member) {
	var kind;
	var data;
	var docComment;
	var mf;
	var this$0;
	var this$1;
	kind = (member._flags & 8 ? "static member" : "member");
	kind += (member instanceof MemberFunctionDefinition ? " function" : " variable");
	data = {};
	data.word = member._nameToken._value;
	data.type = member.getType$().toString();
	data.kind = kind;
	data.definedClass = member._classDef.className$();
	this$0 = member._token;
	data.definedFilename = this$0._filename;
	this$1 = member._token;
	data.definedLineNumber = this$1._lineNumber;
	docComment = member._docComment;
	if (docComment) {
		data.doc = docComment.getDescription$();
	}
	if (member instanceof MemberFunctionDefinition) {
		mf = member;
		data.returnType = mf._returnType.toString();
		data.args = mf._args.map((function (arg) {
			var pair;
			var this$0;
			pair = {};
			this$0 = arg._name;
			pair.name = this$0._value;
			pair.type = arg._type.toString();
			return pair;
		}));
	}
	return data;
};

_CompletionCandidatesOfProperty._makeMemberCandidate$LMemberDefinition$ = _CompletionCandidatesOfProperty$_makeMemberCandidate$LMemberDefinition$;

function _StatementTransformer(transformer, identifier) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap[identifier] == null) {
		_StatementTransformer._statementCountMap[identifier] = 0;
	}
	this._id = _StatementTransformer._statementCountMap[identifier]++;
};

$__jsx_extend([_StatementTransformer], Object);
_StatementTransformer.prototype.getID$ = function () {
	return this._id;
};


function _StatementTransformer$getID$L_StatementTransformer$($this) {
	return $this._id;
};

_StatementTransformer.getID$L_StatementTransformer$ = _StatementTransformer$getID$L_StatementTransformer$;

function _ConstructorInvocationStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "CONSTRUCTOR-INVOCATION");
	this._statement = statement;
};

$__jsx_extend([_ConstructorInvocationStatementTransformer], _StatementTransformer);
_ConstructorInvocationStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ConstructorInvocationStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	return [ this._statement ];
};


function _ExpressionStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "EXPRESSION");
	this._statement = statement;
};

$__jsx_extend([_ExpressionStatementTransformer], _StatementTransformer);
_ExpressionStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ExpressionStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	return [ this._statement ];
};


function _FunctionStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "FUNCTION");
	this._statement = statement;
};

$__jsx_extend([_FunctionStatementTransformer], _StatementTransformer);
_FunctionStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_FunctionStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	return [ this._statement ];
};


function _ReturnStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "RETURN");
	this._statement = statement;
};

$__jsx_extend([_ReturnStatementTransformer], _StatementTransformer);
_ReturnStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ReturnStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	throw new Error("logic flaw");
};


function _YieldStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "YIELD");
	this._index = 0;
	this._statement = statement;
};

$__jsx_extend([_YieldStatementTransformer], _StatementTransformer);
_YieldStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_YieldStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	var statements;
	var label;
	statements = [];
	statements.push(this._statement);
	label = "$YIELD_" + (this._id + "");
	statements.push(new GotoStatement(label));
	statements.push(new LabelStatement(label));
	return statements;
};


function _DeleteStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "DELETE");
	this._statement = statement;
};

$__jsx_extend([_DeleteStatementTransformer], _StatementTransformer);
_DeleteStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_DeleteStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	return [ this._statement ];
};


function _BreakStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "BREAK");
	this._statement = statement;
};

$__jsx_extend([_BreakStatementTransformer], _StatementTransformer);
_BreakStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_BreakStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	var trans;
	var this$0;
	var _labelMap$0;
	if (this._statement._label != null) {
		trans = CodeTransformer$findLabellableStatementTransformerByLabel$LCodeTransformer$S(this._transformer, this._statement._label._value);
	} else {
		this$0 = this._transformer;
		trans = (_labelMap$0 = this$0._labelMap)[_labelMap$0.length - 1];
	}
	return [ new GotoStatement(trans.getBreakingLabel$()) ];
};


function _ContinueStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "CONTINUE");
	this._statement = statement;
};

$__jsx_extend([_ContinueStatementTransformer], _StatementTransformer);
_ContinueStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ContinueStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	var trans;
	var this$0;
	var _labelMap$0;
	if (this._statement._label != null) {
		trans = CodeTransformer$findLabellableStatementTransformerByLabel$LCodeTransformer$S(this._transformer, this._statement._label._value);
	} else {
		this$0 = this._transformer;
		trans = (_labelMap$0 = this$0._labelMap)[_labelMap$0.length - 1];
	}
	return [ new GotoStatement(trans.getContinuingLabel$()) ];
};


function _LabellableStatementTransformer(transformer, identifier) {
	_StatementTransformer.call(this, transformer, identifier);
};

$__jsx_extend([_LabellableStatementTransformer], _StatementTransformer);
function _DoWhileStatementTransformer(transformer, statement) {
	_LabellableStatementTransformer.call(this, transformer, "DO-WHILE");
	this._index = 0;
	this._statement = statement;
};

$__jsx_extend([_DoWhileStatementTransformer], _LabellableStatementTransformer);
_DoWhileStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_DoWhileStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	var statements;
	var bodyLabel;
	var testLabel;
	var endLabel;
	var expr$0;
	statements = [];
	bodyLabel = "$BODY_DO_WHILE_" + (this._id + "");
	statements.push(new GotoStatement(bodyLabel));
	statements.push(new LabelStatement(bodyLabel));
	this._transformer._labelMap.push(this);
	CodeTransformer$convertAndPushStatements$LCodeTransformer$ALStatement$ALStatement$(this._transformer, this._statement.getStatements$(), statements);
	this._transformer._labelMap.pop();
	testLabel = "$TEST_DO_WHILE_" + (this._id + "");
	statements.push(new GotoStatement(testLabel));
	statements.push(new LabelStatement(testLabel));
	endLabel = "$END_DO_WHILE_" + (this._id + "");
	expr$0 = this._statement._expr;
	statements.push(new IfStatement(new Token$1("if", false), expr$0, [ new GotoStatement(bodyLabel) ], [ new GotoStatement(endLabel) ]));
	statements.push(new LabelStatement(endLabel));
	return statements;
};


_DoWhileStatementTransformer.prototype.getBreakingLabel$ = function () {
	return "$END_DO_WHILE_" + (this._id + "");
};


_DoWhileStatementTransformer.prototype.getContinuingLabel$ = function () {
	return "$BODY_DO_WHILE_" + (this._id + "");
};


function _ForInStatementTransformer(transformer, statement) {
	_LabellableStatementTransformer.call(this, transformer, "FOR-IN");
	this._statement = statement;
};

$__jsx_extend([_ForInStatementTransformer], _LabellableStatementTransformer);
_ForInStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ForInStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	throw new Error("logic flaw");
};


_ForInStatementTransformer.prototype.getBreakingLabel$ = function () {
	throw new Error("logic flaw");
};


_ForInStatementTransformer.prototype.getContinuingLabel$ = function () {
	throw new Error("logic flaw");
};


function _ForStatementTransformer(transformer, statement) {
	_LabellableStatementTransformer.call(this, transformer, "FOR");
	this._index = 0;
	this._statement = statement;
};

$__jsx_extend([_ForStatementTransformer], _LabellableStatementTransformer);
_ForStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ForStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	var statements;
	var initLabel;
	var testLabel;
	var bodyLabel;
	var endLabel;
	var postLabel;
	var expr$0;
	var expr$1;
	var expr$2;
	var _id$0;
	statements = [];
	initLabel = "$INIT_FOR_" + (this._id + "");
	statements.push(new GotoStatement(initLabel));
	statements.push(new LabelStatement(initLabel));
	expr$0 = this._statement._initExpr;
	statements.push(new ExpressionStatement(expr$0));
	testLabel = "$TEST_FOR_" + (this._id + "");
	statements.push(new GotoStatement(testLabel));
	statements.push(new LabelStatement(testLabel));
	bodyLabel = "$BODY_FOR_" + ((_id$0 = this._id) + "");
	endLabel = "$END_FOR_" + (_id$0 + "");
	expr$1 = this._statement._condExpr;
	statements.push(new IfStatement(new Token$1("if", false), expr$1, [ new GotoStatement(bodyLabel) ], [ new GotoStatement(endLabel) ]));
	statements.push(new LabelStatement(bodyLabel));
	this._transformer._labelMap.push(this);
	CodeTransformer$convertAndPushStatements$LCodeTransformer$ALStatement$ALStatement$(this._transformer, this._statement._statements, statements);
	this._transformer._labelMap.pop();
	postLabel = "$POST_FOR_" + (this._id + "");
	statements.push(new GotoStatement(postLabel));
	statements.push(new LabelStatement(postLabel));
	expr$2 = this._statement._postExpr;
	statements.push(new ExpressionStatement(expr$2));
	statements.push(new GotoStatement(testLabel));
	statements.push(new LabelStatement(endLabel));
	return statements;
};


_ForStatementTransformer.prototype.getBreakingLabel$ = function () {
	return "$END_FOR_" + (this._id + "");
};


_ForStatementTransformer.prototype.getContinuingLabel$ = function () {
	return "$POST_FOR_" + (this._id + "");
};


function _IfStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "IF");
	this._statement = statement;
};

$__jsx_extend([_IfStatementTransformer], _StatementTransformer);
_IfStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_IfStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	var statements;
	var testLabel;
	var succLabel;
	var failLabel;
	var endLabel;
	var expr$0;
	var _id$0;
	statements = [];
	testLabel = "$TEST_IF_" + ((_id$0 = this._id) + "");
	succLabel = "$SUCC_IF_" + (_id$0 + "");
	failLabel = "$FAIL_IF_" + (_id$0 + "");
	statements.push(new GotoStatement(testLabel));
	statements.push(new LabelStatement(testLabel));
	expr$0 = this._statement._expr;
	statements.push(new IfStatement(new Token$1("if", false), expr$0, [ new GotoStatement(succLabel) ], [ new GotoStatement(failLabel) ]));
	statements.push(new LabelStatement(succLabel));
	CodeTransformer$convertAndPushStatements$LCodeTransformer$ALStatement$ALStatement$(this._transformer, this._statement._onTrueStatements, statements);
	endLabel = "$END_IF_" + (this._id + "");
	statements.push(new GotoStatement(endLabel));
	statements.push(new LabelStatement(failLabel));
	CodeTransformer$convertAndPushStatements$LCodeTransformer$ALStatement$ALStatement$(this._transformer, this._statement._onFalseStatements, statements);
	statements.push(new GotoStatement(endLabel));
	statements.push(new LabelStatement(endLabel));
	return statements;
};


function _SwitchStatementTransformer(transformer, statement) {
	_LabellableStatementTransformer.call(this, transformer, "SWITCH");
	this._index = 0;
	this._statement = statement;
};

$__jsx_extend([_SwitchStatementTransformer], _LabellableStatementTransformer);
_SwitchStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_SwitchStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	var statements;
	var testLabel;
	var endLabel;
	statements = [];
	testLabel = "$TEST_SWITCH_" + (this._id + "");
	statements.push(new GotoStatement(testLabel));
	statements.push(new LabelStatement(testLabel));
	_SwitchStatementTransformer$_pushConditionalSwitch$L_SwitchStatementTransformer$ALStatement$(this, statements);
	endLabel = "$END_SWITCH_" + (this._id + "");
	statements.push(new GotoStatement(endLabel));
	_SwitchStatementTransformer$_pushSwitchBody$L_SwitchStatementTransformer$ALStatement$(this, statements);
	statements.push(new LabelStatement(endLabel));
	return statements;
};


_SwitchStatementTransformer.prototype._pushConditionalSwitch$ALStatement$ = function (output) {
	var statements;
	var switchCases;
	var i;
	var stmt;
	var condSwitch;
	var clone$this$0;
	statements = this._statement._statements;
	switchCases = [];
	for (i = 0; i < statements.length; ++ i) {
		stmt = statements[i];
		if (stmt instanceof CaseStatement) {
			switchCases.push(stmt);
			switchCases.push(new GotoStatement("$SWITCH_" + (this._id + "") + "_CASE_" + stmt._expr._token._value));
			switchCases.push(new ReturnStatement(new Token$1("return", false), null));
		} else {
			if (stmt instanceof DefaultStatement) {
				switchCases.push(stmt);
				switchCases.push(new GotoStatement("$SWITCH_" + (this._id + "") + "_DEFAULT"));
				switchCases.push(new ReturnStatement(new Token$1("return", false), null));
			}
		}
	}
	condSwitch = (clone$this$0 = this._statement, new SwitchStatement(clone$this$0._token, clone$this$0._label, clone$this$0._expr.clone$(), Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(clone$this$0._statements)));
	condSwitch._statements = switchCases;
	output.push(condSwitch);
};


function _SwitchStatementTransformer$_pushConditionalSwitch$L_SwitchStatementTransformer$ALStatement$($this, output) {
	var statements;
	var switchCases;
	var i;
	var stmt;
	var condSwitch;
	var clone$this$0;
	statements = $this._statement._statements;
	switchCases = [];
	for (i = 0; i < statements.length; ++ i) {
		stmt = statements[i];
		if (stmt instanceof CaseStatement) {
			switchCases.push(stmt);
			switchCases.push(new GotoStatement("$SWITCH_" + ($this._id + "") + "_CASE_" + stmt._expr._token._value));
			switchCases.push(new ReturnStatement(new Token$1("return", false), null));
		} else {
			if (stmt instanceof DefaultStatement) {
				switchCases.push(stmt);
				switchCases.push(new GotoStatement("$SWITCH_" + ($this._id + "") + "_DEFAULT"));
				switchCases.push(new ReturnStatement(new Token$1("return", false), null));
			}
		}
	}
	condSwitch = (clone$this$0 = $this._statement, new SwitchStatement(clone$this$0._token, clone$this$0._label, clone$this$0._expr.clone$(), Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(clone$this$0._statements)));
	condSwitch._statements = switchCases;
	output.push(condSwitch);
};

_SwitchStatementTransformer._pushConditionalSwitch$L_SwitchStatementTransformer$ALStatement$ = _SwitchStatementTransformer$_pushConditionalSwitch$L_SwitchStatementTransformer$ALStatement$;

_SwitchStatementTransformer.prototype._pushSwitchBody$ALStatement$ = function (output) {
	var statements;
	var i;
	var stmt;
	var label;
	var caseStmt$0;
	statements = this._statement._statements;
	this._transformer._labelMap.push(this);
	for (i = 0; i < statements.length; ++ i) {
		stmt = statements[i];
		if (stmt instanceof CaseStatement) {
			caseStmt$0 = stmt;
			label = "$SWITCH_" + (this._id + "") + "_CASE_" + caseStmt$0._expr._token._value;
			output.push(new GotoStatement(label));
			output.push(new LabelStatement(label));
		} else {
			if (stmt instanceof DefaultStatement) {
				label = "$SWITCH_" + (this._id + "") + "_DEFAULT";
				output.push(new GotoStatement(label));
				output.push(new LabelStatement(label));
			} else {
				CodeTransformer$convertAndPushStatement$LCodeTransformer$LStatement$ALStatement$(this._transformer, stmt, output);
			}
		}
	}
	this._transformer._labelMap.pop();
};


function _SwitchStatementTransformer$_pushSwitchBody$L_SwitchStatementTransformer$ALStatement$($this, output) {
	var statements;
	var i;
	var stmt;
	var label;
	var caseStmt$0;
	statements = $this._statement._statements;
	$this._transformer._labelMap.push($this);
	for (i = 0; i < statements.length; ++ i) {
		stmt = statements[i];
		if (stmt instanceof CaseStatement) {
			caseStmt$0 = stmt;
			label = "$SWITCH_" + ($this._id + "") + "_CASE_" + caseStmt$0._expr._token._value;
			output.push(new GotoStatement(label));
			output.push(new LabelStatement(label));
		} else {
			if (stmt instanceof DefaultStatement) {
				label = "$SWITCH_" + ($this._id + "") + "_DEFAULT";
				output.push(new GotoStatement(label));
				output.push(new LabelStatement(label));
			} else {
				CodeTransformer$convertAndPushStatement$LCodeTransformer$LStatement$ALStatement$($this._transformer, stmt, output);
			}
		}
	}
	$this._transformer._labelMap.pop();
};

_SwitchStatementTransformer._pushSwitchBody$L_SwitchStatementTransformer$ALStatement$ = _SwitchStatementTransformer$_pushSwitchBody$L_SwitchStatementTransformer$ALStatement$;

_SwitchStatementTransformer.prototype._getLabelFromCaseStatement$LCaseStatement$ = function (caseStmt) {
	return "$SWITCH_" + (this._id + "") + "_CASE_" + caseStmt._expr._token._value;
};


function _SwitchStatementTransformer$_getLabelFromCaseStatement$L_SwitchStatementTransformer$LCaseStatement$($this, caseStmt) {
	return "$SWITCH_" + ($this._id + "") + "_CASE_" + caseStmt._expr._token._value;
};

_SwitchStatementTransformer._getLabelFromCaseStatement$L_SwitchStatementTransformer$LCaseStatement$ = _SwitchStatementTransformer$_getLabelFromCaseStatement$L_SwitchStatementTransformer$LCaseStatement$;

_SwitchStatementTransformer.prototype._getLabelFromDefaultStatement$ = function () {
	return "$SWITCH_" + (this._id + "") + "_DEFAULT";
};


function _SwitchStatementTransformer$_getLabelFromDefaultStatement$L_SwitchStatementTransformer$($this) {
	return "$SWITCH_" + ($this._id + "") + "_DEFAULT";
};

_SwitchStatementTransformer._getLabelFromDefaultStatement$L_SwitchStatementTransformer$ = _SwitchStatementTransformer$_getLabelFromDefaultStatement$L_SwitchStatementTransformer$;

_SwitchStatementTransformer.prototype.getBreakingLabel$ = function () {
	return "$END_SWITCH_" + (this._id + "");
};


_SwitchStatementTransformer.prototype.getContinuingLabel$ = function () {
	throw new Error("logic flaw");
};


function _CaseStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "CASE");
	this._statement = statement;
};

$__jsx_extend([_CaseStatementTransformer], _StatementTransformer);
_CaseStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_CaseStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	throw new Error("logic flaw");
};


function _DefaultStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "DEFAULT");
	this._statement = statement;
};

$__jsx_extend([_DefaultStatementTransformer], _StatementTransformer);
_DefaultStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_DefaultStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	throw new Error("logic flaw");
};


function _WhileStatementTransformer(transformer, statement) {
	_LabellableStatementTransformer.call(this, transformer, "WHILE");
	this._statement = statement;
};

$__jsx_extend([_WhileStatementTransformer], _LabellableStatementTransformer);
_WhileStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_WhileStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	var statements;
	var testLabel;
	var bodyLabel;
	var endLabel;
	var expr$0;
	var _id$0;
	statements = [];
	testLabel = "$TEST_WHILE_" + (this._id + "");
	statements.push(new GotoStatement(testLabel));
	statements.push(new LabelStatement(testLabel));
	bodyLabel = "$BODY_WHILE_" + ((_id$0 = this._id) + "");
	endLabel = "$END_WHILE_" + (_id$0 + "");
	expr$0 = this._statement._expr;
	statements.push(new IfStatement(new Token$1("if", false), expr$0, [ new GotoStatement(bodyLabel) ], [ new GotoStatement(endLabel) ]));
	statements.push(new LabelStatement(bodyLabel));
	this._transformer._labelMap.push(this);
	CodeTransformer$convertAndPushStatements$LCodeTransformer$ALStatement$ALStatement$(this._transformer, this._statement._statements, statements);
	this._transformer._labelMap.pop();
	statements.push(new GotoStatement(testLabel));
	statements.push(new LabelStatement(endLabel));
	return statements;
};


_WhileStatementTransformer.prototype.getBreakingLabel$ = function () {
	return "$END_WHILE_" + (this._id + "");
};


_WhileStatementTransformer.prototype.getContinuingLabel$ = function () {
	return "$TEST_WHILE_" + (this._id + "");
};


function _TryStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "TRY");
	this._statement = statement;
};

$__jsx_extend([_TryStatementTransformer], _StatementTransformer);
_TryStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_TryStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	throw new Error("logic flaw");
};


function _CatchStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "CATCH");
	this._statement = statement;
};

$__jsx_extend([_CatchStatementTransformer], _StatementTransformer);
_CatchStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_CatchStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	throw new Error("logic flaw");
};


function _ThrowStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "THROW");
	this._statement = statement;
};

$__jsx_extend([_ThrowStatementTransformer], _StatementTransformer);
_ThrowStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ThrowStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	return [ this._statement ];
};


function _AssertStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "ASSERT");
	this._statement = statement;
};

$__jsx_extend([_AssertStatementTransformer], _StatementTransformer);
_AssertStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_AssertStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	return [ this._statement ];
};


function _LogStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "LOG");
	this._statement = statement;
};

$__jsx_extend([_LogStatementTransformer], _StatementTransformer);
_LogStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_LogStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	return [ this._statement ];
};


function _DebuggerStatementTransformer(transformer, statement) {
	_StatementTransformer.call(this, transformer, "DEBUGGER");
	this._statement = statement;
};

$__jsx_extend([_DebuggerStatementTransformer], _StatementTransformer);
_DebuggerStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_DebuggerStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	return [ this._statement ];
};


function CodeTransformer() {
	this._labelMap = [];
	this._statementIDs = {};
};

$__jsx_extend([CodeTransformer], Object);
function CodeTransformer$findLabellableStatementTransformerByLabel$LCodeTransformer$S($this, label) {
	var i;
	var trans;
	var getLabel$this$0;
	var getValue$this$0;
	for (i = 0; $this._labelMap.length; ++ i) {
		trans = $this._labelMap[i];
		if ((getValue$this$0 = (getLabel$this$0 = trans.getStatement$(), getLabel$this$0._label), getValue$this$0._value) === label) {
			return trans;
		}
	}
	throw new Error("fatal error: no corresponding transformer for label \"" + label + "\"");
};

CodeTransformer.findLabellableStatementTransformerByLabel$LCodeTransformer$S = CodeTransformer$findLabellableStatementTransformerByLabel$LCodeTransformer$S;

function CodeTransformer$getInnermostLabellableStatementTransformer$LCodeTransformer$($this) {
	var _labelMap$0;
	return (_labelMap$0 = $this._labelMap)[_labelMap$0.length - 1];
};

CodeTransformer.getInnermostLabellableStatementTransformer$LCodeTransformer$ = CodeTransformer$getInnermostLabellableStatementTransformer$LCodeTransformer$;

function CodeTransformer$enterLabelledBlock$LCodeTransformer$L_LabellableStatementTransformer$($this, transformer) {
	$this._labelMap.push(transformer);
};

CodeTransformer.enterLabelledBlock$LCodeTransformer$L_LabellableStatementTransformer$ = CodeTransformer$enterLabelledBlock$LCodeTransformer$L_LabellableStatementTransformer$;

function CodeTransformer$leaveLabelledBlock$LCodeTransformer$($this) {
	$this._labelMap.pop();
};

CodeTransformer.leaveLabelledBlock$LCodeTransformer$ = CodeTransformer$leaveLabelledBlock$LCodeTransformer$;

function CodeTransformer$convertAndPushStatement$LCodeTransformer$LStatement$ALStatement$($this, input, output) {
	var conved;
	var i;
	conved = CodeTransformer$_getStatementTransformerFor$LCodeTransformer$LStatement$($this, input).replaceControlStructuresWithGotos$();
	for (i = 0; i < conved.length; ++ i) {
		output.push(conved[i]);
	}
};

CodeTransformer.convertAndPushStatement$LCodeTransformer$LStatement$ALStatement$ = CodeTransformer$convertAndPushStatement$LCodeTransformer$LStatement$ALStatement$;

function CodeTransformer$convertAndPushStatements$LCodeTransformer$ALStatement$ALStatement$($this, input, output) {
	var i;
	for (i = 0; i < input.length; ++ i) {
		CodeTransformer$convertAndPushStatement$LCodeTransformer$LStatement$ALStatement$($this, input[i], output);
	}
};

CodeTransformer.convertAndPushStatements$LCodeTransformer$ALStatement$ALStatement$ = CodeTransformer$convertAndPushStatements$LCodeTransformer$ALStatement$ALStatement$;

function CodeTransformer$pushConditionalBranch$LCodeTransformer$LExpression$SSALStatement$($this, expr, succLabel, failLabel, output) {
	output.push(new IfStatement(new Token$1("if", false), expr, [ new GotoStatement(succLabel) ], [ new GotoStatement(failLabel) ]));
};

CodeTransformer.pushConditionalBranch$LCodeTransformer$LExpression$SSALStatement$ = CodeTransformer$pushConditionalBranch$LCodeTransformer$LExpression$SSALStatement$;

function CodeTransformer$pushExpressionStatement$LCodeTransformer$LExpression$ALStatement$($this, expr, output) {
	output.push(new ExpressionStatement(expr));
};

CodeTransformer.pushExpressionStatement$LCodeTransformer$LExpression$ALStatement$ = CodeTransformer$pushExpressionStatement$LCodeTransformer$LExpression$ALStatement$;

function CodeTransformer$getStatementIDMap$LCodeTransformer$($this) {
	return $this._statementIDs;
};

CodeTransformer.getStatementIDMap$LCodeTransformer$ = CodeTransformer$getStatementIDMap$LCodeTransformer$;

function CodeTransformer$transformFunctionDefinition$LCodeTransformer$LMemberFunctionDefinition$($this, funcDef) {
	var newExpr;
	var numBlock;
	newExpr = new NewExpression(new Token$1("new", false), CodeTransformer.stopIterationType, [  ]);
	newExpr.analyze$LAnalysisContext$LExpression$(({errors: [  ], parser: null, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}), null);
	funcDef._statements.push(new ThrowStatement(new Token$1("throw", false), newExpr));
	CodeTransformer$_replaceControlStructuresWithGotos$LCodeTransformer$LMemberFunctionDefinition$($this, funcDef);
	numBlock = CodeTransformer$_eliminateGotos$LCodeTransformer$LMemberFunctionDefinition$($this, funcDef);
	CodeTransformer$_eliminateYields$LCodeTransformer$LMemberFunctionDefinition$N($this, funcDef, numBlock);
};

CodeTransformer.transformFunctionDefinition$LCodeTransformer$LMemberFunctionDefinition$ = CodeTransformer$transformFunctionDefinition$LCodeTransformer$LMemberFunctionDefinition$;

function CodeTransformer$_getStatementTransformerFor$LCodeTransformer$LStatement$($this, statement) {
	if (statement instanceof ConstructorInvocationStatement) {
		return new _ConstructorInvocationStatementTransformer($this, statement);
	} else {
		if (statement instanceof ExpressionStatement) {
			return new _ExpressionStatementTransformer($this, statement);
		} else {
			if (statement instanceof FunctionStatement) {
				return new _FunctionStatementTransformer($this, statement);
			} else {
				if (statement instanceof ReturnStatement) {
					return new _ReturnStatementTransformer($this, statement);
				} else {
					if (statement instanceof YieldStatement) {
						return new _YieldStatementTransformer($this, statement);
					} else {
						if (statement instanceof DeleteStatement) {
							return new _DeleteStatementTransformer($this, statement);
						} else {
							if (statement instanceof BreakStatement) {
								return new _BreakStatementTransformer($this, statement);
							} else {
								if (statement instanceof ContinueStatement) {
									return new _ContinueStatementTransformer($this, statement);
								} else {
									if (statement instanceof DoWhileStatement) {
										return new _DoWhileStatementTransformer($this, statement);
									} else {
										if (statement instanceof ForInStatement) {
											return new _ForInStatementTransformer($this, statement);
										} else {
											if (statement instanceof ForStatement) {
												return new _ForStatementTransformer($this, statement);
											} else {
												if (statement instanceof IfStatement) {
													return new _IfStatementTransformer($this, statement);
												} else {
													if (statement instanceof SwitchStatement) {
														return new _SwitchStatementTransformer($this, statement);
													} else {
														if (statement instanceof CaseStatement) {
															return new _CaseStatementTransformer($this, statement);
														} else {
															if (statement instanceof DefaultStatement) {
																return new _DefaultStatementTransformer($this, statement);
															} else {
																if (statement instanceof WhileStatement) {
																	return new _WhileStatementTransformer($this, statement);
																} else {
																	if (statement instanceof TryStatement) {
																		return new _TryStatementTransformer($this, statement);
																	} else {
																		if (statement instanceof CatchStatement) {
																			return new _CatchStatementTransformer($this, statement);
																		} else {
																			if (statement instanceof ThrowStatement) {
																				return new _ThrowStatementTransformer($this, statement);
																			} else {
																				if (statement instanceof AssertStatement) {
																					return new _AssertStatementTransformer($this, statement);
																				} else {
																					if (statement instanceof LogStatement) {
																						return new _LogStatementTransformer($this, statement);
																					} else {
																						if (statement instanceof DebuggerStatement) {
																							return new _DebuggerStatementTransformer($this, statement);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	throw new Error("got unexpected type of statement: " + JSON.stringify(statement.serialize$()));
};

CodeTransformer._getStatementTransformerFor$LCodeTransformer$LStatement$ = CodeTransformer$_getStatementTransformerFor$LCodeTransformer$LStatement$;

function CodeTransformer$_doCPSConvert$LCodeTransformer$LMemberFunctionDefinition$($this, funcDef) {
	CodeTransformer$_replaceControlStructuresWithGotos$LCodeTransformer$LMemberFunctionDefinition$($this, funcDef);
	return CodeTransformer$_eliminateGotos$LCodeTransformer$LMemberFunctionDefinition$($this, funcDef);
};

CodeTransformer._doCPSConvert$LCodeTransformer$LMemberFunctionDefinition$ = CodeTransformer$_doCPSConvert$LCodeTransformer$LMemberFunctionDefinition$;

function CodeTransformer$_replaceControlStructuresWithGotos$LCodeTransformer$LMemberFunctionDefinition$($this, funcDef) {
	var statements;
	var i;
	statements = [];
	for (i = 0; i < funcDef._statements.length; ++ i) {
		statements = statements.concat(CodeTransformer$_getStatementTransformerFor$LCodeTransformer$LStatement$($this, funcDef._statements[i]).replaceControlStructuresWithGotos$());
	}
	statements.unshift(new GotoStatement("$START"), new LabelStatement("$START"));
	statements.push(new GotoStatement("$END"), new LabelStatement("$END"));
	funcDef._statements = statements;
};

CodeTransformer._replaceControlStructuresWithGotos$LCodeTransformer$LMemberFunctionDefinition$ = CodeTransformer$_replaceControlStructuresWithGotos$LCodeTransformer$LMemberFunctionDefinition$;

function CodeTransformer$_eliminateGotos$LCodeTransformer$LMemberFunctionDefinition$($this, funcDef) {
	var statements;
	var labels;
	var i;
	var name;
	var stmt;
	var ifStmt;
	var succLabel;
	var failLabel;
	var switchStmt;
	var j;
	var entries;
	var codeBlocks;
	var currentLabel;
	var numBlock;
	var body;
	var block;
	var this$0;
	var this$1;
	var this$2;
	statements = funcDef._statements;
	labels = {};
	for (i = 0; i < statements.length; ++ i) {
		if (statements[i] instanceof LabelStatement && labels[statements[i]._name] == null) {
			name = statements[i]._name;
			labels[name] = new LocalVariable(new Token$1(name, true), new StaticFunctionType(null, Type.voidType, [  ], true));
			funcDef._locals.push(labels[name]);
		}
	}
	for (i = 0; i < statements.length; ++ i) {
		stmt = statements[i];
		if (stmt instanceof GotoStatement) {
			name = stmt.label;
			statements[i] = new ExpressionStatement(new CallExpression(new Token$1("(", false), new LocalExpression(null, labels[name]), [  ]));
		} else {
			if (stmt instanceof IfStatement) {
				ifStmt = stmt;
				this$0 = ifStmt._onTrueStatements[0];
				succLabel = this$0.label;
				ifStmt._onTrueStatements[0] = new ExpressionStatement(new CallExpression(new Token$1("(", false), new LocalExpression(null, labels[succLabel]), [  ]));
				this$1 = ifStmt._onFalseStatements[0];
				failLabel = this$1.label;
				ifStmt._onFalseStatements[0] = new ExpressionStatement(new CallExpression(new Token$1("(", false), new LocalExpression(null, labels[failLabel]), [  ]));
			} else {
				if (stmt instanceof SwitchStatement) {
					switchStmt = stmt;
					for (j = 0; j < switchStmt._statements.length; ++ j) {
						if (switchStmt._statements[j] instanceof GotoStatement) {
							this$2 = switchStmt._statements[j];
							name = this$2.label;
							switchStmt._statements[j] = new ExpressionStatement(new CallExpression(new Token$1("(", false), new LocalExpression(null, labels[name]), [  ]));
						}
					}
				}
			}
		}
	}
	entries = [];
	for (i = 0; i < statements.length; ++ i) {
		if (statements[i] instanceof LabelStatement) {
			break;
		}
		entries.push(statements[i]);
	}
	codeBlocks = [];
	currentLabel = null;
	numBlock = 0;
	while (i < statements.length) {
		currentLabel = statements[i];
		body = [];
		++ i;
		for (; i < statements.length; ++ i) {
			if (statements[i] instanceof LabelStatement) {
				break;
			}
			body.push(statements[i]);
		}
		block = new MemberFunctionDefinition(new Token$1("function", false), null, 8, Type.voidType, [  ], [  ], body, [  ], null, null);
		funcDef._closures.push(block);
		codeBlocks.push(new ExpressionStatement(new AssignmentExpression(new Token$1("=", false), new LocalExpression(null, labels[currentLabel._name]), new FunctionExpression(new Token$1("function", false), block))));
		++ numBlock;
	}
	funcDef._statements = codeBlocks.concat(entries);
	return numBlock;
};

CodeTransformer._eliminateGotos$LCodeTransformer$LMemberFunctionDefinition$ = CodeTransformer$_eliminateGotos$LCodeTransformer$LMemberFunctionDefinition$;

function CodeTransformer$_calcGeneratorNestDepth$LMemberFunctionDefinition$(funcDef) {
	var depth;
	var parent;
	depth = 0;
	while ((parent = funcDef._parent) != null) {
		if ((parent._flags & 8192) !== 0) {
			depth++;
		}
		funcDef = parent;
	}
	return depth;
};

CodeTransformer._calcGeneratorNestDepth$LMemberFunctionDefinition$ = CodeTransformer$_calcGeneratorNestDepth$LMemberFunctionDefinition$;

function CodeTransformer$_eliminateYields$LCodeTransformer$LMemberFunctionDefinition$N($this, funcDef, numBlock) {
	var yieldType;
	var genClassDef;
	var createContext;
	var parser;
	var genType;
	var genLocalName;
	var genLocal;
	var newExpr;
	var blocks;
	var i;
	var statements;
	var j;
	var getTypeArguments$this$0;
	var _closures$0;
	yieldType = (getTypeArguments$this$0 = funcDef._returnType.getClassDef$(), getTypeArguments$this$0._typeArguments)[0];
	genClassDef = TemplateClassDefinition$instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$(CodeTransformer.jsxGeneratorClassDef, [  ], ({_token: null, _className: "__jsx_generator", _typeArgs: [ yieldType ]}));
	createContext = (function (parser) {
		return ({errors: [  ], parser: parser, postInstantiationCallback: (function (parser, classDef) {
			ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			return classDef;
		}), funcDef: null, blockStack: null, statement: null});
	});
	parser = CodeTransformer.jsxGeneratorClassDef._parser;
	ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(genClassDef, createContext(parser));
	ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(genClassDef, createContext(parser));
	CodeTransformer.jsxGeneratorClassDef._parser._classDefs.push(genClassDef);
	genType = new ObjectType(genClassDef);
	genLocalName = "$generator" + (CodeTransformer$_calcGeneratorNestDepth$LMemberFunctionDefinition$(funcDef) + "");
	genLocal = new LocalVariable(new Token$1(genLocalName, false), genType);
	funcDef._locals.push(genLocal);
	newExpr = new NewExpression(new Token$1("new", false), genType, [  ]);
	newExpr.analyze$LAnalysisContext$LExpression$(({errors: [  ], parser: null, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}), null);
	funcDef._statements.unshift(new ExpressionStatement(new AssignmentExpression(new Token$1("=", false), new LocalExpression(new Token$1(genLocalName, false), genLocal), newExpr)));
	blocks = (_closures$0 = funcDef._closures).slice(_closures$0.length - numBlock);
	for (i = 0; i < blocks.length; ++ i) {
		statements = blocks[i]._statements;
		for (j = 0; j < statements.length; ++ j) {
			if (statements[j] instanceof YieldStatement) {
				statements.splice(j, 2, new ExpressionStatement(new AssignmentExpression(new Token$1("=", false), new PropertyExpression$0(new Token$1(".", false), new LocalExpression(new Token$1(genLocalName, false), genLocal), new Token$1("__value", false), [  ], yieldType), statements[j]._expr)), new ExpressionStatement(new AssignmentExpression(new Token$1("=", false), new PropertyExpression$0(new Token$1(".", false), new LocalExpression(new Token$1(genLocalName, false), genLocal), new Token$1("__next", true), [  ], new StaticFunctionType(null, Type.voidType, [  ], true)), statements[j + 1]._expr._expr)));
				break;
			}
		}
	}
	statements = funcDef._statements;
	statements.splice(statements.length - 1, 1, new ExpressionStatement(new AssignmentExpression(new Token$1("=", false), new PropertyExpression$0(new Token$1(".", false), new LocalExpression(new Token$1(genLocalName, false), genLocal), new Token$1("__next", true), [  ], new StaticFunctionType(null, Type.voidType, [  ], true)), new LocalExpression(new Token$1("$START", true), statements[statements.length - 1]._expr._expr._local))));
	statements.push(new ReturnStatement(new Token$1("return", false), new LocalExpression(new Token$1("$generator", false), genLocal)));
};

CodeTransformer._eliminateYields$LCodeTransformer$LMemberFunctionDefinition$N = CodeTransformer$_eliminateYields$LCodeTransformer$LMemberFunctionDefinition$N;

function Expression(token) {
	this._stash = {};
	this._token = token;
};

function Expression$0(that) {
	var k;
	this._stash = {};
	this._token = that._token;
	for (k in that._stash) {
		this._stash[k] = that._stash[k].clone$();
	}
};

$__jsx_extend([Expression, Expression$0], Object);
$__jsx_merge_interface(Expression, Stashable);

Expression.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var $this = this;
	var onExpr;
	function onExpr(expr) {
		var srcType;
		var propertyExpr;
		var srcTypes;
		var instanceofExpr;
		var type$0;
		var type$1;
		var type$2;
		var types$0;
		var type$3;
		var type$4;
		var type$5;
		var type$6;
		var type$7;
		var local$0;
		var type$8;
		if (expr instanceof NullExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				type$0 = srcType.instantiate$LInstantiationContext$(instantiationContext);
				expr._type = type$0;
			}
		} else {
			if (expr instanceof NewExpression) {
				srcType = expr.getType$();
				if (srcType != null) {
					type$1 = srcType.instantiate$LInstantiationContext$(instantiationContext);
					expr._type = type$1;
				}
			} else {
				if (expr instanceof PropertyExpression) {
					propertyExpr = expr;
					srcType = expr.getType$();
					if (srcType != null) {
						type$2 = srcType.instantiate$LInstantiationContext$(instantiationContext);
						propertyExpr._type = type$2;
					}
					srcTypes = propertyExpr._typeArgs;
					if (srcTypes != null) {
						types$0 = srcTypes.map((function (type) {
							return type.instantiate$LInstantiationContext$(instantiationContext);
						}));
						propertyExpr._typeArgs = types$0;
					}
				} else {
					if (expr instanceof ArrayLiteralExpression) {
						srcType = expr.getType$();
						if (srcType != null) {
							type$3 = srcType.instantiate$LInstantiationContext$(instantiationContext);
							expr._type = type$3;
						}
					} else {
						if (expr instanceof MapLiteralExpression) {
							srcType = expr.getType$();
							if (srcType != null) {
								type$4 = srcType.instantiate$LInstantiationContext$(instantiationContext);
								expr._type = type$4;
							}
						} else {
							if (expr instanceof AsExpression) {
								srcType = expr.getType$();
								if (srcType != null) {
									type$5 = srcType.instantiate$LInstantiationContext$(instantiationContext);
									expr._type = type$5;
								}
							} else {
								if (expr instanceof AsNoConvertExpression) {
									srcType = expr.getType$();
									if (srcType != null) {
										type$6 = srcType.instantiate$LInstantiationContext$(instantiationContext);
										expr._type = type$6;
									}
								} else {
									if (expr instanceof ClassExpression) {
										srcType = expr.getType$();
										if (srcType != null) {
											type$7 = srcType.instantiate$LInstantiationContext$(instantiationContext);
											expr._parsedType = type$7;
										}
									} else {
										if (expr instanceof LocalExpression) {
											local$0 = LocalVariable$getInstantiated$LLocalVariable$(expr._local);
											expr._local = local$0;
										} else {
											if (expr instanceof InstanceofExpression) {
												instanceofExpr = expr;
												type$8 = instanceofExpr._expectedType.instantiate$LInstantiationContext$(instantiationContext);
												instanceofExpr._expectedType = type$8;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}
	return onExpr(this);
};


function Expression$instantiate$LExpression$LInstantiationContext$($this, instantiationContext) {
	var onExpr;
	function onExpr(expr) {
		var srcType;
		var propertyExpr;
		var srcTypes;
		var instanceofExpr;
		var type$0;
		var type$1;
		var type$2;
		var types$0;
		var type$3;
		var type$4;
		var type$5;
		var type$6;
		var type$7;
		var local$0;
		var type$8;
		if (expr instanceof NullExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				type$0 = srcType.instantiate$LInstantiationContext$(instantiationContext);
				expr._type = type$0;
			}
		} else {
			if (expr instanceof NewExpression) {
				srcType = expr.getType$();
				if (srcType != null) {
					type$1 = srcType.instantiate$LInstantiationContext$(instantiationContext);
					expr._type = type$1;
				}
			} else {
				if (expr instanceof PropertyExpression) {
					propertyExpr = expr;
					srcType = expr.getType$();
					if (srcType != null) {
						type$2 = srcType.instantiate$LInstantiationContext$(instantiationContext);
						propertyExpr._type = type$2;
					}
					srcTypes = propertyExpr._typeArgs;
					if (srcTypes != null) {
						types$0 = srcTypes.map((function (type) {
							return type.instantiate$LInstantiationContext$(instantiationContext);
						}));
						propertyExpr._typeArgs = types$0;
					}
				} else {
					if (expr instanceof ArrayLiteralExpression) {
						srcType = expr.getType$();
						if (srcType != null) {
							type$3 = srcType.instantiate$LInstantiationContext$(instantiationContext);
							expr._type = type$3;
						}
					} else {
						if (expr instanceof MapLiteralExpression) {
							srcType = expr.getType$();
							if (srcType != null) {
								type$4 = srcType.instantiate$LInstantiationContext$(instantiationContext);
								expr._type = type$4;
							}
						} else {
							if (expr instanceof AsExpression) {
								srcType = expr.getType$();
								if (srcType != null) {
									type$5 = srcType.instantiate$LInstantiationContext$(instantiationContext);
									expr._type = type$5;
								}
							} else {
								if (expr instanceof AsNoConvertExpression) {
									srcType = expr.getType$();
									if (srcType != null) {
										type$6 = srcType.instantiate$LInstantiationContext$(instantiationContext);
										expr._type = type$6;
									}
								} else {
									if (expr instanceof ClassExpression) {
										srcType = expr.getType$();
										if (srcType != null) {
											type$7 = srcType.instantiate$LInstantiationContext$(instantiationContext);
											expr._parsedType = type$7;
										}
									} else {
										if (expr instanceof LocalExpression) {
											local$0 = LocalVariable$getInstantiated$LLocalVariable$(expr._local);
											expr._local = local$0;
										} else {
											if (expr instanceof InstanceofExpression) {
												instanceofExpr = expr;
												type$8 = instanceofExpr._expectedType.instantiate$LInstantiationContext$(instantiationContext);
												instanceofExpr._expectedType = type$8;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}
	return onExpr($this);
};

Expression.instantiate$LExpression$LInstantiationContext$ = Expression$instantiate$LExpression$LInstantiationContext$;

Expression.prototype.getToken$ = function () {
	return this._token;
};


function Expression$getToken$LExpression$($this) {
	return $this._token;
};

Expression.getToken$LExpression$ = Expression$getToken$LExpression$;

Expression.prototype.getHolderType$ = function () {
	return null;
};


Expression.prototype.isClassSpecifier$ = function () {
	return false;
};


Expression.prototype.forEachExpression$F$LExpression$B$ = function (cb) {
	var $this = this;
	return this.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, _) {
		return cb(expr);
	}));
};


function Expression$forEachExpression$LExpression$F$LExpression$B$($this, cb) {
	return $this.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, _) {
		return cb(expr);
	}));
};

Expression.forEachExpression$LExpression$F$LExpression$B$ = Expression$forEachExpression$LExpression$F$LExpression$B$;

Expression.prototype.assertIsAssignable$LAnalysisContext$LToken$LType$ = function (context, token, type) {
	context.errors.push(new CompileError(token, "left-hand-side expression is not assignable"));
	return false;
};


function Expression$assertIsAssignable$LAnalysisContext$LToken$LType$LType$(context, token, lhsType, rhsType) {
	if (! lhsType.isAssignable$()) {
		context.errors.push(new CompileError(token, "left-hand-side expression is not assignable"));
		return false;
	}
	if (! rhsType.isConvertibleTo$LType$(lhsType)) {
		context.errors.push(new CompileError(token, "cannot assign a value of type '" + rhsType.toString() + "' to '" + lhsType.toString() + "'"));
		return false;
	}
	return true;
};

Expression.assertIsAssignable$LAnalysisContext$LToken$LType$LType$ = Expression$assertIsAssignable$LAnalysisContext$LToken$LType$LType$;

function Expression$getDefaultValueExpressionOf$LType$(type) {
	return (type.equals$LType$(Type.booleanType) ? new BooleanLiteralExpression(new Token$1("false", false)) : type.equals$LType$(Type.integerType) ? new IntegerLiteralExpression(new Token$1("0", false)) : type.equals$LType$(Type.numberType) ? new NumberLiteralExpression(new Token$1("0", false)) : type.equals$LType$(Type.stringType) ? new StringLiteralExpression(new Token$1("\"\"", false)) : new NullExpression(new Token$1("null", false), type));
};

Expression.getDefaultValueExpressionOf$LType$ = Expression$getDefaultValueExpressionOf$LType$;

function LeafExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([LeafExpression], Expression);
LeafExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function OperatorExpression(token) {
	this._stash = {};
	this._token = token;
};

function OperatorExpression$0(that) {
	Expression$0.call(this, that);
};

$__jsx_extend([OperatorExpression, OperatorExpression$0], Expression);
OperatorExpression.prototype.isConvertibleTo$LAnalysisContext$LExpression$LType$B = function (context, expr, type, mayUnbox) {
	var exprType;
	var this$0;
	this$0 = expr.getType$();
	exprType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	return (mayUnbox && type instanceof PrimitiveType && exprType instanceof ObjectType && exprType.getClassDef$() == type.getClassDef$() ? true : exprType.isConvertibleTo$LType$(type));
};


function OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B($this, context, expr, type, mayUnbox) {
	var exprType;
	var this$0;
	this$0 = expr.getType$();
	exprType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	return (mayUnbox && type instanceof PrimitiveType && exprType instanceof ObjectType && exprType.getClassDef$() == type.getClassDef$() ? true : exprType.isConvertibleTo$LType$(type));
};

OperatorExpression.isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B = OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B;

OperatorExpression.prototype.assertIsConvertibleTo$LAnalysisContext$LExpression$LType$B = function (context, expr, type, mayUnbox) {
	var _token$0;
	if (! OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, expr, type, mayUnbox)) {
		context.errors.push(new CompileError(_token$0 = this._token, "cannot apply operator '" + _token$0._value + "' to type '" + expr.getType$().toString() + "'"));
		return false;
	}
	return true;
};


function OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B($this, context, expr, type, mayUnbox) {
	var _token$0;
	if (! OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B($this, context, expr, type, mayUnbox)) {
		context.errors.push(new CompileError(_token$0 = $this._token, "cannot apply operator '" + _token$0._value + "' to type '" + expr.getType$().toString() + "'"));
		return false;
	}
	return true;
};

OperatorExpression.assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B = OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B;

function LocalExpression(token, local) {
	this._stash = {};
	this._token = token;
	this._cloned = false;
	this._local = local;
};

$__jsx_extend([LocalExpression], LeafExpression);
LocalExpression.prototype.clone$ = function () {
	var that;
	that = new LocalExpression(this._token, this._local);
	that._cloned = true;
	return that;
};


LocalExpression.prototype.getLocal$ = function () {
	return this._local;
};


function LocalExpression$getLocal$LLocalExpression$($this) {
	return $this._local;
};

LocalExpression.getLocal$LLocalExpression$ = LocalExpression$getLocal$LLocalExpression$;

LocalExpression.prototype.setLocal$LLocalVariable$ = function (local) {
	this._local = local;
};


function LocalExpression$setLocal$LLocalExpression$LLocalVariable$($this, local) {
	$this._local = local;
};

LocalExpression.setLocal$LLocalExpression$LLocalVariable$ = LocalExpression$setLocal$LLocalExpression$LLocalVariable$;

LocalExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "LocalExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), LocalVariable$serialize$LLocalVariable$(this._local) ];
};


LocalExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var statement$0;
	if (parentExpr instanceof AssignmentExpression && parentExpr._expr1 == this && parentExpr._token._value === "=" || parentExpr == null && (statement$0 = context.statement) instanceof ForInStatement && statement$0._lhsExpr == this) {
	} else {
		this._local.touchVariable$LAnalysisContext$LToken$B(context, this._token, false);
		if (this._local._type == null) {
			return false;
		}
	}
	return true;
};


LocalExpression.prototype.getType$ = function () {
	return this._local._type;
};


LocalExpression.prototype.assertIsAssignable$LAnalysisContext$LToken$LType$ = function (context, token, type) {
	if (this._local._type == null) {
		if (type.equals$LType$(Type.nullType)) {
			context.errors.push(new CompileError(token, "cannot assign null without type annotation to a value of undetermined type"));
			return false;
		}
		LocalVariable$setType$LLocalVariable$LType$(this._local, type.asAssignableType$());
	} else {
		if (! type.isConvertibleTo$LType$(this._local._type)) {
			context.errors.push(new CompileError(token, "cannot assign a value of type '" + type.toString() + "' to '" + this._local._type.toString() + "'"));
			return false;
		}
	}
	this._local.touchVariable$LAnalysisContext$LToken$B(context, this._token, true);
	return true;
};


function ClassExpression(token, parsedType) {
	this._stash = {};
	this._token = token;
	this._parsedType = parsedType;
};

$__jsx_extend([ClassExpression], LeafExpression);
ClassExpression.prototype.clone$ = function () {
	return new ClassExpression(this._token, this._parsedType);
};


ClassExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "ClassExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), this._parsedType.toString() ];
};


ClassExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


ClassExpression.prototype.getType$ = function () {
	return this._parsedType;
};


ClassExpression.prototype.setType$LType$ = function (type) {
	this._parsedType = type;
};


function ClassExpression$setType$LClassExpression$LType$($this, type) {
	$this._parsedType = type;
};

ClassExpression.setType$LClassExpression$LType$ = ClassExpression$setType$LClassExpression$LType$;

ClassExpression.prototype.isClassSpecifier$ = function () {
	return true;
};


ClassExpression.prototype.assertIsAssignable$LAnalysisContext$LToken$LType$ = function (context, token, type) {
	context.errors.push(new CompileError(token, "cannot modify a class definition"));
	return false;
};


function NullExpression(token, type) {
	this._stash = {};
	this._token = token;
	this._type = type;
};

$__jsx_extend([NullExpression], LeafExpression);
NullExpression.prototype.clone$ = function () {
	return new NullExpression(this._token, this._type);
};


NullExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "NullExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), this._type.toString() ];
};


NullExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


NullExpression.prototype.getType$ = function () {
	return this._type;
};


NullExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function NullExpression$setType$LNullExpression$LType$($this, type) {
	$this._type = type;
};

NullExpression.setType$LNullExpression$LType$ = NullExpression$setType$LNullExpression$LType$;

function BooleanLiteralExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([BooleanLiteralExpression], LeafExpression);
BooleanLiteralExpression.prototype.clone$ = function () {
	return new BooleanLiteralExpression(this._token);
};


BooleanLiteralExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "BooleanLiteralExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]) ];
};


BooleanLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


BooleanLiteralExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


function IntegerLiteralExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([IntegerLiteralExpression], LeafExpression);
IntegerLiteralExpression.prototype.clone$ = function () {
	return new IntegerLiteralExpression(this._token);
};


IntegerLiteralExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "IntegerLiteralExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]) ];
};


IntegerLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


IntegerLiteralExpression.prototype.getType$ = function () {
	return Type.integerType;
};


function NumberLiteralExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([NumberLiteralExpression], LeafExpression);
NumberLiteralExpression.prototype.clone$ = function () {
	return new NumberLiteralExpression(this._token);
};


NumberLiteralExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "NumberLiteralExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]) ];
};


NumberLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


NumberLiteralExpression.prototype.getType$ = function () {
	return Type.numberType;
};


function StringLiteralExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([StringLiteralExpression], LeafExpression);
StringLiteralExpression.prototype.clone$ = function () {
	return new StringLiteralExpression(this._token);
};


StringLiteralExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "StringLiteralExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]) ];
};


StringLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


StringLiteralExpression.prototype.getType$ = function () {
	return Type.stringType;
};


function RegExpLiteralExpression(token) {
	RegExpLiteralExpression$0.call(this, token, null);
};

function RegExpLiteralExpression$0(token, type) {
	this._stash = {};
	this._token = token;
	this._type = type;
};

$__jsx_extend([RegExpLiteralExpression, RegExpLiteralExpression$0], LeafExpression);
RegExpLiteralExpression.prototype.clone$ = function () {
	return new RegExpLiteralExpression$0(this._token, this._type);
};


RegExpLiteralExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "RegExpLiteralExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]) ];
};


RegExpLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var classDef;
	classDef = Parser$lookup$LParser$ALCompileError$LToken$S(context.parser, context.errors, this._token, "RegExp");
	if (classDef == null) {
		throw new Error("could not find definition for RegExp");
	}
	this._type = new ObjectType(classDef);
	return true;
};


RegExpLiteralExpression.prototype.getType$ = function () {
	return this._type;
};


function ArrayLiteralExpression(token, exprs, type) {
	this._stash = {};
	this._token = token;
	this._exprs = exprs;
	this._type = type;
};

$__jsx_extend([ArrayLiteralExpression], Expression);
ArrayLiteralExpression.prototype.clone$ = function () {
	return new ArrayLiteralExpression(this._token, Cloner$x2E$x3CExpression$x3E$cloneArray$ALExpression$(this._exprs), this._type);
};


ArrayLiteralExpression.prototype.getExprs$ = function () {
	return this._exprs;
};


function ArrayLiteralExpression$getExprs$LArrayLiteralExpression$($this) {
	return $this._exprs;
};

ArrayLiteralExpression.getExprs$LArrayLiteralExpression$ = ArrayLiteralExpression$getExprs$LArrayLiteralExpression$;

ArrayLiteralExpression.prototype.getType$ = function () {
	return this._type;
};


ArrayLiteralExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function ArrayLiteralExpression$setType$LArrayLiteralExpression$LType$($this, type) {
	$this._type = type;
};

ArrayLiteralExpression.setType$LArrayLiteralExpression$LType$ = ArrayLiteralExpression$setType$LArrayLiteralExpression$LType$;

ArrayLiteralExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	var serializeNullable$v$0;
	return [ "ArrayLiteralExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), Serializer$x2E$x3CExpression$x3E$serializeArray$ALExpression$(this._exprs), (serializeNullable$v$0 = this._type, serializeNullable$v$0 == null ? null : serializeNullable$v$0.toString()) ];
};


ArrayLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var $this = this;
	var succeeded;
	var i;
	var classDef;
	var expectedType;
	var elementType;
	var this$0;
	var getTypeArguments$this$0;
	var _type$0;
	succeeded = true;
	for (i = 0; i < this._exprs.length; ++ i) {
		if (! this._exprs[i].analyze$LAnalysisContext$LExpression$(context, this)) {
			succeeded = false;
		} else {
			if (this._exprs[i].getType$().equals$LType$(Type.voidType)) {
				context.errors.push(new CompileError(this._token, "cannot assign void to an array"));
				succeeded = false;
			}
		}
	}
	if (! succeeded) {
		return false;
	}
	if (this._type != null) {
		if ((_type$0 = this._type) instanceof ObjectType && (classDef = _type$0.getClassDef$()) instanceof InstantiatedClassDefinition && classDef._templateClassDef._className === "Array") {
		} else {
			context.errors.push(new CompileError(this._token, "the type specified after ':' is not an array type"));
			return false;
		}
		this$0 = (getTypeArguments$this$0 = this._type.getClassDef$(), getTypeArguments$this$0._typeArguments)[0];
		expectedType = (this$0 instanceof PrimitiveType ? new NullableType(this$0) : this$0);
		for (i = 0; i < this._exprs.length; ++ i) {
			elementType = this._exprs[i].getType$();
			if (! elementType.isConvertibleTo$LType$(expectedType)) {
				context.errors.push(new CompileError(this._token, "cannot assign '" + elementType.toString() + "' to an array of '" + expectedType.toString() + "'"));
				succeeded = false;
			}
		}
	} else {
		elementType = Type$calcLeastCommonAncestor$ALType$B(this._exprs.map((function (expr) {
			return expr.getType$();
		})), true);
		if (elementType == null || elementType.equals$LType$(Type.nullType)) {
			context.errors.push(new CompileError(this._token, "could not deduce array type, please specify"));
			return false;
		}
		if (elementType.equals$LType$(Type.integerType)) {
			elementType = Type.numberType;
		}
		elementType = (elementType instanceof NullableType ? elementType._baseType : elementType);
		this._type = new ObjectType(Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: this._token, _className: "Array", _typeArgs: [ elementType ]}), context.postInstantiationCallback));
	}
	return succeeded;
};


ArrayLiteralExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return (! Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._exprs) ? false : true);
};


function MapLiteralElement(key, expr) {
	this._key = key;
	this._expr = expr;
};

$__jsx_extend([MapLiteralElement], Object);
function MapLiteralElement$getKey$LMapLiteralElement$($this) {
	return $this._key;
};

MapLiteralElement.getKey$LMapLiteralElement$ = MapLiteralElement$getKey$LMapLiteralElement$;

function MapLiteralElement$getExpr$LMapLiteralElement$($this) {
	return $this._expr;
};

MapLiteralElement.getExpr$LMapLiteralElement$ = MapLiteralElement$getExpr$LMapLiteralElement$;

function MapLiteralElement$setExpr$LMapLiteralElement$LExpression$($this, expr) {
	$this._expr = expr;
};

MapLiteralElement.setExpr$LMapLiteralElement$LExpression$ = MapLiteralElement$setExpr$LMapLiteralElement$LExpression$;

function MapLiteralElement$serialize$LMapLiteralElement$($this) {
	var serialize$this$0;
	return [ (serialize$this$0 = $this._key, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), $this._expr.serialize$() ];
};

MapLiteralElement.serialize$LMapLiteralElement$ = MapLiteralElement$serialize$LMapLiteralElement$;

function MapLiteralExpression(token, elements, type) {
	this._stash = {};
	this._token = token;
	this._elements = elements;
	this._type = type;
};

$__jsx_extend([MapLiteralExpression], Expression);
MapLiteralExpression.prototype.clone$ = function () {
	var ret;
	var i;
	ret = new MapLiteralExpression(this._token, [], this._type);
	for (i = 0; i < this._elements.length; ++ i) {
		ret._elements[i] = ({_key: this._elements[i]._key, _expr: this._elements[i]._expr.clone$()});
	}
	return ret;
};


MapLiteralExpression.prototype.getElements$ = function () {
	return this._elements;
};


function MapLiteralExpression$getElements$LMapLiteralExpression$($this) {
	return $this._elements;
};

MapLiteralExpression.getElements$LMapLiteralExpression$ = MapLiteralExpression$getElements$LMapLiteralExpression$;

MapLiteralExpression.prototype.getType$ = function () {
	return this._type;
};


MapLiteralExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function MapLiteralExpression$setType$LMapLiteralExpression$LType$($this, type) {
	$this._type = type;
};

MapLiteralExpression.setType$LMapLiteralExpression$LType$ = MapLiteralExpression$setType$LMapLiteralExpression$LType$;

MapLiteralExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	var serializeNullable$v$0;
	return [ "MapLiteralExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), Serializer$x2E$x3CMapLiteralElement$x3E$serializeArray$ALMapLiteralElement$(this._elements), (serializeNullable$v$0 = this._type, serializeNullable$v$0 == null ? null : serializeNullable$v$0.toString()) ];
};


MapLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var $this = this;
	var succeeded;
	var i;
	var classDef;
	var expectedType;
	var elementType;
	var _type$0;
	var _type$1;
	succeeded = true;
	for (i = 0; i < this._elements.length; ++ i) {
		if (! this._elements[i]._expr.analyze$LAnalysisContext$LExpression$(context, this)) {
			succeeded = false;
		} else {
			if (this._elements[i]._expr.getType$().equals$LType$(Type.voidType)) {
				context.errors.push(new CompileError(this._token, "cannot assign void to a map"));
				succeeded = false;
			}
		}
	}
	if (! succeeded) {
		return false;
	}
	if ((_type$1 = this._type) != null && _type$1 == Type.variantType) {
	} else {
		if ((_type$0 = this._type) != null && _type$0 instanceof ObjectType) {
			classDef = this._type.getClassDef$();
			if (! (classDef instanceof InstantiatedClassDefinition && classDef._templateClassDef._className === "Map")) {
				context.errors.push(new CompileError(this._token, "specified type is not a map type"));
				return false;
			}
			expectedType = this._type._typeArguments[0];
			for (i = 0; i < this._elements.length; ++ i) {
				elementType = this._elements[i]._expr.getType$();
				if (! elementType.isConvertibleTo$LType$(expectedType)) {
					context.errors.push(new CompileError(this._token, "cannot assign '" + elementType.toString() + "' to a map of '" + expectedType.toString() + "'"));
					succeeded = false;
				}
			}
		} else {
			if (this._type != null) {
				context.errors.push(new CompileError(this._token, "invalid type for a map literal"));
				return false;
			} else {
				elementType = Type$calcLeastCommonAncestor$ALType$B(this._elements.map((function (elt) {
					return elt._expr.getType$();
				})), true);
				if (elementType == null || elementType.equals$LType$(Type.nullType)) {
					context.errors.push(new CompileError(this._token, "could not deduce map type, please specify"));
					return false;
				}
				if (elementType.equals$LType$(Type.integerType)) {
					elementType = Type.numberType;
				}
				elementType = (elementType instanceof NullableType ? elementType._baseType : elementType);
				this._type = new ObjectType(Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: this._token, _className: "Map", _typeArgs: [ elementType ]}), context.postInstantiationCallback));
			}
		}
	}
	return succeeded;
};


MapLiteralExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	var i;
	for (i = 0; i < this._elements.length; ++ i) {
		if (! cb(this._elements[i]._expr, (function (elements, index) {
			return (function (expr) {
				MapLiteralElement$setExpr$LMapLiteralElement$LExpression$(elements[index], expr);
			});
		})(this._elements, i))) {
			return false;
		}
	}
	return true;
};


function ThisExpression(token, classDef) {
	this._stash = {};
	this._token = token;
	this._classDef = classDef;
};

$__jsx_extend([ThisExpression], LeafExpression);
ThisExpression.prototype.clone$ = function () {
	return new ThisExpression(this._token, this._classDef);
};


ThisExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	var serializeNullable$v$0;
	return [ "ThisExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), (serializeNullable$v$0 = this._classDef, serializeNullable$v$0 == null ? null : ClassDefinition$serialize$LClassDefinition$(serializeNullable$v$0)) ];
};


ThisExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var rootFuncDef;
	rootFuncDef = context.funcDef;
	if (rootFuncDef != null) {
		while (rootFuncDef._parent != null) {
			rootFuncDef = rootFuncDef._parent;
		}
	}
	if (rootFuncDef == null || (rootFuncDef._flags & 8) !== 0) {
		context.errors.push(new CompileError(this._token, "cannot use 'this' outside of a member function"));
		return false;
	}
	this._classDef = rootFuncDef._classDef;
	return true;
};


ThisExpression.prototype.getType$ = function () {
	return new ObjectType(this._classDef);
};


ThisExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function FunctionExpression(token, funcDef) {
	this._stash = {};
	this._token = token;
	this._funcDef = funcDef;
};

$__jsx_extend([FunctionExpression], Expression);
FunctionExpression.prototype.clone$ = function () {
	return new FunctionExpression(this._token, this._funcDef);
};


FunctionExpression.prototype.getFuncDef$ = function () {
	return this._funcDef;
};


function FunctionExpression$getFuncDef$LFunctionExpression$($this) {
	return $this._funcDef;
};

FunctionExpression.getFuncDef$LFunctionExpression$ = FunctionExpression$getFuncDef$LFunctionExpression$;

FunctionExpression.prototype.setFuncDef$LMemberFunctionDefinition$ = function (funcDef) {
	this._funcDef = funcDef;
};


function FunctionExpression$setFuncDef$LFunctionExpression$LMemberFunctionDefinition$($this, funcDef) {
	$this._funcDef = funcDef;
};

FunctionExpression.setFuncDef$LFunctionExpression$LMemberFunctionDefinition$ = FunctionExpression$setFuncDef$LFunctionExpression$LMemberFunctionDefinition$;

FunctionExpression.prototype.serialize$ = function () {
	return [ "FunctionExpression", this._funcDef.serialize$() ];
};


FunctionExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	if (! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(this)) {
		context.errors.push(new CompileError(this._token, "argument types were not automatically deductable, please specify them by hand"));
		return false;
	}
	MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(this._funcDef, context);
	return true;
};


FunctionExpression.prototype.getType$ = function () {
	return this._funcDef.getType$();
};


FunctionExpression.prototype.argumentTypesAreIdentified$ = function () {
	var argTypes;
	var i;
	var argTypes$len$0;
	argTypes = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._funcDef);
	for ((i = 0, argTypes$len$0 = argTypes.length); i < argTypes$len$0; ++ i) {
		if (argTypes[i] == null) {
			return false;
		}
	}
	return true;
};


function FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$($this) {
	var argTypes;
	var i;
	var argTypes$len$0;
	argTypes = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._funcDef);
	for ((i = 0, argTypes$len$0 = argTypes.length); i < argTypes$len$0; ++ i) {
		if (argTypes[i] == null) {
			return false;
		}
	}
	return true;
};

FunctionExpression.argumentTypesAreIdentified$LFunctionExpression$ = FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$;

FunctionExpression.prototype.typesAreIdentified$ = function () {
	return (! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(this) ? false : this._funcDef._returnType == null ? false : true);
};


function FunctionExpression$typesAreIdentified$LFunctionExpression$($this) {
	return (! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$($this) ? false : $this._funcDef._returnType == null ? false : true);
};

FunctionExpression.typesAreIdentified$LFunctionExpression$ = FunctionExpression$typesAreIdentified$LFunctionExpression$;

FunctionExpression.prototype.deductTypeIfUnknown$LAnalysisContext$LResolvedFunctionType$ = function (context, type) {
	return (! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$(this._funcDef, context, type) ? false : true);
};


function FunctionExpression$deductTypeIfUnknown$LFunctionExpression$LAnalysisContext$LResolvedFunctionType$($this, context, type) {
	return (! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$($this._funcDef, context, type) ? false : true);
};

FunctionExpression.deductTypeIfUnknown$LFunctionExpression$LAnalysisContext$LResolvedFunctionType$ = FunctionExpression$deductTypeIfUnknown$LFunctionExpression$LAnalysisContext$LResolvedFunctionType$;

FunctionExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function UnaryExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([UnaryExpression], OperatorExpression);
UnaryExpression.prototype.getExpr$ = function () {
	return this._expr;
};


function UnaryExpression$getExpr$LUnaryExpression$($this) {
	return $this._expr;
};

UnaryExpression.getExpr$LUnaryExpression$ = UnaryExpression$getExpr$LUnaryExpression$;

UnaryExpression.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function UnaryExpression$setExpr$LUnaryExpression$LExpression$($this, expr) {
	$this._expr = expr;
};

UnaryExpression.setExpr$LUnaryExpression$LExpression$ = UnaryExpression$setExpr$LUnaryExpression$LExpression$;

UnaryExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "UnaryExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), this._expr.serialize$() ];
};


UnaryExpression.prototype._analyze$LAnalysisContext$ = function (context) {
	var _token$0;
	if (! this._expr.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	if (this._expr.getType$().equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(_token$0 = this._token, "cannot apply operator '" + _token$0._value + "' against void"));
		return false;
	}
	return true;
};


function UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$($this, context) {
	var _token$0;
	if (! $this._expr.analyze$LAnalysisContext$LExpression$(context, $this)) {
		return false;
	}
	if ($this._expr.getType$().equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(_token$0 = $this._token, "cannot apply operator '" + _token$0._value + "' against void"));
		return false;
	}
	return true;
};

UnaryExpression._analyze$LUnaryExpression$LAnalysisContext$ = UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$;

UnaryExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return cb(this._expr, (function (expr) {
		$this._expr = expr;
	}));
};


function BitwiseNotExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([BitwiseNotExpression], UnaryExpression);
BitwiseNotExpression.prototype.clone$ = function () {
	return new BitwiseNotExpression(this._token, this._expr.clone$());
};


BitwiseNotExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context) ? false : ! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr, Type.numberType, false) ? false : true);
};


BitwiseNotExpression.prototype.getType$ = function () {
	return Type.integerType;
};


function InstanceofExpression(operatorToken, expr, expectedType) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
	this._expectedType = expectedType;
};

$__jsx_extend([InstanceofExpression], UnaryExpression);
InstanceofExpression.prototype.clone$ = function () {
	return new InstanceofExpression(this._token, this._expr.clone$(), this._expectedType);
};


InstanceofExpression.prototype.getExpectedType$ = function () {
	return this._expectedType;
};


function InstanceofExpression$getExpectedType$LInstanceofExpression$($this) {
	return $this._expectedType;
};

InstanceofExpression.getExpectedType$LInstanceofExpression$ = InstanceofExpression$getExpectedType$LInstanceofExpression$;

InstanceofExpression.prototype.setExpectedType$LType$ = function (type) {
	this._expectedType = type;
};


function InstanceofExpression$setExpectedType$LInstanceofExpression$LType$($this, type) {
	$this._expectedType = type;
};

InstanceofExpression.setExpectedType$LInstanceofExpression$LType$ = InstanceofExpression$setExpectedType$LInstanceofExpression$LType$;

InstanceofExpression.prototype.serialize$ = function () {
	return [ "InstanceofExpression", this._expr.serialize$(), this._expectedType.toString() ];
};


InstanceofExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var exprType;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	exprType = this._expr.getType$();
	if (exprType instanceof ObjectType) {
	} else {
		if (exprType.equals$LType$(Type.variantType)) {
		} else {
			context.errors.push(new CompileError(this._token, "operator 'instanceof' is only applicable to an object or a variant"));
			return false;
		}
	}
	return true;
};


InstanceofExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


function AsExpression(operatorToken, expr, type) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
	this._type = type;
};

$__jsx_extend([AsExpression], UnaryExpression);
AsExpression.prototype.clone$ = function () {
	return new AsExpression(this._token, this._expr.clone$(), this._type);
};


AsExpression.prototype.serialize$ = function () {
	return [ "AsExpression", this._expr.serialize$(), this._type.toString() ];
};


AsExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var exprType;
	var success;
	var deducedType;
	var this$0;
	var _type$0;
	var _type$1;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	if (this._type instanceof NullableType) {
		context.errors.push(new CompileError(this._token, "right operand of 'as' expression cannot be a Nullable<T> type"));
		return false;
	}
	if (this._expr.getType$().isConvertibleTo$LType$(this._type)) {
		return true;
	}
	this$0 = this._expr.getType$();
	exprType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	success = false;
	if (exprType.equals$LType$(Type.nullType)) {
		if ((_type$0 = this._type) instanceof ObjectType || _type$0 instanceof FunctionType) {
			success = true;
		}
	} else {
		if (exprType instanceof PrimitiveType) {
			if (this._type instanceof PrimitiveType) {
				success = true;
			}
		} else {
			if (exprType.equals$LType$(Type.variantType)) {
				success = true;
			} else {
				if (exprType instanceof ObjectType) {
					if ((_type$1 = this._type) instanceof ObjectType && _type$1.isConvertibleTo$LType$(exprType)) {
						success = true;
					}
				} else {
					if (this._expr instanceof PropertyExpression && exprType instanceof FunctionType && this._type instanceof StaticFunctionType) {
						deducedType = PropertyExpression$deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B(this._expr, context, this._token, this._type._argTypes, true);
						if (deducedType != null) {
							exprType = deducedType;
							if (deducedType._returnType.equals$LType$(this._type._returnType)) {
								success = true;
							}
						}
					}
				}
			}
		}
	}
	if (! success) {
		context.errors.push(new CompileError(this._token, "cannot convert a value of type '" + exprType.toString() + "' to '" + this._type.toString() + "'"));
		return false;
	}
	return true;
};


AsExpression.prototype.getType$ = function () {
	return this._type;
};


AsExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function AsExpression$setType$LAsExpression$LType$($this, type) {
	$this._type = type;
};

AsExpression.setType$LAsExpression$LType$ = AsExpression$setType$LAsExpression$LType$;

function AsNoConvertExpression(operatorToken, expr, type) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
	this._type = type;
};

$__jsx_extend([AsNoConvertExpression], UnaryExpression);
AsNoConvertExpression.prototype.clone$ = function () {
	return new AsNoConvertExpression(this._token, this._expr.clone$(), this._type);
};


AsNoConvertExpression.prototype.serialize$ = function () {
	return [ "AsNoConvertExpression", this._expr.serialize$(), this._type.toString() ];
};


AsNoConvertExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var srcType;
	var _type$0;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	srcType = this._expr.getType$();
	if (srcType.equals$LType$(Type.nullType) && ! ((_type$0 = this._type) instanceof NullableType || _type$0 instanceof ObjectType || _type$0 instanceof FunctionType)) {
		context.errors.push(new CompileError(this._token, "'" + srcType.toString() + "' cannot be treated as a value of type '" + this._type.toString() + "'"));
		return false;
	}
	return true;
};


AsNoConvertExpression.prototype.getType$ = function () {
	return this._type;
};


AsNoConvertExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function AsNoConvertExpression$setType$LAsNoConvertExpression$LType$($this, type) {
	$this._type = type;
};

AsNoConvertExpression.setType$LAsNoConvertExpression$LType$ = AsNoConvertExpression$setType$LAsNoConvertExpression$LType$;

function LogicalNotExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([LogicalNotExpression], UnaryExpression);
LogicalNotExpression.prototype.clone$ = function () {
	return new LogicalNotExpression(this._token, this._expr.clone$());
};


LogicalNotExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var resolveIfNullable$this$0;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	if ((resolveIfNullable$this$0 = this._expr.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0).equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(this._token, "cannot apply operator '!' against void"));
		return false;
	}
	return true;
};


LogicalNotExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


function IncrementExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([IncrementExpression], UnaryExpression);
IncrementExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ this._getClassName$(), (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), this._expr.serialize$() ];
};


IncrementExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var exprType;
	var _token$0;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	exprType = this._expr.getType$();
	if ((exprType instanceof NullableType ? exprType._baseType : exprType).equals$LType$(Type.integerType) || (exprType instanceof NullableType ? exprType._baseType : exprType).equals$LType$(Type.numberType)) {
	} else {
		context.errors.push(new CompileError(_token$0 = this._token, "cannot apply operator '" + _token$0._value + "' to a non-number"));
		return false;
	}
	return (! this._expr.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, exprType) ? false : true);
};


IncrementExpression.prototype.getType$ = function () {
	var this$0;
	this$0 = this._expr.getType$();
	return (this$0 instanceof NullableType ? this$0._baseType : this$0);
};


function PostIncrementExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([PostIncrementExpression], IncrementExpression);
PostIncrementExpression.prototype.clone$ = function () {
	return new PostIncrementExpression(this._token, this._expr.clone$());
};


PostIncrementExpression.prototype._getClassName$ = function () {
	return "PostIncrementExpression";
};


function PreIncrementExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([PreIncrementExpression], IncrementExpression);
PreIncrementExpression.prototype.clone$ = function () {
	return new PreIncrementExpression(this._token, this._expr.clone$());
};


PreIncrementExpression.prototype._getClassName$ = function () {
	return "PreIncrementExpression";
};


function PropertyExpression(operatorToken, expr1, identifierToken, typeArgs) {
	PropertyExpression$0.call(this, operatorToken, expr1, identifierToken, typeArgs, null);
};

function PropertyExpression$0(operatorToken, expr1, identifierToken, typeArgs, type) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr1;
	this._identifierToken = identifierToken;
	this._typeArgs = typeArgs;
	this._type = (type != null ? type : null);
	this._isInner = false;
};

$__jsx_extend([PropertyExpression, PropertyExpression$0], UnaryExpression);
PropertyExpression.prototype.clone$ = function () {
	var propExpr;
	propExpr = new PropertyExpression$0(this._token, this._expr.clone$(), this._identifierToken, this._typeArgs, this._type);
	propExpr._isInner = this._isInner;
	return propExpr;
};


PropertyExpression.prototype.getIdentifierToken$ = function () {
	return this._identifierToken;
};


function PropertyExpression$getIdentifierToken$LPropertyExpression$($this) {
	return $this._identifierToken;
};

PropertyExpression.getIdentifierToken$LPropertyExpression$ = PropertyExpression$getIdentifierToken$LPropertyExpression$;

PropertyExpression.prototype.getTypeArguments$ = function () {
	return this._typeArgs;
};


function PropertyExpression$getTypeArguments$LPropertyExpression$($this) {
	return $this._typeArgs;
};

PropertyExpression.getTypeArguments$LPropertyExpression$ = PropertyExpression$getTypeArguments$LPropertyExpression$;

PropertyExpression.prototype.setTypeArguments$ALType$ = function (types) {
	this._typeArgs = types;
};


function PropertyExpression$setTypeArguments$LPropertyExpression$ALType$($this, types) {
	$this._typeArgs = types;
};

PropertyExpression.setTypeArguments$LPropertyExpression$ALType$ = PropertyExpression$setTypeArguments$LPropertyExpression$ALType$;

PropertyExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	var serializeNullable$v$0;
	return [ "PropertyExpression", this._expr.serialize$(), (serialize$this$0 = this._identifierToken, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), (serializeNullable$v$0 = this._type, serializeNullable$v$0 == null ? null : serializeNullable$v$0.toString()) ];
};


PropertyExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var $this = this;
	var exprType;
	var classDef;
	var _identifierToken$0;
	var _type$0;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	exprType = this._expr.getType$();
	if (exprType.equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(this._identifierToken, "cannot obtain a member of void"));
		return false;
	}
	if (exprType.equals$LType$(Type.nullType)) {
		context.errors.push(new CompileError(this._identifierToken, "cannot obtain a member of null"));
		return false;
	}
	if ((exprType instanceof NullableType ? exprType._baseType : exprType).equals$LType$(Type.variantType)) {
		context.errors.push(new CompileError(this._identifierToken, "property of a variant should be referred to by using the [] operator"));
		return false;
	}
	classDef = exprType.getClassDef$();
	if (classDef == null) {
		context.errors.push(new CompileError(this._identifierToken, "cannot determine type due to preceding errors"));
		return false;
	}
	if (this._expr.isClassSpecifier$()) {
		ClassDefinition$forEachInnerClass$LClassDefinition$F$LClassDefinition$B$(classDef, (function (classDef) {
			var objectType;
			if (classDef.className$() === $this._identifierToken._value) {
				objectType = new ParsedObjectType(new QualifiedName$1($this._identifierToken, exprType), $this._typeArgs);
				objectType.resolveType$LAnalysisContext$(context);
				$this._type = objectType;
				$this._isInner = true;
				return false;
			}
			return true;
		}));
		if (this._isInner) {
			return true;
		}
	}
	_type$0 = this._type = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(classDef, context.errors, _identifierToken$0 = this._identifierToken, _identifierToken$0._value, this._expr.isClassSpecifier$(), this._typeArgs, (this._expr.isClassSpecifier$() ? 1 : 0));
	if (_type$0 == null) {
		context.errors.push(new CompileError(this._identifierToken, "'" + exprType.toString() + "' does not have a property named '" + this._identifierToken._value + "'"));
		return false;
	}
	return true;
};


PropertyExpression.prototype.getType$ = function () {
	return this._type;
};


PropertyExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function PropertyExpression$setType$LPropertyExpression$LType$($this, type) {
	$this._type = type;
};

PropertyExpression.setType$LPropertyExpression$LType$ = PropertyExpression$setType$LPropertyExpression$LType$;

PropertyExpression.prototype.getHolderType$ = function () {
	var type;
	type = this._expr.getType$();
	if (type instanceof PrimitiveType) {
		type = new ObjectType(type.getClassDef$());
	}
	return type;
};


PropertyExpression.prototype.isClassSpecifier$ = function () {
	return this._isInner;
};


PropertyExpression.prototype.assertIsAssignable$LAnalysisContext$LToken$LType$ = function (context, token, type) {
	var $this = this;
	var holderType;
	var varFlags;
	if (! Expression$assertIsAssignable$LAnalysisContext$LToken$LType$LType$(context, token, this._type, type)) {
		return false;
	}
	holderType = this.getHolderType$();
	varFlags = 0;
	if (! holderType.equals$LType$(Type.variantType)) {
		if (ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(holderType.getClassDef$(), (function (classDef) {
			return ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
				if (MemberDefinition$name$LMemberDefinition$(varDef) === Token$getValue$LToken$($this._identifierToken)) {
					varFlags = MemberDefinition$flags$LMemberDefinition$(varDef);
					return false;
				}
				return true;
			}));
		}))) {
			throw new Error("logic flaw, could not find definition for " + holderType.getClassDef$().className$() + "#" + this._identifierToken._value);
		}
	}
	if ((varFlags & 1) !== 0) {
		context.errors.push(new CompileError(token, "cannot modify a constant"));
		return false;
	} else {
		if ((varFlags & 512) !== 0) {
			context.errors.push(new CompileError(token, "cannot modify a readonly variable"));
			return false;
		}
	}
	return true;
};


PropertyExpression.prototype.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B = function (context, operatorToken, argTypes, isStatic) {
	var i;
	var rhsType;
	for (i = 0; i < argTypes.length; ++ i) {
		if (argTypes[i] instanceof FunctionChoiceType) {
			context.errors.push(new CompileError(operatorToken, "type deduction of overloaded function passed in as an argument is not supported; use 'as' to specify the function"));
			return null;
		}
	}
	rhsType = this._type.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, operatorToken, argTypes, isStatic);
	if (rhsType == null) {
		return null;
	}
	this._type = rhsType;
	return rhsType;
};


function PropertyExpression$deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B($this, context, operatorToken, argTypes, isStatic) {
	var i;
	var rhsType;
	for (i = 0; i < argTypes.length; ++ i) {
		if (argTypes[i] instanceof FunctionChoiceType) {
			context.errors.push(new CompileError(operatorToken, "type deduction of overloaded function passed in as an argument is not supported; use 'as' to specify the function"));
			return null;
		}
	}
	rhsType = $this._type.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, operatorToken, argTypes, isStatic);
	if (rhsType == null) {
		return null;
	}
	$this._type = rhsType;
	return rhsType;
};

PropertyExpression.deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B = PropertyExpression$deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B;

function TypeofExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([TypeofExpression], UnaryExpression);
TypeofExpression.prototype.clone$ = function () {
	return new TypeofExpression(this._token, this._expr.clone$());
};


TypeofExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var exprType;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	exprType = this._expr.getType$();
	if (! exprType.equals$LType$(Type.variantType)) {
		context.errors.push(new CompileError(this._token, "cannot apply operator 'typeof' to '" + this._expr.getType$().toString() + "'"));
		return false;
	}
	return true;
};


TypeofExpression.prototype.getType$ = function () {
	return Type.stringType;
};


function SignExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([SignExpression], UnaryExpression);
SignExpression.prototype.clone$ = function () {
	return new SignExpression(this._token, this._expr.clone$());
};


SignExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context) ? false : ! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr, Type.numberType, true) ? false : true);
};


SignExpression.prototype.getType$ = function () {
	var type;
	type = this._expr.getType$();
	return ((type instanceof NullableType ? type._baseType : type).equals$LType$(Type.numberType) ? Type.numberType : Type.integerType);
};


function BinaryExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([BinaryExpression], OperatorExpression);
BinaryExpression.prototype.getFirstExpr$ = function () {
	return this._expr1;
};


function BinaryExpression$getFirstExpr$LBinaryExpression$($this) {
	return $this._expr1;
};

BinaryExpression.getFirstExpr$LBinaryExpression$ = BinaryExpression$getFirstExpr$LBinaryExpression$;

BinaryExpression.prototype.setFirstExpr$LExpression$ = function (expr) {
	this._expr1 = expr;
};


function BinaryExpression$setFirstExpr$LBinaryExpression$LExpression$($this, expr) {
	$this._expr1 = expr;
};

BinaryExpression.setFirstExpr$LBinaryExpression$LExpression$ = BinaryExpression$setFirstExpr$LBinaryExpression$LExpression$;

BinaryExpression.prototype.getSecondExpr$ = function () {
	return this._expr2;
};


function BinaryExpression$getSecondExpr$LBinaryExpression$($this) {
	return $this._expr2;
};

BinaryExpression.getSecondExpr$LBinaryExpression$ = BinaryExpression$getSecondExpr$LBinaryExpression$;

BinaryExpression.prototype.setSecondExpr$LExpression$ = function (expr) {
	this._expr2 = expr;
};


function BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$($this, expr) {
	$this._expr2 = expr;
};

BinaryExpression.setSecondExpr$LBinaryExpression$LExpression$ = BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$;

BinaryExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "BinaryExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), this._expr1.serialize$(), this._expr2.serialize$() ];
};


BinaryExpression.prototype._analyze$LAnalysisContext$ = function (context) {
	return (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true);
};


function BinaryExpression$_analyze$LBinaryExpression$LAnalysisContext$($this, context) {
	return (! $this._expr1.analyze$LAnalysisContext$LExpression$(context, $this) ? false : ! $this._expr2.analyze$LAnalysisContext$LExpression$(context, $this) ? false : true);
};

BinaryExpression._analyze$LBinaryExpression$LAnalysisContext$ = BinaryExpression$_analyze$LBinaryExpression$LAnalysisContext$;

BinaryExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr1, (function (expr) {
		$this._expr1 = expr;
	})) ? false : ! cb(this._expr2, (function (expr) {
		$this._expr2 = expr;
	})) ? false : true);
};


function AdditiveExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
	this._type = null;
};

$__jsx_extend([AdditiveExpression], BinaryExpression);
AdditiveExpression.prototype.clone$ = function () {
	var ret;
	ret = new AdditiveExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
	ret._type = this._type;
	return ret;
};


AdditiveExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var expr1Type;
	var expr2Type;
	var this$0;
	var this$1;
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	this$0 = this._expr1.getType$();
	expr1Type = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	this$1 = this._expr2.getType$();
	expr2Type = (this$1 instanceof NullableType ? this$1._baseType : this$1);
	if ((expr1Type.isConvertibleTo$LType$(Type.numberType) || expr1Type instanceof ObjectType && expr1Type.getClassDef$() == (Type.numberType, NumberType._classDef)) && (expr2Type.isConvertibleTo$LType$(Type.numberType) || expr2Type instanceof ObjectType && expr2Type.getClassDef$() == (Type.numberType, NumberType._classDef))) {
		this._type = (expr1Type instanceof NumberType || expr2Type instanceof NumberType ? Type.numberType : Type.integerType);
	} else {
		if ((expr1Type.equals$LType$(Type.stringType) || expr1Type instanceof ObjectType && expr1Type.getClassDef$() == (Type.stringType, StringType._classDef)) && (expr2Type.equals$LType$(Type.stringType) || expr2Type instanceof ObjectType && expr2Type.getClassDef$() == (Type.stringType, StringType._classDef))) {
			this._type = expr1Type;
		} else {
			context.errors.push(new CompileError(this._token, "cannot apply operator '+' to '" + expr1Type.toString() + "' and '" + expr2Type.toString() + "'"));
			return false;
		}
	}
	return true;
};


AdditiveExpression.prototype.getType$ = function () {
	return this._type;
};


function ArrayExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
	this._type = null;
};

$__jsx_extend([ArrayExpression], BinaryExpression);
ArrayExpression.prototype.clone$ = function () {
	var ret;
	ret = new ArrayExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
	ret._type = this._type;
	return ret;
};


ArrayExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var expr1Type;
	var this$0;
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	if (this._expr1.getType$() == null) {
		context.errors.push(new CompileError(this._token, "cannot determine type due to preceding errors"));
		return false;
	}
	this$0 = this._expr1.getType$();
	expr1Type = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	if (expr1Type instanceof ObjectType) {
		return ArrayExpression$_analyzeApplicationOnObject$LArrayExpression$LAnalysisContext$LType$(this, context, expr1Type);
	} else {
		if (expr1Type.equals$LType$(Type.variantType)) {
			return ArrayExpression$_analyzeApplicationOnVariant$LArrayExpression$LAnalysisContext$(this, context);
		}
	}
	context.errors.push(new CompileError(this._token, "cannot apply []; the operator is only applicable against an array or an variant"));
	return false;
};


ArrayExpression.prototype._analyzeApplicationOnObject$LAnalysisContext$LType$ = function (context, expr1Type) {
	var expr1ClassDef;
	var funcType;
	var deducedFuncType;
	expr1ClassDef = expr1Type.getClassDef$();
	funcType = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(expr1ClassDef, context.errors, this._token, "__native_index_operator__", false, [], 0);
	if (funcType == null) {
		context.errors.push(new CompileError(this._token, "cannot apply operator[] on an instance of class '" + expr1ClassDef.className$() + "'"));
		return false;
	}
	deducedFuncType = funcType.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, this._token, [ this._expr2.getType$() ], false);
	if (deducedFuncType == null) {
		return false;
	}
	this._type = deducedFuncType._returnType;
	return true;
};


function ArrayExpression$_analyzeApplicationOnObject$LArrayExpression$LAnalysisContext$LType$($this, context, expr1Type) {
	var expr1ClassDef;
	var funcType;
	var deducedFuncType;
	expr1ClassDef = expr1Type.getClassDef$();
	funcType = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(expr1ClassDef, context.errors, $this._token, "__native_index_operator__", false, [], 0);
	if (funcType == null) {
		context.errors.push(new CompileError($this._token, "cannot apply operator[] on an instance of class '" + expr1ClassDef.className$() + "'"));
		return false;
	}
	deducedFuncType = funcType.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, $this._token, [ $this._expr2.getType$() ], false);
	if (deducedFuncType == null) {
		return false;
	}
	$this._type = deducedFuncType._returnType;
	return true;
};

ArrayExpression._analyzeApplicationOnObject$LArrayExpression$LAnalysisContext$LType$ = ArrayExpression$_analyzeApplicationOnObject$LArrayExpression$LAnalysisContext$LType$;

ArrayExpression.prototype._analyzeApplicationOnVariant$LAnalysisContext$ = function (context) {
	var expr2Type;
	var this$0;
	this$0 = this._expr2.getType$();
	expr2Type = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	if (! (expr2Type.equals$LType$(Type.stringType) || expr2Type.isConvertibleTo$LType$(Type.numberType))) {
		context.errors.push(new CompileError(this._token, "the argument of variant[] should be a string or a number"));
		return false;
	}
	this._type = Type.variantType;
	return true;
};


function ArrayExpression$_analyzeApplicationOnVariant$LArrayExpression$LAnalysisContext$($this, context) {
	var expr2Type;
	var this$0;
	this$0 = $this._expr2.getType$();
	expr2Type = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	if (! (expr2Type.equals$LType$(Type.stringType) || expr2Type.isConvertibleTo$LType$(Type.numberType))) {
		context.errors.push(new CompileError($this._token, "the argument of variant[] should be a string or a number"));
		return false;
	}
	$this._type = Type.variantType;
	return true;
};

ArrayExpression._analyzeApplicationOnVariant$LArrayExpression$LAnalysisContext$ = ArrayExpression$_analyzeApplicationOnVariant$LArrayExpression$LAnalysisContext$;

ArrayExpression.prototype.getType$ = function () {
	return this._type;
};


ArrayExpression.prototype.assertIsAssignable$LAnalysisContext$LToken$LType$ = function (context, token, type) {
	return Expression$assertIsAssignable$LAnalysisContext$LToken$LType$LType$(context, token, this._type, type);
};


function AssignmentExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([AssignmentExpression], BinaryExpression);
AssignmentExpression.prototype.clone$ = function () {
	return new AssignmentExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


AssignmentExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var rhsType;
	var lhsType;
	var _expr2$0;
	var _expr2$1;
	if (this._expr2 instanceof FunctionExpression) {
		return AssignmentExpression$_analyzeFunctionExpressionAssignment$LAssignmentExpression$LAnalysisContext$LExpression$(this, context, parentExpr);
	}
	if ((_expr2$0 = this._expr2) instanceof ArrayLiteralExpression && _expr2$0._exprs.length === 0 && _expr2$0.getType$() == null || (_expr2$1 = this._expr2) instanceof MapLiteralExpression && _expr2$1._elements.length === 0 && _expr2$1.getType$() == null) {
		return AssignmentExpression$_analyzeEmptyLiteralAssignment$LAssignmentExpression$LAnalysisContext$LExpression$(this, context, parentExpr);
	}
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	if (this._token._value !== "=") {
		return AssignmentExpression$_analyzeFusedAssignment$LAssignmentExpression$LAnalysisContext$(this, context);
	}
	rhsType = this._expr2.getType$();
	if (rhsType == null) {
		return false;
	}
	if (rhsType.equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(this._token, "cannot assign void"));
		return false;
	}
	if (this._expr2.isClassSpecifier$()) {
		context.errors.push(new CompileError(this._token, "cannot assign a class"));
		return false;
	}
	if ((rhsType instanceof NullableType ? rhsType._baseType : rhsType).equals$LType$(Type.nullType) && this._expr1.getType$() == null) {
		context.errors.push(new CompileError(this._token, "cannot assign null to an unknown type"));
		return false;
	}
	if (rhsType instanceof FunctionChoiceType) {
		lhsType = this._expr1.getType$();
		if (lhsType != null) {
			if (! (lhsType instanceof ResolvedFunctionType)) {
				context.errors.push(new CompileError(this._token, "cannot assign a function reference to '" + this._expr1.getType$().toString() + "'"));
				return false;
			}
			if ((rhsType = PropertyExpression$deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B(this._expr2, context, this._token, lhsType._argTypes, lhsType instanceof StaticFunctionType)) == null) {
				return false;
			}
		} else {
			context.errors.push(new CompileError(this._token, "function reference is ambiguous"));
			return false;
		}
	}
	if (rhsType instanceof MemberFunctionType) {
		context.errors.push(new CompileError(this._token, "cannot assign a member function"));
		return false;
	}
	return (! this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, rhsType) ? false : true);
};


AssignmentExpression.prototype._analyzeFusedAssignment$LAnalysisContext$ = function (context) {
	var lhsType;
	var rhsType;
	var this$0;
	var this$1;
	var _token$0;
	this$0 = this._expr1.getType$();
	lhsType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	this$1 = this._expr2.getType$();
	rhsType = (this$1 instanceof NullableType ? this$1._baseType : this$1);
	if (! this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, lhsType)) {
		return false;
	}
	if (this._token._value === "+=" && lhsType.equals$LType$(Type.stringType) && rhsType.equals$LType$(Type.stringType)) {
		return true;
	}
	if ((lhsType instanceof IntegerType || lhsType instanceof NumberType) && (rhsType instanceof IntegerType || rhsType instanceof NumberType)) {
		return true;
	}
	context.errors.push(new CompileError(_token$0 = this._token, "cannot apply operator '" + _token$0._value + "' against '" + this._expr1.getType$().toString() + "' and '" + this._expr2.getType$().toString() + "'"));
	return false;
};


function AssignmentExpression$_analyzeFusedAssignment$LAssignmentExpression$LAnalysisContext$($this, context) {
	var lhsType;
	var rhsType;
	var this$0;
	var this$1;
	var _token$0;
	this$0 = $this._expr1.getType$();
	lhsType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	this$1 = $this._expr2.getType$();
	rhsType = (this$1 instanceof NullableType ? this$1._baseType : this$1);
	if (! $this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, $this._token, lhsType)) {
		return false;
	}
	if ($this._token._value === "+=" && lhsType.equals$LType$(Type.stringType) && rhsType.equals$LType$(Type.stringType)) {
		return true;
	}
	if ((lhsType instanceof IntegerType || lhsType instanceof NumberType) && (rhsType instanceof IntegerType || rhsType instanceof NumberType)) {
		return true;
	}
	context.errors.push(new CompileError(_token$0 = $this._token, "cannot apply operator '" + _token$0._value + "' against '" + $this._expr1.getType$().toString() + "' and '" + $this._expr2.getType$().toString() + "'"));
	return false;
};

AssignmentExpression._analyzeFusedAssignment$LAssignmentExpression$LAnalysisContext$ = AssignmentExpression$_analyzeFusedAssignment$LAssignmentExpression$LAnalysisContext$;

AssignmentExpression.prototype._analyzeEmptyLiteralAssignment$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var classDef;
	var type$0;
	var type$1;
	if (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	if (this._expr1.getType$() == null) {
		context.errors.push(new CompileError(this._token, "either side of the operator should be fully type-qualified"));
	}
	if (this._expr2 instanceof ArrayLiteralExpression) {
		if (! (this._expr1.getType$() instanceof ObjectType && (classDef = this._expr1.getType$().getClassDef$()) instanceof InstantiatedClassDefinition && classDef._templateClassDef._className === "Array")) {
			context.errors.push(new CompileError(this._token, "cannot deduce the type of [] because left-hand-side expression is not of Array type"));
			return false;
		}
		type$0 = this._expr1.getType$();
		this._expr2._type = type$0;
	} else {
		if (! (this._expr1.getType$() instanceof ObjectType && (classDef = this._expr1.getType$().getClassDef$()) instanceof InstantiatedClassDefinition && classDef._templateClassDef._className === "Map")) {
			context.errors.push(new CompileError(this._token, "cannot deduce the type of {} because left-hand-side expression is not of Map type"));
			return false;
		}
		type$1 = this._expr1.getType$();
		this._expr2._type = type$1;
	}
	return (! this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, this._expr2.getType$()) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true);
};


function AssignmentExpression$_analyzeEmptyLiteralAssignment$LAssignmentExpression$LAnalysisContext$LExpression$($this, context, parentExpr) {
	var classDef;
	var type$0;
	var type$1;
	if (! $this._expr1.analyze$LAnalysisContext$LExpression$(context, $this)) {
		return false;
	}
	if ($this._expr1.getType$() == null) {
		context.errors.push(new CompileError($this._token, "either side of the operator should be fully type-qualified"));
	}
	if ($this._expr2 instanceof ArrayLiteralExpression) {
		if (! ($this._expr1.getType$() instanceof ObjectType && (classDef = $this._expr1.getType$().getClassDef$()) instanceof InstantiatedClassDefinition && classDef._templateClassDef._className === "Array")) {
			context.errors.push(new CompileError($this._token, "cannot deduce the type of [] because left-hand-side expression is not of Array type"));
			return false;
		}
		type$0 = $this._expr1.getType$();
		$this._expr2._type = type$0;
	} else {
		if (! ($this._expr1.getType$() instanceof ObjectType && (classDef = $this._expr1.getType$().getClassDef$()) instanceof InstantiatedClassDefinition && classDef._templateClassDef._className === "Map")) {
			context.errors.push(new CompileError($this._token, "cannot deduce the type of {} because left-hand-side expression is not of Map type"));
			return false;
		}
		type$1 = $this._expr1.getType$();
		$this._expr2._type = type$1;
	}
	return (! $this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, $this._token, $this._expr2.getType$()) ? false : ! $this._expr2.analyze$LAnalysisContext$LExpression$(context, $this) ? false : true);
};

AssignmentExpression._analyzeEmptyLiteralAssignment$LAssignmentExpression$LAnalysisContext$LExpression$ = AssignmentExpression$_analyzeEmptyLiteralAssignment$LAssignmentExpression$LAnalysisContext$LExpression$;

AssignmentExpression.prototype._analyzeFunctionExpressionAssignment$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var typesAreIdentified$this$0;
	var deductTypeIfUnknown$type$0;
	if (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	if (this._expr1.getType$() == null) {
		if (! (typesAreIdentified$this$0 = this._expr2, ! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(typesAreIdentified$this$0) ? false : typesAreIdentified$this$0._funcDef._returnType == null ? false : true)) {
			context.errors.push(new CompileError(this._token, "either side of the operator should be fully type-qualified : " + (FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(this._expr2) ? "return type not declared" : "argument / return types not declared")));
			return false;
		}
	} else {
		if (! this._expr1.getType$().equals$LType$(Type.variantType)) {
			if (this._expr1.getType$() instanceof ResolvedFunctionType) {
				if (! (deductTypeIfUnknown$type$0 = this._expr1.getType$(), ! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$(this._expr2._funcDef, context, deductTypeIfUnknown$type$0) ? false : true)) {
					return false;
				}
			} else {
				context.errors.push(new CompileError(this._token, Util$format$SAS("%1 is not convertible to %2", [ this._expr2.getType$().toString(), this._expr1.getType$().toString() ])));
				return false;
			}
		}
	}
	return (! this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, this._expr2.getType$()) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true);
};


function AssignmentExpression$_analyzeFunctionExpressionAssignment$LAssignmentExpression$LAnalysisContext$LExpression$($this, context, parentExpr) {
	var typesAreIdentified$this$0;
	var deductTypeIfUnknown$type$0;
	if (! $this._expr1.analyze$LAnalysisContext$LExpression$(context, $this)) {
		return false;
	}
	if ($this._expr1.getType$() == null) {
		if (! (typesAreIdentified$this$0 = $this._expr2, ! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(typesAreIdentified$this$0) ? false : typesAreIdentified$this$0._funcDef._returnType == null ? false : true)) {
			context.errors.push(new CompileError($this._token, "either side of the operator should be fully type-qualified : " + (FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$($this._expr2) ? "return type not declared" : "argument / return types not declared")));
			return false;
		}
	} else {
		if (! $this._expr1.getType$().equals$LType$(Type.variantType)) {
			if ($this._expr1.getType$() instanceof ResolvedFunctionType) {
				if (! (deductTypeIfUnknown$type$0 = $this._expr1.getType$(), ! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$($this._expr2._funcDef, context, deductTypeIfUnknown$type$0) ? false : true)) {
					return false;
				}
			} else {
				context.errors.push(new CompileError($this._token, Util$format$SAS("%1 is not convertible to %2", [ $this._expr2.getType$().toString(), $this._expr1.getType$().toString() ])));
				return false;
			}
		}
	}
	return (! $this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, $this._token, $this._expr2.getType$()) ? false : ! $this._expr2.analyze$LAnalysisContext$LExpression$(context, $this) ? false : true);
};

AssignmentExpression._analyzeFunctionExpressionAssignment$LAssignmentExpression$LAnalysisContext$LExpression$ = AssignmentExpression$_analyzeFunctionExpressionAssignment$LAssignmentExpression$LAnalysisContext$LExpression$;

AssignmentExpression.prototype.getType$ = function () {
	return this._expr1.getType$();
};


function BinaryNumberExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([BinaryNumberExpression], BinaryExpression);
BinaryNumberExpression.prototype.clone$ = function () {
	return new BinaryNumberExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


BinaryNumberExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var _token$0;
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	switch (this._token._value) {
	case "<":
	case "<=":
	case ">":
	case ">=":
		if (OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr1, Type.numberType, true)) {
			return OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr2, Type.numberType, true);
		}
		if (OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr1, Type.stringType, true)) {
			return OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr2, Type.stringType, true);
		}
		context.errors.push(new CompileError(_token$0 = this._token, "cannot apply operator '" + _token$0._value + "' to type '" + this._expr1.getType$().toString() + "'"));
		return false;
	default:
		this._expr1.getType$();
		if (! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr1, Type.numberType, true)) {
			return false;
		}
		this._expr2.getType$();
		if (! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr2, Type.numberType, true)) {
			return false;
		}
		return true;
	}
};


BinaryNumberExpression.prototype.getType$ = function () {
	var resolveIfNullable$this$0;
	var resolveIfNullable$this$1;
	switch (this._token._value) {
	case "+":
	case "-":
	case "*":
		if ((resolveIfNullable$this$0 = this._expr1.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0).equals$LType$(Type.numberType) || (resolveIfNullable$this$1 = this._expr2.getType$(), resolveIfNullable$this$1 instanceof NullableType ? resolveIfNullable$this$1._baseType : resolveIfNullable$this$1).equals$LType$(Type.numberType)) {
			return Type.numberType;
		} else {
			return Type.integerType;
		}
	case "/":
	case "%":
		return Type.numberType;
	case "<":
	case "<=":
	case ">":
	case ">=":
		return Type.booleanType;
	case "&":
	case "|":
	case "^":
		return Type.integerType;
	default:
		throw new Error("unexpected operator:" + this._token._value);
	}
};


function EqualityExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([EqualityExpression], BinaryExpression);
EqualityExpression.prototype.clone$ = function () {
	return new EqualityExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


EqualityExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var $this = this;
	var bool;
	var expr1Type;
	var expr2Type;
	function bool(x) {
		return (x ? 1 : 0);
	}
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	expr1Type = this._expr1.getType$();
	expr2Type = this._expr2.getType$();
	if ((expr1Type instanceof NullableType ? expr1Type._baseType : expr1Type).equals$LType$(expr2Type instanceof NullableType ? expr2Type._baseType : expr2Type)) {
	} else {
		if (expr1Type.isConvertibleTo$LType$(expr2Type) || expr2Type.isConvertibleTo$LType$(expr1Type)) {
		} else {
			if (bool(expr1Type instanceof ObjectType) + bool(expr2Type instanceof ObjectType) === 1 && expr1Type.getClassDef$() == expr2Type.getClassDef$()) {
			} else {
				context.errors.push(new CompileError(this._token, "either side of operator == should be convertible from the other"));
				return false;
			}
		}
	}
	return true;
};


EqualityExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


function InExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([InExpression], BinaryExpression);
InExpression.prototype.clone$ = function () {
	return new InExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


InExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var expr2Type;
	var expr2ClassDef;
	var resolveIfNullable$this$0;
	var resolveIfNullable$this$1;
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	if (! (resolveIfNullable$this$0 = this._expr1.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0).equals$LType$(Type.stringType)) {
		context.errors.push(new CompileError(this._token, "left operand of 'in' expression should be a string"));
		return false;
	}
	if ((expr2Type = (resolveIfNullable$this$1 = this._expr2.getType$(), resolveIfNullable$this$1 instanceof NullableType ? resolveIfNullable$this$1._baseType : resolveIfNullable$this$1)) instanceof ObjectType && (expr2ClassDef = expr2Type.getClassDef$()) instanceof InstantiatedClassDefinition && expr2ClassDef._templateClassDef._className === "Map") {
	} else {
		context.errors.push(new CompileError(this._token, "right operand of 'in' expression should be a map"));
		return false;
	}
	return true;
};


InExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


function LogicalExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([LogicalExpression], BinaryExpression);
LogicalExpression.prototype.clone$ = function () {
	return new LogicalExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


LogicalExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var resolveIfNullable$this$0;
	var resolveIfNullable$this$1;
	var _token$0;
	var _token$1;
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	if ((resolveIfNullable$this$0 = this._expr1.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0).equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(_token$0 = this._token, "left argument of operator '" + _token$0._value + "' cannot be void"));
		return false;
	}
	if ((resolveIfNullable$this$1 = this._expr2.getType$(), resolveIfNullable$this$1 instanceof NullableType ? resolveIfNullable$this$1._baseType : resolveIfNullable$this$1).equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(_token$1 = this._token, "right argument of operator '" + _token$1._value + "' cannot be void"));
		return false;
	}
	return true;
};


LogicalExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


function ShiftExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([ShiftExpression], BinaryExpression);
ShiftExpression.prototype.clone$ = function () {
	return new ShiftExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


ShiftExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true) ? false : ! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr1, Type.integerType, true) ? false : ! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr2, Type.integerType, true) ? false : true);
};


ShiftExpression.prototype.getType$ = function () {
	return Type.integerType;
};


function ConditionalExpression(operatorToken, condExpr, ifTrueExpr, ifFalseExpr) {
	ConditionalExpression$0.call(this, operatorToken, condExpr, ifTrueExpr, ifFalseExpr, null);
};

function ConditionalExpression$0(operatorToken, condExpr, ifTrueExpr, ifFalseExpr, type) {
	this._stash = {};
	this._token = operatorToken;
	this._condExpr = condExpr;
	this._ifTrueExpr = ifTrueExpr;
	this._ifFalseExpr = ifFalseExpr;
	this._type = (type != null ? type : null);
};

$__jsx_extend([ConditionalExpression, ConditionalExpression$0], OperatorExpression);
ConditionalExpression.prototype.clone$ = function () {
	return new ConditionalExpression$0(this._token, this._condExpr.clone$(), this._ifTrueExpr != null ? this._ifTrueExpr.clone$() : null, this._ifFalseExpr.clone$(), this._type);
};


ConditionalExpression.prototype.getCondExpr$ = function () {
	return this._condExpr;
};


function ConditionalExpression$getCondExpr$LConditionalExpression$($this) {
	return $this._condExpr;
};

ConditionalExpression.getCondExpr$LConditionalExpression$ = ConditionalExpression$getCondExpr$LConditionalExpression$;

ConditionalExpression.prototype.setCondExpr$LExpression$ = function (expr) {
	this._condExpr = expr;
};


function ConditionalExpression$setCondExpr$LConditionalExpression$LExpression$($this, expr) {
	$this._condExpr = expr;
};

ConditionalExpression.setCondExpr$LConditionalExpression$LExpression$ = ConditionalExpression$setCondExpr$LConditionalExpression$LExpression$;

ConditionalExpression.prototype.getIfTrueExpr$ = function () {
	return this._ifTrueExpr;
};


function ConditionalExpression$getIfTrueExpr$LConditionalExpression$($this) {
	return $this._ifTrueExpr;
};

ConditionalExpression.getIfTrueExpr$LConditionalExpression$ = ConditionalExpression$getIfTrueExpr$LConditionalExpression$;

ConditionalExpression.prototype.getIfFalseExpr$ = function () {
	return this._ifFalseExpr;
};


function ConditionalExpression$getIfFalseExpr$LConditionalExpression$($this) {
	return $this._ifFalseExpr;
};

ConditionalExpression.getIfFalseExpr$LConditionalExpression$ = ConditionalExpression$getIfFalseExpr$LConditionalExpression$;

ConditionalExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	var serializeNullable$v$0;
	return [ "ConditionalExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), this._condExpr.serialize$(), (serializeNullable$v$0 = this._ifTrueExpr, serializeNullable$v$0 == null ? null : serializeNullable$v$0.serialize$()), this._ifFalseExpr.serialize$() ];
};


ConditionalExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var typeIfTrue;
	var typeIfFalse;
	var _ifTrueExpr$0;
	var _type$0;
	if (! this._condExpr.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	if ((_ifTrueExpr$0 = this._ifTrueExpr) != null && ! _ifTrueExpr$0.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	if (! this._ifFalseExpr.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	if (this._condExpr.getType$().equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(this._token, "condition cannot be void"));
		return false;
	}
	if (this._ifTrueExpr != null) {
		typeIfTrue = this._ifTrueExpr.getType$();
	} else {
		typeIfTrue = this._condExpr.getType$();
	}
	typeIfFalse = this._ifFalseExpr.getType$();
	_type$0 = this._type = Type$calcLeastCommonAncestor$LType$LType$B(typeIfTrue, typeIfFalse, false);
	if (_type$0 == null) {
		context.errors.push(new CompileError(this._token, "could not get the join type of '" + typeIfTrue.toString() + "' and '" + typeIfFalse.toString() + "'"));
		return false;
	}
	return true;
};


ConditionalExpression.prototype.getType$ = function () {
	return this._type;
};


ConditionalExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._condExpr, (function (expr) {
		$this._condExpr = expr;
	})) ? false : this._ifTrueExpr != null && ! cb(this._ifTrueExpr, (function (expr) {
		$this._ifTrueExpr = expr;
	})) ? false : ! cb(this._ifFalseExpr, (function (expr) {
		$this._ifFalseExpr = expr;
	})) ? false : true);
};


function CallExpression(token, expr, args) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
	this._args = args;
};

function CallExpression$0(that) {
	OperatorExpression$0.call(this, that);
	this._expr = that._expr.clone$();
	this._args = Cloner$x2E$x3CExpression$x3E$cloneArray$ALExpression$(that._args);
};

$__jsx_extend([CallExpression, CallExpression$0], OperatorExpression);
CallExpression.prototype.clone$ = function () {
	return new CallExpression$0(this);
};


CallExpression.prototype.getExpr$ = function () {
	return this._expr;
};


function CallExpression$getExpr$LCallExpression$($this) {
	return $this._expr;
};

CallExpression.getExpr$LCallExpression$ = CallExpression$getExpr$LCallExpression$;

CallExpression.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function CallExpression$setExpr$LCallExpression$LExpression$($this, expr) {
	$this._expr = expr;
};

CallExpression.setExpr$LCallExpression$LExpression$ = CallExpression$setExpr$LCallExpression$LExpression$;

CallExpression.prototype.getArguments$ = function () {
	return this._args;
};


function CallExpression$getArguments$LCallExpression$($this) {
	return $this._args;
};

CallExpression.getArguments$LCallExpression$ = CallExpression$getArguments$LCallExpression$;

CallExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "CallExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), this._expr.serialize$(), Serializer$x2E$x3CExpression$x3E$serializeArray$ALExpression$(this._args) ];
};


CallExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var exprType;
	var argTypes;
	var isCallingStatic;
	var this$0;
	var _args$0;
	if (! this._expr.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	this$0 = this._expr.getType$();
	exprType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	if (! (exprType instanceof FunctionType)) {
		context.errors.push(new CompileError(this._token, "cannot call a non-function"));
		return false;
	}
	argTypes = Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$AALType$(context, _args$0 = this._args, this, exprType.getExpectedTypes$NB(_args$0.length, ! (this._expr instanceof PropertyExpression && ! exprType.isAssignable$() && ! this._expr._expr.isClassSpecifier$())));
	if (argTypes == null) {
		return false;
	}
	if (this._expr instanceof PropertyExpression && ! exprType.isAssignable$()) {
		isCallingStatic = this._expr._expr.isClassSpecifier$();
		if (! isCallingStatic && this._expr._identifierToken._value === "constructor") {
			context.errors.push(new CompileError(this._token, "cannot call a constructor other than by using 'new'"));
			return false;
		}
		if (PropertyExpression$deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B(this._expr, context, this._token, argTypes, isCallingStatic) == null) {
			return false;
		}
	} else {
		if (exprType.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, this._token, argTypes, true) == null) {
			return false;
		}
	}
	return true;
};


CallExpression.prototype.getType$ = function () {
	var type;
	type = this._expr.getType$();
	return (type == null ? null : (type instanceof NullableType ? type._baseType : type)._returnType);
};


CallExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : ! Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._args) ? false : true);
};


function SuperExpression(token, name, args) {
	this._stash = {};
	this._token = token;
	this._name = name;
	this._args = args;
	this._funcType = null;
};

function SuperExpression$0(that) {
	OperatorExpression$0.call(this, that);
	this._name = that._name;
	this._args = Cloner$x2E$x3CExpression$x3E$cloneArray$ALExpression$(that._args);
	this._funcType = that._funcType;
};

$__jsx_extend([SuperExpression, SuperExpression$0], OperatorExpression);
SuperExpression.prototype.clone$ = function () {
	return new SuperExpression$0(this);
};


SuperExpression.prototype.getName$ = function () {
	return this._name;
};


function SuperExpression$getName$LSuperExpression$($this) {
	return $this._name;
};

SuperExpression.getName$LSuperExpression$ = SuperExpression$getName$LSuperExpression$;

SuperExpression.prototype.getArguments$ = function () {
	return this._args;
};


function SuperExpression$getArguments$LSuperExpression$($this) {
	return $this._args;
};

SuperExpression.getArguments$LSuperExpression$ = SuperExpression$getArguments$LSuperExpression$;

SuperExpression.prototype.getFunctionType$ = function () {
	return this._funcType;
};


function SuperExpression$getFunctionType$LSuperExpression$($this) {
	return $this._funcType;
};

SuperExpression.getFunctionType$LSuperExpression$ = SuperExpression$getFunctionType$LSuperExpression$;

SuperExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	var serialize$this$1;
	return [ "SuperExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), (serialize$this$1 = this._name, [ serialize$this$1._value, serialize$this$1._isIdentifier, serialize$this$1._filename, serialize$this$1._lineNumber, serialize$this$1._columnNumber ]), Serializer$x2E$x3CExpression$x3E$serializeArray$ALExpression$(this._args) ];
};


SuperExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var classDef;
	var funcType;
	var argTypes;
	var _args$0;
	if ((context.funcDef._flags & 8) !== 0) {
		context.errors.push(new CompileError(this._token, "cannot use 'super' keyword in a static function"));
		return false;
	}
	classDef = context.funcDef._classDef;
	funcType = null;
	if ((funcType = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(classDef, context.errors, this._token, this._name._value, false, [], 2)) == null) {
		context.errors.push(new CompileError(this._token, "could not find a member function with given name in super classes of class '" + classDef.className$() + "'"));
		return false;
	}
	argTypes = Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$AALType$(context, _args$0 = this._args, this, funcType.getExpectedTypes$NB(_args$0.length, false));
	if (argTypes == null) {
		return false;
	}
	if ((funcType = funcType.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, this._token, argTypes, false)) == null) {
		return false;
	}
	this._funcType = funcType;
	return true;
};


SuperExpression.prototype.getType$ = function () {
	return this._funcType._returnType;
};


SuperExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return (! Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._args) ? false : true);
};


function NewExpression(token, type, args) {
	this._stash = {};
	this._token = token;
	this._type = type;
	this._args = args;
	this._constructor = null;
};

function NewExpression$0(that) {
	OperatorExpression$0.call(this, that);
	this._type = that._type;
	this._args = Cloner$x2E$x3CExpression$x3E$cloneArray$ALExpression$(that._args);
	this._constructor = that._constructor;
};

$__jsx_extend([NewExpression, NewExpression$0], OperatorExpression);
NewExpression.prototype.clone$ = function () {
	return new NewExpression$0(this);
};


NewExpression.prototype.getArguments$ = function () {
	return this._args;
};


function NewExpression$getArguments$LNewExpression$($this) {
	return $this._args;
};

NewExpression.getArguments$LNewExpression$ = NewExpression$getArguments$LNewExpression$;

NewExpression.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "NewExpression", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), this._type.toString(), Serializer$x2E$x3CExpression$x3E$serializeArray$ALExpression$(this._args) ];
};


NewExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var classDef;
	var ctors;
	var argTypes;
	var _args$0;
	if (! (this._type instanceof ObjectType)) {
		context.errors.push(new CompileError(this._token, "cannot instantiate a non-object type: " + this._type.toString()));
		return false;
	}
	classDef = this._type.getClassDef$();
	if (classDef == null) {
		return false;
	}
	if ((classDef.flags$() & 192) !== 0) {
		context.errors.push(new CompileError(this._token, "cannot instantiate an interface or a mixin"));
		return false;
	}
	if ((classDef.flags$() & 2) !== 0) {
		context.errors.push(new CompileError(this._token, "cannot instantiate an abstract class"));
		return false;
	}
	ctors = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(classDef, context.errors, this._token, "constructor", false, [], 1);
	if (ctors == null) {
		context.errors.push(new CompileError(this._token, "the class cannot be instantiated"));
		return false;
	}
	argTypes = Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$AALType$(context, _args$0 = this._args, this, ctors.getExpectedTypes$NB(_args$0.length, false));
	if (argTypes == null) {
		return false;
	}
	if ((this._constructor = ctors.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, this._token, argTypes, false)) == null) {
		context.errors.push(new CompileError(this._token, "cannot create an object of type '" + this._type.toString() + "', arguments mismatch"));
		return false;
	}
	return true;
};


NewExpression.prototype.getType$ = function () {
	return this._type;
};


NewExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function NewExpression$setType$LNewExpression$LType$($this, type) {
	$this._type = type;
};

NewExpression.setType$LNewExpression$LType$ = NewExpression$setType$LNewExpression$LType$;

NewExpression.prototype.getConstructor$ = function () {
	return this._constructor;
};


function NewExpression$getConstructor$LNewExpression$($this) {
	return $this._constructor;
};

NewExpression.getConstructor$LNewExpression$ = NewExpression$getConstructor$LNewExpression$;

NewExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return (! Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._args) ? false : true);
};


function CommaExpression(token, expr1, expr2) {
	this._stash = {};
	this._token = token;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([CommaExpression], Expression);
CommaExpression.prototype.clone$ = function () {
	return new CommaExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


CommaExpression.prototype.getFirstExpr$ = function () {
	return this._expr1;
};


function CommaExpression$getFirstExpr$LCommaExpression$($this) {
	return $this._expr1;
};

CommaExpression.getFirstExpr$LCommaExpression$ = CommaExpression$getFirstExpr$LCommaExpression$;

CommaExpression.prototype.getSecondExpr$ = function () {
	return this._expr2;
};


function CommaExpression$getSecondExpr$LCommaExpression$($this) {
	return $this._expr2;
};

CommaExpression.getSecondExpr$LCommaExpression$ = CommaExpression$getSecondExpr$LCommaExpression$;

CommaExpression.prototype.serialize$ = function () {
	return [ "CommaExpression", this._expr1.serialize$(), this._expr2.serialize$() ];
};


CommaExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return this._expr1.analyze$LAnalysisContext$LExpression$(context, this) && this._expr2.analyze$LAnalysisContext$LExpression$(context, this);
};


CommaExpression.prototype.getType$ = function () {
	return this._expr2.getType$();
};


CommaExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr1, (function (expr) {
		$this._expr1 = expr;
	})) ? false : ! cb(this._expr2, (function (expr) {
		$this._expr2 = expr;
	})) ? false : true);
};


function Statement() {
	this._stash = {};
};

$__jsx_extend([Statement], Object);
$__jsx_merge_interface(Statement, Stashable);

Statement.prototype.analyze$LAnalysisContext$ = function (context) {
	var token;
	var srcPos;
	if (! (this instanceof CaseStatement || this instanceof DefaultStatement)) {
		if (! Statement$assertIsReachable$LAnalysisContext$LToken$(context, this.getToken$())) {
			return false;
		}
	}
	try {
		return this.doAnalyze$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			token = this.getToken$();
			srcPos = (token != null ? Util$format$SAS(" at file %1, line %2", [ token._filename, token._lineNumber + "" ]) : "");
			$__jsx_catch_0.message = Util$format$SAS("fatal error while compiling statement%1\n%2", [ srcPos, $__jsx_catch_0.message ]);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
};


function Statement$analyze$LStatement$LAnalysisContext$($this, context) {
	var token;
	var srcPos;
	if (! ($this instanceof CaseStatement || $this instanceof DefaultStatement)) {
		if (! Statement$assertIsReachable$LAnalysisContext$LToken$(context, $this.getToken$())) {
			return false;
		}
	}
	try {
		return $this.doAnalyze$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			token = $this.getToken$();
			srcPos = (token != null ? Util$format$SAS(" at file %1, line %2", [ token._filename, token._lineNumber + "" ]) : "");
			$__jsx_catch_0.message = Util$format$SAS("fatal error while compiling statement%1\n%2", [ srcPos, $__jsx_catch_0.message ]);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
};

Statement.analyze$LStatement$LAnalysisContext$ = Statement$analyze$LStatement$LAnalysisContext$;

Statement.prototype.forEachStatement$F$LStatement$B$ = function (cb) {
	return true;
};


Statement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	return true;
};


Statement.prototype.forEachExpression$F$LExpression$B$ = function (cb) {
	var $this = this;
	return this.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, _) {
		return cb(expr);
	}));
};


function Statement$forEachExpression$LStatement$F$LExpression$B$($this, cb) {
	return $this.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, _) {
		return cb(expr);
	}));
};

Statement.forEachExpression$LStatement$F$LExpression$B$ = Statement$forEachExpression$LStatement$F$LExpression$B$;

Statement.prototype._analyzeExpr$LAnalysisContext$LExpression$ = function (context, expr) {
	var result;
	if (context.statement != null) {
		throw new Error("logic flaw");
	}
	context.statement = this;
	result = false;
	try {
		result = expr.analyze$LAnalysisContext$LExpression$(context, null);
	} finally {
		context.statement = null;
	}
	return result;
};


function Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$($this, context, expr) {
	var result;
	if (context.statement != null) {
		throw new Error("logic flaw");
	}
	context.statement = $this;
	result = false;
	try {
		result = expr.analyze$LAnalysisContext$LExpression$(context, null);
	} finally {
		context.statement = null;
	}
	return result;
};

Statement._analyzeExpr$LStatement$LAnalysisContext$LExpression$ = Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$;

function Statement$assertIsReachable$LAnalysisContext$LToken$(context, token) {
	var blockStack$0;
	if (! (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses._isReachable) {
		context.errors.push(new CompileWarning(token, "the code is unreachable"));
	}
	return true;
};

Statement.assertIsReachable$LAnalysisContext$LToken$ = Statement$assertIsReachable$LAnalysisContext$LToken$;

function ConstructorInvocationStatement(token, ctorClassType, args) {
	ConstructorInvocationStatement$0.call(this, token, ctorClassType, args, null);
};

function ConstructorInvocationStatement$0(token, ctorClassType, args, ctorFunctionType) {
	this._stash = {};
	this._token = token;
	this._ctorClassType = ctorClassType;
	this._args = args;
	this._ctorFunctionType = (ctorFunctionType != null ? ctorFunctionType : null);
};

$__jsx_extend([ConstructorInvocationStatement, ConstructorInvocationStatement$0], Statement);
ConstructorInvocationStatement.prototype.clone$ = function () {
	return new ConstructorInvocationStatement$0(this._token, this._ctorClassType, Cloner$x2E$x3CExpression$x3E$cloneArray$ALExpression$(this._args), this._ctorFunctionType);
};


ConstructorInvocationStatement.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	if (this._ctorFunctionType != null) {
		throw new Error("instantiation after analysis?");
	}
	return new ConstructorInvocationStatement$0(this._token, this._ctorClassType.instantiate$LInstantiationContext$(instantiationContext), Cloner$x2E$x3CExpression$x3E$cloneArray$ALExpression$(this._args), null);
};


function ConstructorInvocationStatement$instantiate$LConstructorInvocationStatement$LInstantiationContext$($this, instantiationContext) {
	if ($this._ctorFunctionType != null) {
		throw new Error("instantiation after analysis?");
	}
	return new ConstructorInvocationStatement$0($this._token, $this._ctorClassType.instantiate$LInstantiationContext$(instantiationContext), Cloner$x2E$x3CExpression$x3E$cloneArray$ALExpression$($this._args), null);
};

ConstructorInvocationStatement.instantiate$LConstructorInvocationStatement$LInstantiationContext$ = ConstructorInvocationStatement$instantiate$LConstructorInvocationStatement$LInstantiationContext$;

ConstructorInvocationStatement.prototype.getToken$ = function () {
	return this._token;
};


ConstructorInvocationStatement.prototype.getArguments$ = function () {
	return this._args;
};


function ConstructorInvocationStatement$getArguments$LConstructorInvocationStatement$($this) {
	return $this._args;
};

ConstructorInvocationStatement.getArguments$LConstructorInvocationStatement$ = ConstructorInvocationStatement$getArguments$LConstructorInvocationStatement$;

ConstructorInvocationStatement.prototype.getConstructingClassDef$ = function () {
	return this._ctorClassType.getClassDef$();
};


function ConstructorInvocationStatement$getConstructingClassDef$LConstructorInvocationStatement$($this) {
	return $this._ctorClassType.getClassDef$();
};

ConstructorInvocationStatement.getConstructingClassDef$LConstructorInvocationStatement$ = ConstructorInvocationStatement$getConstructingClassDef$LConstructorInvocationStatement$;

ConstructorInvocationStatement.prototype.getConstructorType$ = function () {
	return this._ctorFunctionType;
};


function ConstructorInvocationStatement$getConstructorType$LConstructorInvocationStatement$($this) {
	return $this._ctorFunctionType;
};

ConstructorInvocationStatement.getConstructorType$LConstructorInvocationStatement$ = ConstructorInvocationStatement$getConstructorType$LConstructorInvocationStatement$;

ConstructorInvocationStatement.prototype.serialize$ = function () {
	return [ "ConstructorInvocationStatement", this._ctorClassType.toString(), Serializer$x2E$x3CExpression$x3E$serializeArray$ALExpression$(this._args) ];
};


ConstructorInvocationStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var ctorType;
	var argTypes;
	var _args$0;
	ctorType = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(this._ctorClassType.getClassDef$(), context.errors, this._token, "constructor", false, [], 1);
	if (ctorType == null) {
		if (this._args.length !== 0) {
			context.errors.push(new CompileError(this._token, "no function with matching arguments"));
			return true;
		}
		ctorType = new MemberFunctionType(this._ctorClassType.getClassDef$().getToken$(), new ObjectType(this._ctorClassType.getClassDef$()), Type.voidType, [], false);
	} else {
		argTypes = Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$AALType$(context, _args$0 = this._args, null, ctorType.getExpectedTypes$NB(_args$0.length, false));
		if (argTypes == null) {
			return true;
		}
		if ((ctorType = ctorType.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, this._token, argTypes, false)) == null) {
			return true;
		}
	}
	this._ctorFunctionType = ctorType;
	return true;
};


ConstructorInvocationStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return (! Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._args) ? false : true);
};


function UnaryExpressionStatement(expr) {
	this._stash = {};
	this._expr = null;
	if (expr == null) {
		throw new Error("logic flaw");
	}
	this._expr = expr;
};

$__jsx_extend([UnaryExpressionStatement], Statement);
UnaryExpressionStatement.prototype.getToken$ = function () {
	return this._expr._token;
};


UnaryExpressionStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$($this) {
	return $this._expr;
};

UnaryExpressionStatement.getExpr$LUnaryExpressionStatement$ = UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$;

UnaryExpressionStatement.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function UnaryExpressionStatement$setExpr$LUnaryExpressionStatement$LExpression$($this, expr) {
	$this._expr = expr;
};

UnaryExpressionStatement.setExpr$LUnaryExpressionStatement$LExpression$ = UnaryExpressionStatement$setExpr$LUnaryExpressionStatement$LExpression$;

UnaryExpressionStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr);
	return true;
};


UnaryExpressionStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function ExpressionStatement(expr) {
	UnaryExpressionStatement.call(this, expr);
};

$__jsx_extend([ExpressionStatement], UnaryExpressionStatement);
ExpressionStatement.prototype.clone$ = function () {
	return new ExpressionStatement(this._expr.clone$());
};


ExpressionStatement.prototype.serialize$ = function () {
	return [ "ExpressionStatement", this._expr.serialize$() ];
};


function FunctionStatement(token, funcDef) {
	this._stash = {};
	this._token = token;
	this._funcDef = funcDef;
};

$__jsx_extend([FunctionStatement], Statement);
FunctionStatement.prototype.clone$ = function () {
	return new FunctionStatement(this._token, this._funcDef);
};


FunctionStatement.prototype.getToken$ = function () {
	return this._token;
};


FunctionStatement.prototype.getFuncDef$ = function () {
	return this._funcDef;
};


function FunctionStatement$getFuncDef$LFunctionStatement$($this) {
	return $this._funcDef;
};

FunctionStatement.getFuncDef$LFunctionStatement$ = FunctionStatement$getFuncDef$LFunctionStatement$;

FunctionStatement.prototype.setFuncDef$LMemberFunctionDefinition$ = function (funcDef) {
	this._funcDef = funcDef;
};


function FunctionStatement$setFuncDef$LFunctionStatement$LMemberFunctionDefinition$($this, funcDef) {
	$this._funcDef = funcDef;
};

FunctionStatement.setFuncDef$LFunctionStatement$LMemberFunctionDefinition$ = FunctionStatement$setFuncDef$LFunctionStatement$LMemberFunctionDefinition$;

FunctionStatement.prototype.serialize$ = function () {
	return [ "FunctionStatement", this._funcDef.serialize$() ];
};


FunctionStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var blockStack$0;
	if (! FunctionStatement$_typesAreIdentified$LFunctionStatement$(this)) {
		context.errors.push(new CompileError(this._token, "argument / return types were not automatically deductable, please specify them by hand"));
		return false;
	}
	MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(this._funcDef, context);
	LocalVariableStatuses$setStatus$LLocalVariableStatuses$LLocalVariable$((blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses, this._funcDef._funcLocal);
	return true;
};


FunctionStatement.prototype._typesAreIdentified$ = function () {
	var argTypes;
	var i;
	var argTypes$len$0;
	argTypes = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._funcDef);
	for ((i = 0, argTypes$len$0 = argTypes.length); i < argTypes$len$0; ++ i) {
		if (argTypes[i] == null) {
			return false;
		}
	}
	return (this._funcDef._returnType == null ? false : true);
};


function FunctionStatement$_typesAreIdentified$LFunctionStatement$($this) {
	var argTypes;
	var i;
	var argTypes$len$0;
	argTypes = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._funcDef);
	for ((i = 0, argTypes$len$0 = argTypes.length); i < argTypes$len$0; ++ i) {
		if (argTypes[i] == null) {
			return false;
		}
	}
	return ($this._funcDef._returnType == null ? false : true);
};

FunctionStatement._typesAreIdentified$LFunctionStatement$ = FunctionStatement$_typesAreIdentified$LFunctionStatement$;

FunctionStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function ReturnStatement(token, expr) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
};

$__jsx_extend([ReturnStatement], Statement);
ReturnStatement.prototype.clone$ = function () {
	var cloneNullable$o$0;
	return new ReturnStatement(this._token, (cloneNullable$o$0 = this._expr, cloneNullable$o$0 == null ? null : cloneNullable$o$0.clone$()));
};


ReturnStatement.prototype.getToken$ = function () {
	return this._token;
};


ReturnStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function ReturnStatement$getExpr$LReturnStatement$($this) {
	return $this._expr;
};

ReturnStatement.getExpr$LReturnStatement$ = ReturnStatement$getExpr$LReturnStatement$;

ReturnStatement.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function ReturnStatement$setExpr$LReturnStatement$LExpression$($this, expr) {
	$this._expr = expr;
};

ReturnStatement.setExpr$LReturnStatement$LExpression$ = ReturnStatement$setExpr$LReturnStatement$LExpression$;

ReturnStatement.prototype.serialize$ = function () {
	var serializeNullable$v$0;
	return [ "ReturnStatement", (serializeNullable$v$0 = this._expr, serializeNullable$v$0 == null ? null : serializeNullable$v$0.serialize$()) ];
};


ReturnStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var returnType;
	var exprType;
	var type$0;
	var this$0;
	var _expr$0;
	var blockStack$0;
	if ((context.funcDef._flags & 8192) !== 0) {
		context.errors.push(new CompileError(this._token, "return statement in generator is not allowed"));
		return true;
	}
	returnType = context.funcDef._returnType;
	if (returnType == null) {
		if (this._expr != null) {
			if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
				return true;
			}
			exprType = this._expr.getType$();
			if (exprType == null) {
				return true;
			}
			context.funcDef._returnType = exprType;
		} else {
			type$0 = Type.voidType;
			context.funcDef._returnType = type$0;
		}
	} else {
		if (returnType.equals$LType$(Type.voidType)) {
			if (this._expr != null) {
				context.errors.push(new CompileError(this._token, "cannot return a value from a void function"));
				return true;
			}
		} else {
			if (this._expr == null) {
				context.errors.push(new CompileError(this._token, "cannot return void, the function is declared to return a value of type '" + returnType.toString() + "'"));
				return true;
			}
			if ((_expr$0 = this._expr) instanceof FunctionExpression && ! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(_expr$0) && returnType instanceof StaticFunctionType) {
				if (! (! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$(this._expr._funcDef, context, returnType) ? false : true)) {
					return false;
				}
			}
			if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
				return true;
			}
			exprType = this._expr.getType$();
			if (exprType == null) {
				return true;
			}
			if (! exprType.isConvertibleTo$LType$(returnType)) {
				context.errors.push(new CompileError(this._token, "cannot convert '" + exprType.toString() + "' to return type '" + returnType.toString() + "'"));
				return false;
			}
		}
	}
	this$0 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
	this$0._isReachable = false;
	return true;
};


ReturnStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	var _expr$0;
	return ((_expr$0 = this._expr) != null && ! cb(_expr$0, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function YieldStatement(token, expr) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
};

$__jsx_extend([YieldStatement], Statement);
YieldStatement.prototype.clone$ = function () {
	var cloneNullable$o$0;
	return new YieldStatement(this._token, (cloneNullable$o$0 = this._expr, cloneNullable$o$0 == null ? null : cloneNullable$o$0.clone$()));
};


YieldStatement.prototype.getToken$ = function () {
	return this._token;
};


YieldStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function YieldStatement$getExpr$LYieldStatement$($this) {
	return $this._expr;
};

YieldStatement.getExpr$LYieldStatement$ = YieldStatement$getExpr$LYieldStatement$;

YieldStatement.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function YieldStatement$setExpr$LYieldStatement$LExpression$($this, expr) {
	$this._expr = expr;
};

YieldStatement.setExpr$LYieldStatement$LExpression$ = YieldStatement$setExpr$LYieldStatement$LExpression$;

YieldStatement.prototype.serialize$ = function () {
	var serializeNullable$v$0;
	return [ "YieldStatement", (serializeNullable$v$0 = this._expr, serializeNullable$v$0 == null ? null : serializeNullable$v$0.serialize$()) ];
};


YieldStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var returnType;
	var yieldType;
	var type$0;
	var getTypeArguments$this$0;
	var getTemplateClassName$this$0;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		return true;
	}
	if (this._expr.getType$() == null) {
		return true;
	}
	returnType = context.funcDef._returnType;
	if (returnType == null) {
		yieldType = this._expr.getType$();
		type$0 = new ObjectType(Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: this._token, _className: "g_Enumerable", _typeArgs: [ yieldType ]}), context.postInstantiationCallback));
		context.funcDef._returnType = type$0;
	} else {
		if (returnType instanceof ObjectType && returnType.getClassDef$() instanceof InstantiatedClassDefinition && (getTemplateClassName$this$0 = returnType.getClassDef$(), getTemplateClassName$this$0._templateClassDef._className) === "g_Enumerable") {
			yieldType = (getTypeArguments$this$0 = returnType.getClassDef$(), getTypeArguments$this$0._typeArguments)[0];
		} else {
			context.errors.push(new CompileError(this._token, "cannot convert 'g_Enumerable.<" + this._expr.getType$().toString() + ">' to return type '" + returnType.toString() + "'"));
			return false;
		}
	}
	if (! this._expr.getType$().isConvertibleTo$LType$(yieldType)) {
		context.errors.push(new CompileError(this._token, "cannot convert '" + this._expr.getType$().toString() + "' to yield type '" + yieldType.toString() + "'"));
		return false;
	}
	return true;
};


YieldStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	var _expr$0;
	return ((_expr$0 = this._expr) != null && ! cb(_expr$0, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function DeleteStatement(token, expr) {
	UnaryExpressionStatement.call(this, expr);
	this._token = token;
};

$__jsx_extend([DeleteStatement], UnaryExpressionStatement);
DeleteStatement.prototype.clone$ = function () {
	return new DeleteStatement(this._token, this._expr.clone$());
};


DeleteStatement.prototype.getToken$ = function () {
	return this._token;
};


DeleteStatement.prototype.serialize$ = function () {
	return [ "DeleteStatement", this._expr.serialize$() ];
};


DeleteStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var secondExprType;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		return true;
	}
	if (! (this._expr instanceof ArrayExpression)) {
		context.errors.push(new CompileError(this._token, "only properties of a map object can be deleted"));
		return true;
	}
	secondExprType = this._expr._expr2.getType$();
	if (secondExprType == null) {
		return true;
	}
	if (! (secondExprType instanceof NullableType ? secondExprType._baseType : secondExprType).equals$LType$(Type.stringType)) {
		context.errors.push(new CompileError(this._token, "only properties of a map object can be deleted"));
		return true;
	}
	return true;
};


function JumpStatement(token, label) {
	this._stash = {};
	this._token = token;
	this._label = label;
};

$__jsx_extend([JumpStatement], Statement);
JumpStatement.prototype.getToken$ = function () {
	return this._token;
};


JumpStatement.prototype.getLabel$ = function () {
	return this._label;
};


function JumpStatement$getLabel$LJumpStatement$($this) {
	return $this._label;
};

JumpStatement.getLabel$LJumpStatement$ = JumpStatement$getLabel$LJumpStatement$;

JumpStatement.prototype.serialize$ = function () {
	var serialize$this$0;
	var serializeNullable$v$0;
	return [ this._getName$(), (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), (serializeNullable$v$0 = this._label, serializeNullable$v$0 == null ? null : [ serializeNullable$v$0._value, serializeNullable$v$0._isIdentifier, serializeNullable$v$0._filename, serializeNullable$v$0._lineNumber, serializeNullable$v$0._columnNumber ]) ];
};


JumpStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var targetBlock;
	var this$0;
	var blockStack$0;
	var blockStack$1;
	var blockStack$2;
	targetBlock = JumpStatement$_determineDestination$LJumpStatement$LAnalysisContext$(this, context);
	if (targetBlock == null) {
		return true;
	}
	if (this instanceof BreakStatement) {
		LabellableStatement$registerVariableStatusesOnBreak$LLabellableStatement$LLocalVariableStatuses$(targetBlock.block, (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses);
	} else {
		ContinuableStatement$registerVariableStatusesOnContinue$LContinuableStatement$LLocalVariableStatuses$(targetBlock.block, (blockStack$1 = context.blockStack)[blockStack$1.length - 1].localVariableStatuses);
	}
	this$0 = (blockStack$2 = context.blockStack)[blockStack$2.length - 1].localVariableStatuses;
	this$0._isReachable = false;
	return true;
};


JumpStatement.prototype._determineDestination$LAnalysisContext$ = function (context) {
	var i;
	var statement;
	var statementLabel;
	var _label$0;
	var _token$0;
	for (i = context.blockStack.length - 1; ! (context.blockStack[i].block instanceof MemberFunctionDefinition); -- i) {
		statement = context.blockStack[i].block;
		if (! (statement instanceof LabellableStatement)) {
			continue;
		}
		if (this._label != null) {
			statementLabel = statement._label;
			if (statementLabel != null && statementLabel._value === this._label._value) {
				if (this._token._value === "continue" && statement instanceof SwitchStatement) {
					context.errors.push(new CompileError(this._token, "cannot 'continue' to a switch statement"));
					return null;
				}
			} else {
				continue;
			}
		} else {
			if (this._token._value === "continue" && statement instanceof SwitchStatement) {
				continue;
			}
		}
		return context.blockStack[i];
	}
	if (this._label != null) {
		context.errors.push(new CompileError(_label$0 = this._label, "label '" + _label$0._value + "' is either not defined or invalid as the destination"));
	} else {
		context.errors.push(new CompileError(_token$0 = this._token, "cannot '" + _token$0._value + "' at this point"));
	}
	return null;
};


function JumpStatement$_determineDestination$LJumpStatement$LAnalysisContext$($this, context) {
	var i;
	var statement;
	var statementLabel;
	var _label$0;
	var _token$0;
	for (i = context.blockStack.length - 1; ! (context.blockStack[i].block instanceof MemberFunctionDefinition); -- i) {
		statement = context.blockStack[i].block;
		if (! (statement instanceof LabellableStatement)) {
			continue;
		}
		if ($this._label != null) {
			statementLabel = statement._label;
			if (statementLabel != null && statementLabel._value === $this._label._value) {
				if ($this._token._value === "continue" && statement instanceof SwitchStatement) {
					context.errors.push(new CompileError($this._token, "cannot 'continue' to a switch statement"));
					return null;
				}
			} else {
				continue;
			}
		} else {
			if ($this._token._value === "continue" && statement instanceof SwitchStatement) {
				continue;
			}
		}
		return context.blockStack[i];
	}
	if ($this._label != null) {
		context.errors.push(new CompileError(_label$0 = $this._label, "label '" + _label$0._value + "' is either not defined or invalid as the destination"));
	} else {
		context.errors.push(new CompileError(_token$0 = $this._token, "cannot '" + _token$0._value + "' at this point"));
	}
	return null;
};

JumpStatement._determineDestination$LJumpStatement$LAnalysisContext$ = JumpStatement$_determineDestination$LJumpStatement$LAnalysisContext$;

JumpStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function BreakStatement(token, label) {
	this._stash = {};
	this._token = token;
	this._label = label;
};

$__jsx_extend([BreakStatement], JumpStatement);
BreakStatement.prototype.clone$ = function () {
	return new BreakStatement(this._token, this._label);
};


BreakStatement.prototype._getName$ = function () {
	return "BreakStatement";
};


BreakStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function ContinueStatement(token, label) {
	this._stash = {};
	this._token = token;
	this._label = label;
};

$__jsx_extend([ContinueStatement], JumpStatement);
ContinueStatement.prototype.clone$ = function () {
	return new ContinueStatement(this._token, this._label);
};


ContinueStatement.prototype._getName$ = function () {
	return "ContinueStatement";
};


ContinueStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function LabellableStatement(token, label) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
};

$__jsx_extend([LabellableStatement], Statement);
$__jsx_merge_interface(LabellableStatement, Block);

LabellableStatement.prototype.getToken$ = function () {
	return this._token;
};


LabellableStatement.prototype.getLabel$ = function () {
	return this._label;
};


function LabellableStatement$getLabel$LLabellableStatement$($this) {
	return $this._label;
};

LabellableStatement.getLabel$LLabellableStatement$ = LabellableStatement$getLabel$LLabellableStatement$;

LabellableStatement.prototype._serialize$ = function () {
	var serializeNullable$v$0;
	return [ (serializeNullable$v$0 = this._label, serializeNullable$v$0 == null ? null : [ serializeNullable$v$0._value, serializeNullable$v$0._isIdentifier, serializeNullable$v$0._filename, serializeNullable$v$0._lineNumber, serializeNullable$v$0._columnNumber ]) ];
};


function LabellableStatement$_serialize$LLabellableStatement$($this) {
	var serializeNullable$v$0;
	return [ (serializeNullable$v$0 = $this._label, serializeNullable$v$0 == null ? null : [ serializeNullable$v$0._value, serializeNullable$v$0._isIdentifier, serializeNullable$v$0._filename, serializeNullable$v$0._lineNumber, serializeNullable$v$0._columnNumber ]) ];
};

LabellableStatement._serialize$LLabellableStatement$ = LabellableStatement$_serialize$LLabellableStatement$;

LabellableStatement.prototype._prepareBlockAnalysis$LAnalysisContext$ = function (context) {
	var this$0;
	var blockStack$0;
	var blockStack$1;
	var _lvStatusesOnBreak$0;
	(blockStack$0 = context.blockStack).push(({localVariableStatuses: new LocalVariableStatuses$0(blockStack$0[blockStack$0.length - 1].localVariableStatuses), block: this}));
	this$0 = (blockStack$1 = context.blockStack)[blockStack$1.length - 1].localVariableStatuses;
	_lvStatusesOnBreak$0 = this._lvStatusesOnBreak = new LocalVariableStatuses$0(this$0);
	_lvStatusesOnBreak$0._isReachable = false;
};


LabellableStatement.prototype._abortBlockAnalysis$LAnalysisContext$ = function (context) {
	context.blockStack.pop();
	this._lvStatusesOnBreak = null;
};


LabellableStatement.prototype._finalizeBlockAnalysis$LAnalysisContext$ = function (context) {
	var blockStack$0;
	context.blockStack.pop();
	(blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses = this._lvStatusesOnBreak;
	this._lvStatusesOnBreak = null;
};


LabellableStatement.prototype.registerVariableStatusesOnBreak$LLocalVariableStatuses$ = function (statuses) {
	if (statuses != null) {
		if (this._lvStatusesOnBreak == null) {
			this._lvStatusesOnBreak = new LocalVariableStatuses$0(statuses);
		} else {
			this._lvStatusesOnBreak = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this._lvStatusesOnBreak, statuses);
		}
	}
};


function LabellableStatement$registerVariableStatusesOnBreak$LLabellableStatement$LLocalVariableStatuses$($this, statuses) {
	if (statuses != null) {
		if ($this._lvStatusesOnBreak == null) {
			$this._lvStatusesOnBreak = new LocalVariableStatuses$0(statuses);
		} else {
			$this._lvStatusesOnBreak = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$($this._lvStatusesOnBreak, statuses);
		}
	}
};

LabellableStatement.registerVariableStatusesOnBreak$LLabellableStatement$LLocalVariableStatuses$ = LabellableStatement$registerVariableStatusesOnBreak$LLabellableStatement$LLocalVariableStatuses$;

function ContinuableStatement(token, label, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._lvStatusesOnContinue = null;
	this._statements = statements;
};

$__jsx_extend([ContinuableStatement], LabellableStatement);
ContinuableStatement.prototype.getStatements$ = function () {
	return this._statements;
};


ContinuableStatement.prototype.forEachStatement$F$LStatement$B$ = function (cb) {
	return (! Util$forEachStatement$F$LStatement$B$ALStatement$(cb, this._statements) ? false : true);
};


ContinuableStatement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	return (! cb(this._statements) ? false : true);
};


ContinuableStatement.prototype._prepareBlockAnalysis$LAnalysisContext$ = function (context) {
	LabellableStatement.prototype._prepareBlockAnalysis$LAnalysisContext$.call(this, context);
	this._lvStatusesOnContinue = null;
};


ContinuableStatement.prototype._abortBlockAnalysis$LAnalysisContext$ = function (context) {
	LabellableStatement.prototype._abortBlockAnalysis$LAnalysisContext$.call(this, context);
	this._lvStatusesOnContinue = null;
};


ContinuableStatement.prototype._finalizeBlockAnalysis$LAnalysisContext$ = function (context) {
	LabellableStatement.prototype._finalizeBlockAnalysis$LAnalysisContext$.call(this, context);
	ContinuableStatement$_restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$(this, context);
};


ContinuableStatement.prototype._restoreContinueVariableStatuses$LAnalysisContext$ = function (context) {
	var blockStack$0;
	if (this._lvStatusesOnContinue != null) {
		(blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(blockStack$0[blockStack$0.length - 1].localVariableStatuses, this._lvStatusesOnContinue);
		this._lvStatusesOnContinue = null;
	}
};


function ContinuableStatement$_restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$($this, context) {
	var blockStack$0;
	if ($this._lvStatusesOnContinue != null) {
		(blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(blockStack$0[blockStack$0.length - 1].localVariableStatuses, $this._lvStatusesOnContinue);
		$this._lvStatusesOnContinue = null;
	}
};

ContinuableStatement._restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$ = ContinuableStatement$_restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$;

ContinuableStatement.prototype.registerVariableStatusesOnContinue$LLocalVariableStatuses$ = function (statuses) {
	if (statuses != null) {
		if (this._lvStatusesOnContinue == null) {
			this._lvStatusesOnContinue = new LocalVariableStatuses$0(statuses);
		} else {
			this._lvStatusesOnContinue = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this._lvStatusesOnContinue, statuses);
		}
	}
};


function ContinuableStatement$registerVariableStatusesOnContinue$LContinuableStatement$LLocalVariableStatuses$($this, statuses) {
	if (statuses != null) {
		if ($this._lvStatusesOnContinue == null) {
			$this._lvStatusesOnContinue = new LocalVariableStatuses$0(statuses);
		} else {
			$this._lvStatusesOnContinue = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$($this._lvStatusesOnContinue, statuses);
		}
	}
};

ContinuableStatement.registerVariableStatusesOnContinue$LContinuableStatement$LLocalVariableStatuses$ = ContinuableStatement$registerVariableStatusesOnContinue$LContinuableStatement$LLocalVariableStatuses$;

function DoWhileStatement(token, label, expr, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._lvStatusesOnContinue = null;
	this._statements = statements;
	this._expr = expr;
};

$__jsx_extend([DoWhileStatement], ContinuableStatement);
DoWhileStatement.prototype.clone$ = function () {
	return new DoWhileStatement(this._token, this._label, this._expr.clone$(), Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(this._statements));
};


DoWhileStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function DoWhileStatement$getExpr$LDoWhileStatement$($this) {
	return $this._expr;
};

DoWhileStatement.getExpr$LDoWhileStatement$ = DoWhileStatement$getExpr$LDoWhileStatement$;

DoWhileStatement.prototype.serialize$ = function () {
	return [ "DoWhileStatement" ].concat(LabellableStatement$_serialize$LLabellableStatement$(this)).concat([ this._expr.serialize$(), Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this._statements) ]);
};


DoWhileStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var i;
	var resolveIfNullable$this$0;
	var blockStack$0;
	this._prepareBlockAnalysis$LAnalysisContext$(context);
	try {
		for (i = 0; i < this._statements.length; ++ i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
				return false;
			}
		}
		ContinuableStatement$_restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$(this, context);
		if (! Statement$assertIsReachable$LAnalysisContext$LToken$(context, this._expr._token)) {
			return false;
		}
		if (Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
			if ((resolveIfNullable$this$0 = this._expr.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0).equals$LType$(Type.voidType)) {
				context.errors.push(new CompileError(this._expr._token, "expression of the do-while statement should not return void"));
			}
		}
		LabellableStatement$registerVariableStatusesOnBreak$LLabellableStatement$LLocalVariableStatuses$(this, (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses);
		this._finalizeBlockAnalysis$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			this._abortBlockAnalysis$LAnalysisContext$(context);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	return true;
};


DoWhileStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function ForInStatement(token, label, lhsExpr, listExpr, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._lvStatusesOnContinue = null;
	this._statements = statements;
	this._lhsExpr = lhsExpr;
	this._listExpr = listExpr;
};

$__jsx_extend([ForInStatement], ContinuableStatement);
ForInStatement.prototype.clone$ = function () {
	return new ForInStatement(this._token, this._label, this._lhsExpr.clone$(), this._listExpr.clone$(), Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(this._statements));
};


ForInStatement.prototype.getLHSExpr$ = function () {
	return this._lhsExpr;
};


function ForInStatement$getLHSExpr$LForInStatement$($this) {
	return $this._lhsExpr;
};

ForInStatement.getLHSExpr$LForInStatement$ = ForInStatement$getLHSExpr$LForInStatement$;

ForInStatement.prototype.getListExpr$ = function () {
	return this._listExpr;
};


function ForInStatement$getListExpr$LForInStatement$($this) {
	return $this._listExpr;
};

ForInStatement.getListExpr$LForInStatement$ = ForInStatement$getListExpr$LForInStatement$;

ForInStatement.prototype.getStatements$ = function () {
	return this._statements;
};


ForInStatement.prototype.serialize$ = function () {
	return [ "ForInStatement" ].concat(LabellableStatement$_serialize$LLabellableStatement$(this)).concat([ this._lhsExpr.serialize$(), this._listExpr.serialize$(), Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this._statements) ]);
};


ForInStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var listType;
	var listClassDef;
	var listTypeName;
	var i;
	var this$0;
	var blockStack$0;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._listExpr)) {
		return true;
	}
	this$0 = this._listExpr.getType$();
	listType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	if (listType instanceof ObjectType && (listClassDef = listType.getClassDef$()) instanceof InstantiatedClassDefinition && ((listTypeName = listClassDef._templateClassDef._className) === "Array" || listTypeName === "Map")) {
	} else {
		context.errors.push(new CompileError(this._token, "list expression of the for..in statement should be an array or a map"));
		return true;
	}
	this._prepareBlockAnalysis$LAnalysisContext$(context);
	try {
		Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._lhsExpr);
		if (! this._lhsExpr.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, listTypeName === "Array" ? Type.numberType : Type.stringType)) {
			return false;
		}
		for (i = 0; i < this._statements.length; ++ i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
				return false;
			}
		}
		ContinuableStatement$registerVariableStatusesOnContinue$LContinuableStatement$LLocalVariableStatuses$(this, (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses);
		this._finalizeBlockAnalysis$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			this._abortBlockAnalysis$LAnalysisContext$(context);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	return true;
};


ForInStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._lhsExpr, (function (expr) {
		$this._lhsExpr = expr;
	})) ? false : ! cb(this._listExpr, (function (expr) {
		$this._listExpr = expr;
	})) ? false : true);
};


function ForStatement(token, label, initExpr, condExpr, postExpr, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._lvStatusesOnContinue = null;
	this._statements = statements;
	this._initExpr = initExpr;
	this._condExpr = condExpr;
	this._postExpr = postExpr;
};

$__jsx_extend([ForStatement], ContinuableStatement);
ForStatement.prototype.clone$ = function () {
	var cloneNullable$o$0;
	var cloneNullable$o$1;
	var cloneNullable$o$2;
	return new ForStatement(this._token, this._label, (cloneNullable$o$0 = this._initExpr, cloneNullable$o$0 == null ? null : cloneNullable$o$0.clone$()), (cloneNullable$o$1 = this._condExpr, cloneNullable$o$1 == null ? null : cloneNullable$o$1.clone$()), (cloneNullable$o$2 = this._postExpr, cloneNullable$o$2 == null ? null : cloneNullable$o$2.clone$()), Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(this._statements));
};


ForStatement.prototype.getInitExpr$ = function () {
	return this._initExpr;
};


function ForStatement$getInitExpr$LForStatement$($this) {
	return $this._initExpr;
};

ForStatement.getInitExpr$LForStatement$ = ForStatement$getInitExpr$LForStatement$;

ForStatement.prototype.setInitExpr$LExpression$ = function (expr) {
	this._initExpr = expr;
};


function ForStatement$setInitExpr$LForStatement$LExpression$($this, expr) {
	$this._initExpr = expr;
};

ForStatement.setInitExpr$LForStatement$LExpression$ = ForStatement$setInitExpr$LForStatement$LExpression$;

ForStatement.prototype.getCondExpr$ = function () {
	return this._condExpr;
};


function ForStatement$getCondExpr$LForStatement$($this) {
	return $this._condExpr;
};

ForStatement.getCondExpr$LForStatement$ = ForStatement$getCondExpr$LForStatement$;

ForStatement.prototype.getPostExpr$ = function () {
	return this._postExpr;
};


function ForStatement$getPostExpr$LForStatement$($this) {
	return $this._postExpr;
};

ForStatement.getPostExpr$LForStatement$ = ForStatement$getPostExpr$LForStatement$;

ForStatement.prototype.getStatements$ = function () {
	return this._statements;
};


ForStatement.prototype.serialize$ = function () {
	var serializeNullable$v$0;
	var serializeNullable$v$1;
	var serializeNullable$v$2;
	return [ "ForStatement" ].concat(LabellableStatement$_serialize$LLabellableStatement$(this)).concat([ (serializeNullable$v$0 = this._initExpr, serializeNullable$v$0 == null ? null : serializeNullable$v$0.serialize$()), (serializeNullable$v$1 = this._condExpr, serializeNullable$v$1 == null ? null : serializeNullable$v$1.serialize$()), (serializeNullable$v$2 = this._postExpr, serializeNullable$v$2 == null ? null : serializeNullable$v$2.serialize$()), Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this._statements) ]);
};


ForStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var i;
	var resolveIfNullable$this$0;
	var blockStack$0;
	if (this._initExpr != null) {
		Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._initExpr);
	}
	if (this._condExpr != null) {
		if (Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._condExpr)) {
			if ((resolveIfNullable$this$0 = this._condExpr.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0).equals$LType$(Type.voidType)) {
				context.errors.push(new CompileError(this._condExpr._token, "condition expression of the for statement should not return void"));
			}
		}
	}
	this._prepareBlockAnalysis$LAnalysisContext$(context);
	try {
		for (i = 0; i < this._statements.length; ++ i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
				return false;
			}
		}
		ContinuableStatement$_restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$(this, context);
		if (this._postExpr != null) {
			if (! Statement$assertIsReachable$LAnalysisContext$LToken$(context, this._postExpr._token)) {
				return false;
			}
			Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._postExpr);
		}
		LabellableStatement$registerVariableStatusesOnBreak$LLabellableStatement$LLocalVariableStatuses$(this, (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses);
		this._finalizeBlockAnalysis$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			this._abortBlockAnalysis$LAnalysisContext$(context);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	return true;
};


ForStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	var _initExpr$0;
	return ((_initExpr$0 = this._initExpr) != null && ! cb(_initExpr$0, (function (expr) {
		$this._initExpr = expr;
	})) ? false : this._condExpr != null && ! cb(this._condExpr, (function (expr) {
		$this._condExpr = expr;
	})) ? false : this._postExpr != null && ! cb(this._postExpr, (function (expr) {
		$this._postExpr = expr;
	})) ? false : true);
};


function IfStatement(token, expr, onTrueStatements, onFalseStatements) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
	this._onTrueStatements = onTrueStatements;
	this._onFalseStatements = onFalseStatements;
};

$__jsx_extend([IfStatement], Statement);
$__jsx_merge_interface(IfStatement, Block);

IfStatement.prototype.clone$ = function () {
	return new IfStatement(this._token, this._expr.clone$(), Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(this._onTrueStatements), Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(this._onFalseStatements));
};


IfStatement.prototype.getToken$ = function () {
	return this._token;
};


IfStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function IfStatement$getExpr$LIfStatement$($this) {
	return $this._expr;
};

IfStatement.getExpr$LIfStatement$ = IfStatement$getExpr$LIfStatement$;

IfStatement.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function IfStatement$setExpr$LIfStatement$LExpression$($this, expr) {
	$this._expr = expr;
};

IfStatement.setExpr$LIfStatement$LExpression$ = IfStatement$setExpr$LIfStatement$LExpression$;

IfStatement.prototype.getOnTrueStatements$ = function () {
	return this._onTrueStatements;
};


function IfStatement$getOnTrueStatements$LIfStatement$($this) {
	return $this._onTrueStatements;
};

IfStatement.getOnTrueStatements$LIfStatement$ = IfStatement$getOnTrueStatements$LIfStatement$;

IfStatement.prototype.getOnFalseStatements$ = function () {
	return this._onFalseStatements;
};


function IfStatement$getOnFalseStatements$LIfStatement$($this) {
	return $this._onFalseStatements;
};

IfStatement.getOnFalseStatements$LIfStatement$ = IfStatement$getOnFalseStatements$LIfStatement$;

IfStatement.prototype.serialize$ = function () {
	return [ "IfStatement", this._expr.serialize$(), Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this._onTrueStatements), Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this._onFalseStatements) ];
};


IfStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var lvStatusesOnTrueStmts;
	var lvStatusesOnFalseStmts;
	var i;
	var resolveIfNullable$this$0;
	var blockStack$0;
	var blockStack$1;
	var blockStack$2;
	var blockStack$3;
	var blockStack$4;
	if (Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		if ((resolveIfNullable$this$0 = this._expr.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0).equals$LType$(Type.voidType)) {
			context.errors.push(new CompileError(this._expr._token, "expression of the if statement should not return void"));
		}
	}
	(blockStack$1 = context.blockStack).push(({localVariableStatuses: new LocalVariableStatuses$0(blockStack$1[blockStack$1.length - 1].localVariableStatuses), block: this}));
	(lvStatusesOnTrueStmts = null, lvStatusesOnFalseStmts = null);
	try {
		for (i = 0; i < this._onTrueStatements.length; ++ i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._onTrueStatements[i], context)) {
				return false;
			}
		}
		lvStatusesOnTrueStmts = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
	} finally {
		context.blockStack.pop();
	}
	try {
		(blockStack$2 = context.blockStack).push(({localVariableStatuses: new LocalVariableStatuses$0(blockStack$2[blockStack$2.length - 1].localVariableStatuses), block: this}));
		for (i = 0; i < this._onFalseStatements.length; ++ i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._onFalseStatements[i], context)) {
				return false;
			}
		}
		lvStatusesOnFalseStmts = (blockStack$3 = context.blockStack)[blockStack$3.length - 1].localVariableStatuses;
	} finally {
		context.blockStack.pop();
	}
	(blockStack$4 = context.blockStack)[blockStack$4.length - 1].localVariableStatuses = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(lvStatusesOnTrueStmts, lvStatusesOnFalseStmts);
	return true;
};


IfStatement.prototype.forEachStatement$F$LStatement$B$ = function (cb) {
	return (! Util$forEachStatement$F$LStatement$B$ALStatement$(cb, this._onTrueStatements) ? false : ! Util$forEachStatement$F$LStatement$B$ALStatement$(cb, this._onFalseStatements) ? false : true);
};


IfStatement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	return (! cb(this._onTrueStatements) ? false : ! cb(this._onFalseStatements) ? false : true);
};


IfStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function SwitchStatement(token, label, expr, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._expr = expr;
	this._statements = statements;
};

$__jsx_extend([SwitchStatement], LabellableStatement);
SwitchStatement.prototype.clone$ = function () {
	return new SwitchStatement(this._token, this._label, this._expr.clone$(), Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(this._statements));
};


SwitchStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function SwitchStatement$getExpr$LSwitchStatement$($this) {
	return $this._expr;
};

SwitchStatement.getExpr$LSwitchStatement$ = SwitchStatement$getExpr$LSwitchStatement$;

SwitchStatement.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function SwitchStatement$setExpr$LSwitchStatement$LExpression$($this, expr) {
	$this._expr = expr;
};

SwitchStatement.setExpr$LSwitchStatement$LExpression$ = SwitchStatement$setExpr$LSwitchStatement$LExpression$;

SwitchStatement.prototype.getStatements$ = function () {
	return this._statements;
};


function SwitchStatement$getStatements$LSwitchStatement$($this) {
	return $this._statements;
};

SwitchStatement.getStatements$LSwitchStatement$ = SwitchStatement$getStatements$LSwitchStatement$;

SwitchStatement.prototype.serialize$ = function () {
	return [ "SwitchStatement" ].concat(LabellableStatement$_serialize$LLabellableStatement$(this)).concat([ this._expr.serialize$(), Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this._statements) ]);
};


SwitchStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var exprType;
	var hasDefaultLabel;
	var caseMap;
	var i;
	var statement;
	var caseExpr;
	var caseStr;
	var this$0;
	var this$1;
	var _token$0;
	var _token$1;
	var blockStack$0;
	var blockStack$1;
	var blockStack$2;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		return true;
	}
	this$0 = this._expr.getType$();
	exprType = (this$0 instanceof NullableType ? this$0._baseType : this$0);
	if (! (exprType.equals$LType$(Type.booleanType) || exprType.equals$LType$(Type.integerType) || exprType.equals$LType$(Type.numberType) || exprType.equals$LType$(Type.stringType))) {
		context.errors.push(new CompileError(this._token, "switch statement only accepts boolean, number, or string expressions"));
		return true;
	}
	this._prepareBlockAnalysis$LAnalysisContext$(context);
	try {
		hasDefaultLabel = false;
		caseMap = {};
		for (i = 0; i < this._statements.length; ++ i) {
			statement = this._statements[i];
			if (! Statement$analyze$LStatement$LAnalysisContext$(statement, context)) {
				return false;
			}
			if (statement instanceof DefaultStatement) {
				hasDefaultLabel = true;
			} else {
				if (statement instanceof CaseStatement) {
					caseExpr = statement._expr;
					if (caseExpr instanceof IntegerLiteralExpression || caseExpr instanceof NumberLiteralExpression || caseExpr instanceof BooleanLiteralExpression) {
						if ($__jsx_ObjectHasOwnProperty.call(caseMap, caseExpr._token._value)) {
							context.errors.push(new CompileError(_token$0 = caseExpr._token, "duplicate case value " + _token$0._value));
							return false;
						} else {
							caseMap[caseExpr._token._value] = true;
						}
					} else {
						if (caseExpr instanceof StringLiteralExpression) {
							caseStr = Util$decodeStringLiteral$S(caseExpr._token._value);
							if ($__jsx_ObjectHasOwnProperty.call(caseMap, caseStr)) {
								context.errors.push(new CompileError(_token$1 = caseExpr._token, "duplicate case value " + _token$1._value));
								return false;
							} else {
								caseMap[caseStr] = true;
							}
						}
					}
				}
			}
		}
		this$1 = (blockStack$1 = context.blockStack)[blockStack$1.length - 1].localVariableStatuses;
		if (this$1._isReachable) {
			LabellableStatement$registerVariableStatusesOnBreak$LLabellableStatement$LLocalVariableStatuses$(this, (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses);
		}
		if (! hasDefaultLabel) {
			LabellableStatement$registerVariableStatusesOnBreak$LLabellableStatement$LLocalVariableStatuses$(this, (blockStack$2 = context.blockStack)[blockStack$2.length - 2].localVariableStatuses);
		}
		this._finalizeBlockAnalysis$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			this._abortBlockAnalysis$LAnalysisContext$(context);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	return true;
};


SwitchStatement.prototype.forEachStatement$F$LStatement$B$ = function (cb) {
	return (! Util$forEachStatement$F$LStatement$B$ALStatement$(cb, this._statements) ? false : true);
};


SwitchStatement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	return (! cb(this._statements) ? false : true);
};


SwitchStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function SwitchStatement$resetLocalVariableStatuses$LAnalysisContext$(context) {
	var blockStack$0;
	(blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses = new LocalVariableStatuses$0(blockStack$0[blockStack$0.length - 2].localVariableStatuses);
};

SwitchStatement.resetLocalVariableStatuses$LAnalysisContext$ = SwitchStatement$resetLocalVariableStatuses$LAnalysisContext$;

function CaseStatement(token, expr) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
};

$__jsx_extend([CaseStatement], Statement);
CaseStatement.prototype.clone$ = function () {
	return new CaseStatement(this._token, this._expr.clone$());
};


CaseStatement.prototype.getToken$ = function () {
	return this._token;
};


CaseStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function CaseStatement$getExpr$LCaseStatement$($this) {
	return $this._expr;
};

CaseStatement.getExpr$LCaseStatement$ = CaseStatement$getExpr$LCaseStatement$;

CaseStatement.prototype.serialize$ = function () {
	return [ "CaseStatement", this._expr.serialize$() ];
};


CaseStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var statement;
	var expectedType;
	var exprType;
	var blockStack$0;
	var blockStack$1;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		return true;
	}
	statement = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].block;
	if (! (statement instanceof SwitchStatement)) {
		throw new Error("logic flaw");
	}
	expectedType = statement._expr.getType$();
	if (expectedType == null) {
		return true;
	}
	expectedType = (expectedType instanceof NullableType ? expectedType._baseType : expectedType);
	exprType = this._expr.getType$();
	if (exprType == null) {
		return true;
	}
	exprType = (exprType instanceof NullableType ? exprType._baseType : exprType);
	if (exprType.equals$LType$(expectedType)) {
	} else {
		if ((exprType instanceof IntegerType || exprType instanceof NumberType) && (expectedType instanceof IntegerType || expectedType instanceof NumberType)) {
		} else {
			if (expectedType.equals$LType$(Type.stringType) && exprType.equals$LType$(Type.nullType)) {
			} else {
				context.errors.push(new CompileError(this._token, "type mismatch; expected type was '" + expectedType.toString() + "' but got '" + exprType.toString() + "'"));
			}
		}
	}
	(blockStack$1 = context.blockStack)[blockStack$1.length - 1].localVariableStatuses = new LocalVariableStatuses$0(blockStack$1[blockStack$1.length - 2].localVariableStatuses);
	return true;
};


CaseStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function DefaultStatement(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([DefaultStatement], Statement);
DefaultStatement.prototype.clone$ = function () {
	return new DefaultStatement(this._token);
};


DefaultStatement.prototype.getToken$ = function () {
	return this._token;
};


DefaultStatement.prototype.serialize$ = function () {
	return [ "DefaultStatement" ];
};


DefaultStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var blockStack$0;
	(blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses = new LocalVariableStatuses$0(blockStack$0[blockStack$0.length - 2].localVariableStatuses);
	return true;
};


DefaultStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function WhileStatement(token, label, expr, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._lvStatusesOnContinue = null;
	this._statements = statements;
	this._expr = expr;
};

$__jsx_extend([WhileStatement], ContinuableStatement);
WhileStatement.prototype.clone$ = function () {
	return new WhileStatement(this._token, this._label, this._expr.clone$(), Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(this._statements));
};


WhileStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function WhileStatement$getExpr$LWhileStatement$($this) {
	return $this._expr;
};

WhileStatement.getExpr$LWhileStatement$ = WhileStatement$getExpr$LWhileStatement$;

WhileStatement.prototype.getStatements$ = function () {
	return this._statements;
};


WhileStatement.prototype.serialize$ = function () {
	return [ "WhileStatement" ].concat(LabellableStatement$_serialize$LLabellableStatement$(this)).concat([ this._expr.serialize$(), Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this._statements) ]);
};


WhileStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var i;
	var resolveIfNullable$this$0;
	var blockStack$0;
	if (Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		if ((resolveIfNullable$this$0 = this._expr.getType$(), resolveIfNullable$this$0 instanceof NullableType ? resolveIfNullable$this$0._baseType : resolveIfNullable$this$0).equals$LType$(Type.voidType)) {
			context.errors.push(new CompileError(this._expr._token, "expression of the while statement should not return void"));
		}
	}
	this._prepareBlockAnalysis$LAnalysisContext$(context);
	try {
		for (i = 0; i < this._statements.length; ++ i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
				return false;
			}
		}
		ContinuableStatement$registerVariableStatusesOnContinue$LContinuableStatement$LLocalVariableStatuses$(this, (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses);
		this._finalizeBlockAnalysis$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			this._abortBlockAnalysis$LAnalysisContext$(context);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	return true;
};


WhileStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function TryStatement(token, tryStatements, catchStatements, finallyStatements) {
	this._stash = {};
	this._token = token;
	this._tryStatements = tryStatements;
	this._catchStatements = catchStatements;
	this._finallyStatements = finallyStatements;
};

$__jsx_extend([TryStatement], Statement);
$__jsx_merge_interface(TryStatement, Block);

TryStatement.prototype.clone$ = function () {
	return new TryStatement(this._token, Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(this._tryStatements), Cloner$x2E$x3CCatchStatement$x3E$cloneArray$ALCatchStatement$(this._catchStatements), Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(this._finallyStatements));
};


TryStatement.prototype.getToken$ = function () {
	return this._token;
};


TryStatement.prototype.getTryStatements$ = function () {
	return this._tryStatements;
};


function TryStatement$getTryStatements$LTryStatement$($this) {
	return $this._tryStatements;
};

TryStatement.getTryStatements$LTryStatement$ = TryStatement$getTryStatements$LTryStatement$;

TryStatement.prototype.getCatchStatements$ = function () {
	return this._catchStatements;
};


function TryStatement$getCatchStatements$LTryStatement$($this) {
	return $this._catchStatements;
};

TryStatement.getCatchStatements$LTryStatement$ = TryStatement$getCatchStatements$LTryStatement$;

TryStatement.prototype.getFinallyStatements$ = function () {
	return this._finallyStatements;
};


function TryStatement$getFinallyStatements$LTryStatement$($this) {
	return $this._finallyStatements;
};

TryStatement.getFinallyStatements$LTryStatement$ = TryStatement$getFinallyStatements$LTryStatement$;

TryStatement.prototype.serialize$ = function () {
	return [ "TryStatement", Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this._tryStatements), Serializer$x2E$x3CCatchStatement$x3E$serializeArray$ALCatchStatement$(this._catchStatements), Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this._finallyStatements) ];
};


TryStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var lvStatusesAfterTryCatch;
	var i;
	var lvStatusesAfterCatch;
	var curCatchType;
	var j;
	var precCatchType;
	var lvStatusesAfterFinally;
	var this$0;
	var this$1;
	var blockStack$0;
	var blockStack$1;
	var blockStack$2;
	var blockStack$3;
	var blockStack$4;
	var blockStack$5;
	var blockStack$6;
	if ((context.funcDef._flags & 8192) !== 0) {
		context.errors.push(new CompileError(this._token, "invalid use of try block inside generator"));
		return false;
	}
	(blockStack$1 = context.blockStack).push(({localVariableStatuses: new LocalVariableStatuses$0(blockStack$1[blockStack$1.length - 1].localVariableStatuses), block: this}));
	lvStatusesAfterTryCatch = null;
	try {
		for (i = 0; i < this._tryStatements.length; ++ i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._tryStatements[i], context)) {
				return false;
			}
		}
		lvStatusesAfterTryCatch = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
	} finally {
		context.blockStack.pop();
	}
	for (i = 0; i < this._catchStatements.length; ++ i) {
		(blockStack$3 = context.blockStack).push(({localVariableStatuses: new LocalVariableStatuses$0(blockStack$3[blockStack$3.length - 1].localVariableStatuses), block: this._catchStatements[i]}));
		lvStatusesAfterCatch = null;
		try {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._catchStatements[i], context)) {
				return false;
			}
			lvStatusesAfterCatch = (blockStack$2 = context.blockStack)[blockStack$2.length - 1].localVariableStatuses;
		} finally {
			context.blockStack.pop();
		}
		lvStatusesAfterTryCatch = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(lvStatusesAfterTryCatch, lvStatusesAfterCatch);
		this$0 = this._catchStatements[i]._local;
		curCatchType = this$0._type;
		for (j = 0; j < i; ++ j) {
			this$1 = this._catchStatements[j]._local;
			precCatchType = this$1._type;
			if (curCatchType.isConvertibleTo$LType$(precCatchType)) {
				context.errors.push(new CompileError(this._catchStatements[i]._token, "code is unreachable, a broader catch statement for type '" + precCatchType.toString() + "' already exists"));
				return false;
			}
		}
	}
	(blockStack$5 = context.blockStack).push(({localVariableStatuses: LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(blockStack$5[blockStack$5.length - 1].localVariableStatuses, lvStatusesAfterTryCatch), block: this}));
	lvStatusesAfterFinally = null;
	try {
		for (i = 0; i < this._finallyStatements.length; ++ i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._finallyStatements[i], context)) {
				return false;
			}
		}
		lvStatusesAfterFinally = (blockStack$4 = context.blockStack)[blockStack$4.length - 1].localVariableStatuses;
	} finally {
		context.blockStack.pop();
	}
	(blockStack$6 = context.blockStack)[blockStack$6.length - 1].localVariableStatuses = LocalVariableStatuses$mergeFinally$LLocalVariableStatuses$LLocalVariableStatuses$(lvStatusesAfterTryCatch, lvStatusesAfterFinally);
	return true;
};


TryStatement.prototype.forEachStatement$F$LStatement$B$ = function (cb) {
	var $this = this;
	return (! Util$forEachStatement$F$LStatement$B$ALStatement$(cb, this._tryStatements) ? false : ! Util$forEachStatement$F$LStatement$B$ALStatement$(cb, this._catchStatements.map((function (s) {
		return s;
	}))) ? false : ! Util$forEachStatement$F$LStatement$B$ALStatement$(cb, this._finallyStatements) ? false : true);
};


TryStatement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	var $this = this;
	return (! cb(this._tryStatements) ? false : ! cb(this._catchStatements.map((function (s) {
		return s;
	}))) ? false : ! cb(this._finallyStatements) ? false : true);
};


TryStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function CatchStatement(token, local, statements) {
	this._stash = {};
	this._token = token;
	this._local = local;
	this._statements = statements;
};

$__jsx_extend([CatchStatement], Statement);
$__jsx_merge_interface(CatchStatement, Block);

CatchStatement.prototype.clone$ = function () {
	return new CatchStatement(this._token, this._local, Cloner$x2E$x3CStatement$x3E$cloneArray$ALStatement$(this._statements));
};


CatchStatement.prototype.getToken$ = function () {
	return this._token;
};


CatchStatement.prototype.getLocal$ = function () {
	return this._local;
};


function CatchStatement$getLocal$LCatchStatement$($this) {
	return $this._local;
};

CatchStatement.getLocal$LCatchStatement$ = CatchStatement$getLocal$LCatchStatement$;

CatchStatement.prototype.setLocal$LCaughtVariable$ = function (local) {
	this._local = local;
};


function CatchStatement$setLocal$LCatchStatement$LCaughtVariable$($this, local) {
	$this._local = local;
};

CatchStatement.setLocal$LCatchStatement$LCaughtVariable$ = CatchStatement$setLocal$LCatchStatement$LCaughtVariable$;

CatchStatement.prototype.getStatements$ = function () {
	return this._statements;
};


function CatchStatement$getStatements$LCatchStatement$($this) {
	return $this._statements;
};

CatchStatement.getStatements$LCatchStatement$ = CatchStatement$getStatements$LCatchStatement$;

CatchStatement.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "CatchStatement", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), LocalVariable$serialize$LLocalVariable$(this._local), Serializer$x2E$x3CStatement$x3E$serializeArray$ALStatement$(this._statements) ];
};


CatchStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var catchType;
	var i;
	var this$0;
	this$0 = this._local;
	catchType = this$0._type;
	if (! (catchType instanceof ObjectType || catchType.equals$LType$(Type.variantType))) {
		context.errors.push(new CompileError(this._token, "only objects or a variant may be caught"));
	}
	for (i = 0; i < this._statements.length; ++ i) {
		if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
			return false;
		}
	}
	return true;
};


CatchStatement.prototype.forEachStatement$F$LStatement$B$ = function (cb) {
	return Util$forEachStatement$F$LStatement$B$ALStatement$(cb, this._statements);
};


CatchStatement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	return cb(this._statements);
};


CatchStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function ThrowStatement(token, expr) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
};

$__jsx_extend([ThrowStatement], Statement);
ThrowStatement.prototype.clone$ = function () {
	return new ThrowStatement(this._token, this._expr.clone$());
};


ThrowStatement.prototype.getToken$ = function () {
	return this._token;
};


ThrowStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function ThrowStatement$getExpr$LThrowStatement$($this) {
	return $this._expr;
};

ThrowStatement.getExpr$LThrowStatement$ = ThrowStatement$getExpr$LThrowStatement$;

ThrowStatement.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "ThrowStatement", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), this._expr.serialize$() ];
};


ThrowStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var errorClassDef;
	var this$0;
	var blockStack$0;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		return true;
	}
	errorClassDef = Parser$lookup$LParser$ALCompileError$LToken$S(context.parser, context.errors, this._token, "Error");
	if (errorClassDef == null) {
		throw new Error("could not find definition for Error");
	}
	if (this._expr.getType$().equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(this._token, "cannot throw 'void'"));
		return true;
	}
	this$0 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
	this$0._isReachable = false;
	return true;
};


ThrowStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function InformationStatement(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([InformationStatement], Statement);
InformationStatement.prototype.getToken$ = function () {
	return this._token;
};


function AssertStatement(token, expr, msgExpr) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
	this._msgExpr = msgExpr;
};

$__jsx_extend([AssertStatement], InformationStatement);
AssertStatement.prototype.clone$ = function () {
	var cloneNullable$o$0;
	return new AssertStatement(this._token, this._expr.clone$(), (cloneNullable$o$0 = this._msgExpr, cloneNullable$o$0 == null ? null : cloneNullable$o$0.clone$()));
};


AssertStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function AssertStatement$getExpr$LAssertStatement$($this) {
	return $this._expr;
};

AssertStatement.getExpr$LAssertStatement$ = AssertStatement$getExpr$LAssertStatement$;

AssertStatement.prototype.getMessageExpr$ = function () {
	return this._msgExpr;
};


function AssertStatement$getMessageExpr$LAssertStatement$($this) {
	return $this._msgExpr;
};

AssertStatement.getMessageExpr$LAssertStatement$ = AssertStatement$getMessageExpr$LAssertStatement$;

AssertStatement.prototype.serialize$ = function () {
	var serialize$this$0;
	var serializeNullable$v$0;
	var serializeNullable$v$1;
	return [ "AssertStatement", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), (serializeNullable$v$0 = this._expr, serializeNullable$v$0 == null ? null : serializeNullable$v$0.serialize$()), (serializeNullable$v$1 = this._msgExpr, serializeNullable$v$1 == null ? null : serializeNullable$v$1.serialize$()) ];
};


AssertStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var exprType;
	var msgExprType;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		return true;
	}
	exprType = this._expr.getType$();
	if (exprType.equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(this._expr._token, "argument of the assert statement cannot be void"));
	}
	if (this._msgExpr != null) {
		if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._msgExpr)) {
			return true;
		}
		msgExprType = this._msgExpr.getType$();
		if (! msgExprType.equals$LType$(Type.stringType)) {
			context.errors.push(new CompileError(this._msgExpr._token, "message expression of the assert statement must be of string type"));
		}
	}
	return true;
};


AssertStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : this._msgExpr != null && ! cb(this._msgExpr, (function (expr) {
		$this._msgExpr = expr;
	})) ? false : true);
};


function LogStatement(token, exprs) {
	this._stash = {};
	this._token = token;
	this._exprs = exprs;
};

$__jsx_extend([LogStatement], InformationStatement);
LogStatement.prototype.clone$ = function () {
	return new LogStatement(this._token, Cloner$x2E$x3CExpression$x3E$cloneArray$ALExpression$(this._exprs));
};


LogStatement.prototype.getExprs$ = function () {
	return this._exprs;
};


function LogStatement$getExprs$LLogStatement$($this) {
	return $this._exprs;
};

LogStatement.getExprs$LLogStatement$ = LogStatement$getExprs$LLogStatement$;

LogStatement.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "LogStatement", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]), Serializer$x2E$x3CExpression$x3E$serializeArray$ALExpression$(this._exprs) ];
};


LogStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var i;
	var exprType;
	for (i = 0; i < this._exprs.length; ++ i) {
		if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._exprs[i])) {
			return true;
		}
		exprType = this._exprs[i].getType$();
		if (exprType == null) {
			return true;
		}
		if (exprType.equals$LType$(Type.voidType)) {
			context.errors.push(new CompileError(this._token, "cannot log a void expression"));
			break;
		}
	}
	return true;
};


LogStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._exprs);
};


function DebuggerStatement(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([DebuggerStatement], InformationStatement);
DebuggerStatement.prototype.clone$ = function () {
	return new DebuggerStatement(this._token);
};


DebuggerStatement.prototype.serialize$ = function () {
	var serialize$this$0;
	return [ "DebuggerStatement", (serialize$this$0 = this._token, [ serialize$this$0._value, serialize$this$0._isIdentifier, serialize$this$0._filename, serialize$this$0._lineNumber, serialize$this$0._columnNumber ]) ];
};


DebuggerStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	return true;
};


DebuggerStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function GotoStatement(label) {
	this._stash = {};
	this.label = label;
};

$__jsx_extend([GotoStatement], Statement);
GotoStatement.prototype.getLabel$ = function () {
	return this.label;
};


function GotoStatement$getLabel$LGotoStatement$($this) {
	return $this.label;
};

GotoStatement.getLabel$LGotoStatement$ = GotoStatement$getLabel$LGotoStatement$;

GotoStatement.prototype.getToken$ = function () {
	return null;
};


GotoStatement.prototype.clone$ = function () {
	return new GotoStatement(this.label);
};


GotoStatement.prototype.serialize$ = function () {
	return null;
};


GotoStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	return true;
};


GotoStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function LabelStatement(name) {
	this._stash = {};
	this._name = name;
};

$__jsx_extend([LabelStatement], Statement);
LabelStatement.prototype.getName$ = function () {
	return this._name;
};


function LabelStatement$getName$LLabelStatement$($this) {
	return $this._name;
};

LabelStatement.getName$LLabelStatement$ = LabelStatement$getName$LLabelStatement$;

LabelStatement.prototype.getToken$ = function () {
	return null;
};


LabelStatement.prototype.clone$ = function () {
	return new LabelStatement(this._name);
};


LabelStatement.prototype.serialize$ = function () {
	return null;
};


LabelStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	return true;
};


LabelStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function Meta() {
};

$__jsx_extend([Meta], Object);
var SourceMapGenerator$0 = require('source-map').SourceMapGenerator;
var SourceMapConsumer$0 = require('source-map').SourceMapConsumer;
function SourceMapper(rootDir, outputFile, runenv) {
	var _header$0;
	this._header = "";
	this._sourceFiles = {};
	this._outputLength = 0;
	this._outputLineNumber = 1;
	this._rootDir = rootDir;
	this._outputFile = (outputFile != null ? Util$_resolvedPathParts$S(outputFile).join("/") : null);
	this._impl = new SourceMapGenerator$0(({ file: outputFile != null ? Util$basename$S(this._outputFile) : null }));
	switch (runenv) {
	case "node":
		this._header = "require('source-map-support').install();\n\n";
		break;
	case "web":
		this._header = "";
		break;
	default:
		this._header = "";
	}
	this._outputLength += (_header$0 = this._header).length;
	this._outputLineNumber += _header$0.split('\n').length - 1;
};

$__jsx_extend([SourceMapper], Object);
SourceMapper.prototype.getSourceMapHeader$ = function () {
	return this._header;
};


function SourceMapper$getSourceMapHeader$LSourceMapper$($this) {
	return $this._header;
};

SourceMapper.getSourceMapHeader$LSourceMapper$ = SourceMapper$getSourceMapHeader$LSourceMapper$;

SourceMapper.prototype.makeGeneratedPos$S = function (output) {
	var pos;
	var line;
	var lastNewLinePos;
	var column;
	pos = this._outputLength;
	line = this._outputLineNumber;
	while ((pos = output.indexOf("\n", pos)) !== -1) {
		++ pos;
		++ line;
	}
	this._outputLength = output.length;
	this._outputLineNumber = line;
	lastNewLinePos = output.lastIndexOf("\n") + 1;
	column = output.length - lastNewLinePos;
	return ({ line: line, column: column });
};


function SourceMapper$makeGeneratedPos$LSourceMapper$S($this, output) {
	var pos;
	var line;
	var lastNewLinePos;
	var column;
	pos = $this._outputLength;
	line = $this._outputLineNumber;
	while ((pos = output.indexOf("\n", pos)) !== -1) {
		++ pos;
		++ line;
	}
	$this._outputLength = output.length;
	$this._outputLineNumber = line;
	lastNewLinePos = output.lastIndexOf("\n") + 1;
	column = output.length - lastNewLinePos;
	return ({ line: line, column: column });
};

SourceMapper.makeGeneratedPos$LSourceMapper$S = SourceMapper$makeGeneratedPos$LSourceMapper$S;

SourceMapper.prototype.add$SNNUSUS = function (output, tokenLineNumber, tokenColumnNumber, tokenValue, tokenFilename) {
	var genPos;
	var origPos;
	var sourceFile;
	genPos = SourceMapper$makeGeneratedPos$LSourceMapper$S(this, output);
	if (tokenLineNumber !== tokenLineNumber || tokenFilename == null) {
		origPos = null;
		sourceFile = null;
		tokenValue = null;
	} else {
		origPos = ({ line: tokenLineNumber, column: tokenColumnNumber });
		sourceFile = tokenFilename;
		this._sourceFiles[tokenFilename] = true;
		if (tokenFilename.indexOf(this._rootDir + "/") === 0) {
			sourceFile = sourceFile.substring(this._rootDir.length + 1);
		}
	}
	this._impl.addMapping(({ generated: genPos, original: origPos, source: sourceFile, name: tokenValue }));
};


function SourceMapper$add$LSourceMapper$SNNUSUS($this, output, tokenLineNumber, tokenColumnNumber, tokenValue, tokenFilename) {
	var genPos;
	var origPos;
	var sourceFile;
	genPos = SourceMapper$makeGeneratedPos$LSourceMapper$S($this, output);
	if (tokenLineNumber !== tokenLineNumber || tokenFilename == null) {
		origPos = null;
		sourceFile = null;
		tokenValue = null;
	} else {
		origPos = ({ line: tokenLineNumber, column: tokenColumnNumber });
		sourceFile = tokenFilename;
		$this._sourceFiles[tokenFilename] = true;
		if (tokenFilename.indexOf($this._rootDir + "/") === 0) {
			sourceFile = sourceFile.substring($this._rootDir.length + 1);
		}
	}
	$this._impl.addMapping(({ generated: genPos, original: origPos, source: sourceFile, name: tokenValue }));
};

SourceMapper.add$LSourceMapper$SNNUSUS = SourceMapper$add$LSourceMapper$SNNUSUS;

SourceMapper.prototype.setSourceContent$SS = function (sourceFile, sourceContent) {
	this._impl.setSourceContent(sourceFile, sourceContent);
};


function SourceMapper$setSourceContent$LSourceMapper$SS($this, sourceFile, sourceContent) {
	$this._impl.setSourceContent(sourceFile, sourceContent);
};

SourceMapper.setSourceContent$LSourceMapper$SS = SourceMapper$setSourceContent$LSourceMapper$SS;

SourceMapper.prototype.getSourceMappingFile$ = function () {
	return this._outputFile + ".mapping";
};


function SourceMapper$getSourceMappingFile$LSourceMapper$($this) {
	return $this._outputFile + ".mapping";
};

SourceMapper.getSourceMappingFile$LSourceMapper$ = SourceMapper$getSourceMappingFile$LSourceMapper$;

SourceMapper.prototype.getSourceFiles$ = function () {
	return Object.keys(this._sourceFiles);
};


function SourceMapper$getSourceFiles$LSourceMapper$($this) {
	return Object.keys($this._sourceFiles);
};

SourceMapper.getSourceFiles$LSourceMapper$ = SourceMapper$getSourceFiles$LSourceMapper$;

SourceMapper.prototype.generate$ = function () {
	return this._impl.toString();
};


function SourceMapper$generate$LSourceMapper$($this) {
	return $this._impl.toString();
};

SourceMapper.generate$LSourceMapper$ = SourceMapper$generate$LSourceMapper$;

SourceMapper.prototype.getSourceMapFooter$ = function () {
	var sourceMappingURL;
	var path$0;
	var parts$0;
	if (this._outputFile != null) {
		path$0 = this._outputFile + ".mapping";
		parts$0 = Util$_resolvedPathParts$S(path$0);
		sourceMappingURL = parts$0.pop();
	} else {
		sourceMappingURL = "data:application/json;base64," + new Buffer(this._impl.toString(), "utf8").toString("base64");
	}
	return "\n//# sourceMappingURL=" + sourceMappingURL + "\n";
};


function SourceMapper$getSourceMapFooter$LSourceMapper$($this) {
	var sourceMappingURL;
	var path$0;
	var parts$0;
	if ($this._outputFile != null) {
		path$0 = $this._outputFile + ".mapping";
		parts$0 = Util$_resolvedPathParts$S(path$0);
		sourceMappingURL = parts$0.pop();
	} else {
		sourceMappingURL = "data:application/json;base64," + new Buffer($this._impl.toString(), "utf8").toString("base64");
	}
	return "\n//# sourceMappingURL=" + sourceMappingURL + "\n";
};

SourceMapper.getSourceMapFooter$LSourceMapper$ = SourceMapper$getSourceMapFooter$LSourceMapper$;

function DocCommentNode() {
	this._description = "";
};

$__jsx_extend([DocCommentNode], Object);
DocCommentNode.prototype.getDescription$ = function () {
	return this._description.replace(/^[\r\n]+/, "").replace(/[\r\n\t ]+$/, "");
};


DocCommentNode.prototype.appendDescription$S = function (s) {
	this._description += s;
};


function DocCommentNode$appendDescription$LDocCommentNode$S($this, s) {
	$this._description += s;
};

DocCommentNode.appendDescription$LDocCommentNode$S = DocCommentNode$appendDescription$LDocCommentNode$S;

function DocCommentParameter(token) {
	this._description = "";
	this._token = token;
};

$__jsx_extend([DocCommentParameter], DocCommentNode);
DocCommentParameter.prototype.getToken$ = function () {
	return this._token;
};


function DocCommentParameter$getToken$LDocCommentParameter$($this) {
	return $this._token;
};

DocCommentParameter.getToken$LDocCommentParameter$ = DocCommentParameter$getToken$LDocCommentParameter$;

DocCommentParameter.prototype.getParamName$ = function () {
	return this._token._value;
};


function DocCommentParameter$getParamName$LDocCommentParameter$($this) {
	return $this._token._value;
};

DocCommentParameter.getParamName$LDocCommentParameter$ = DocCommentParameter$getParamName$LDocCommentParameter$;

DocCommentParameter.prototype.getDescription$ = function () {
	var d;
	d = DocCommentNode.prototype.getDescription$.call(this);
	return d.trim();
};


function DocCommentTag(tagName) {
	this._description = "";
	this._tagName = tagName;
};

$__jsx_extend([DocCommentTag], DocCommentNode);
DocCommentTag.prototype.getTagName$ = function () {
	return this._tagName;
};


function DocCommentTag$getTagName$LDocCommentTag$($this) {
	return $this._tagName;
};

DocCommentTag.getTagName$LDocCommentTag$ = DocCommentTag$getTagName$LDocCommentTag$;

function DocComment() {
	this._description = "";
	this._params = [];
	this._tags = [];
};

$__jsx_extend([DocComment], DocCommentNode);
DocComment.prototype.getParams$ = function () {
	return this._params;
};


function DocComment$getParams$LDocComment$($this) {
	return $this._params;
};

DocComment.getParams$LDocComment$ = DocComment$getParams$LDocComment$;

DocComment.prototype.getTags$ = function () {
	return this._tags;
};


function DocComment$getTags$LDocComment$($this) {
	return $this._tags;
};

DocComment.getTags$LDocComment$ = DocComment$getTags$LDocComment$;

DocComment.prototype.getTagByName$S = function (tagName) {
	var i;
	for (i = 0; i < this._tags.length; ++ i) {
		if (this._tags[i]._tagName === tagName) {
			return this._tags[i];
		}
	}
	return null;
};


function DocComment$getTagByName$LDocComment$S($this, tagName) {
	var i;
	for (i = 0; i < $this._tags.length; ++ i) {
		if ($this._tags[i]._tagName === tagName) {
			return $this._tags[i];
		}
	}
	return null;
};

DocComment.getTagByName$LDocComment$S = DocComment$getTagByName$LDocComment$S;

DocComment.prototype.getTagsByName$S = function (tagName) {
	var tags;
	var i;
	tags = [];
	for (i = 0; i < this._tags.length; ++ i) {
		if (this._tags[i]._tagName === tagName) {
			tags.push(this._tags[i]);
		}
	}
	return tags;
};


function DocComment$getTagsByName$LDocComment$S($this, tagName) {
	var tags;
	var i;
	tags = [];
	for (i = 0; i < $this._tags.length; ++ i) {
		if ($this._tags[i]._tagName === tagName) {
			tags.push($this._tags[i]);
		}
	}
	return tags;
};

DocComment.getTagsByName$LDocComment$S = DocComment$getTagsByName$LDocComment$S;

function DocumentGenerator(compiler, templatePath, outputPath) {
	this._classDefToHTMLCache = new TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E();
	this._compiler = compiler;
	this._templatePath = templatePath;
	this._outputPath = outputPath;
	this._resourceFiles = [];
	this._pathFilter = null;
};

$__jsx_extend([DocumentGenerator], Object);
DocumentGenerator.prototype.setResourceFiles$AS = function (files) {
	this._resourceFiles = files;
	return this;
};


function DocumentGenerator$setResourceFiles$LDocumentGenerator$AS($this, files) {
	$this._resourceFiles = files;
	return $this;
};

DocumentGenerator.setResourceFiles$LDocumentGenerator$AS = DocumentGenerator$setResourceFiles$LDocumentGenerator$AS;

DocumentGenerator.prototype.setPathFilter$F$SB$ = function (pathFilter) {
	this._pathFilter = pathFilter;
	return this;
};


function DocumentGenerator$setPathFilter$LDocumentGenerator$F$SB$($this, pathFilter) {
	$this._pathFilter = pathFilter;
	return $this;
};

DocumentGenerator.setPathFilter$LDocumentGenerator$F$SB$ = DocumentGenerator$setPathFilter$LDocumentGenerator$F$SB$;

DocumentGenerator.prototype.buildDoc$ = function () {
	var $this = this;
	var platform;
	var this$0;
	var i$0;
	var this$1;
	var i$1;
	var file$0;
	platform = this._compiler._platform;
	this$0 = this._resourceFiles;
	for (i$0 in this$0) {
		file$0 = this$0[i$0];
		platform.save$USS(this._outputPath + "/" + file$0, platform.load$S(this._templatePath + "/" + file$0));
	}
	this$1 = this._compiler._parsers;
	for (i$1 in this$1) {
		(function (parser) {
			var encodedFilename;
			var outputFile;
			var html;
			encodedFilename = Platform$encodeFilename$LPlatform$S(platform, parser._filename);
			if ($this._pathFilter(encodedFilename)) {
				outputFile = $this._outputPath + "/" + parser._filename + ".html";
				html = DocumentGenerator$_buildDocOfFile$LDocumentGenerator$LParser$($this, parser);
				platform.save$USS(outputFile, html);
			}
		})(this$1[i$1]);
	}
};


function DocumentGenerator$buildDoc$LDocumentGenerator$($this) {
	var platform;
	var this$0;
	var i$0;
	var this$1;
	var i$1;
	var file$0;
	platform = $this._compiler._platform;
	this$0 = $this._resourceFiles;
	for (i$0 in this$0) {
		file$0 = this$0[i$0];
		platform.save$USS($this._outputPath + "/" + file$0, platform.load$S($this._templatePath + "/" + file$0));
	}
	this$1 = $this._compiler._parsers;
	for (i$1 in this$1) {
		(function (parser) {
			var encodedFilename;
			var outputFile;
			var html;
			encodedFilename = Platform$encodeFilename$LPlatform$S(platform, parser._filename);
			if ($this._pathFilter(encodedFilename)) {
				outputFile = $this._outputPath + "/" + parser._filename + ".html";
				html = DocumentGenerator$_buildDocOfFile$LDocumentGenerator$LParser$($this, parser);
				platform.save$USS(outputFile, html);
			}
		})(this$1[i$1]);
	}
};

DocumentGenerator.buildDoc$LDocumentGenerator$ = DocumentGenerator$buildDoc$LDocumentGenerator$;

DocumentGenerator.prototype._buildDocOfFile$LParser$ = function (parser) {
	var $this = this;
	var htmlFile;
	htmlFile = this._templatePath + "/template.html";
	return this._compiler._platform.load$S(htmlFile).replace(/<%JSX:(.*?)%>/g, (function (matched) {
		var key;
		key = matched.substring(6, matched.length - 2);
		switch (key) {
		case "BASE_HREF":
			return parser._filename.replace(/\/[^\/]+$/, "").replace(/[^\/]+/g, "..");
		case "TITLE":
			return DocumentGenerator$_escape$LDocumentGenerator$S($this, parser._filename);
		case "BODY":
			return DocumentGenerator$_buildBodyOfFile$LDocumentGenerator$LParser$($this, parser);
		case "FOOTER":
			return DocumentGenerator$_buildFooterOfFile$LDocumentGenerator$LParser$($this, parser);
		default:
			throw new Error("unknown template key:" + key + " in file: " + htmlFile);
		}
	}));
};


function DocumentGenerator$_buildDocOfFile$LDocumentGenerator$LParser$($this, parser) {
	var htmlFile;
	htmlFile = $this._templatePath + "/template.html";
	return $this._compiler._platform.load$S(htmlFile).replace(/<%JSX:(.*?)%>/g, (function (matched) {
		var key;
		key = matched.substring(6, matched.length - 2);
		switch (key) {
		case "BASE_HREF":
			return parser._filename.replace(/\/[^\/]+$/, "").replace(/[^\/]+/g, "..");
		case "TITLE":
			return DocumentGenerator$_escape$LDocumentGenerator$S($this, parser._filename);
		case "BODY":
			return DocumentGenerator$_buildBodyOfFile$LDocumentGenerator$LParser$($this, parser);
		case "FOOTER":
			return DocumentGenerator$_buildFooterOfFile$LDocumentGenerator$LParser$($this, parser);
		default:
			throw new Error("unknown template key:" + key + " in file: " + htmlFile);
		}
	}));
};

DocumentGenerator._buildDocOfFile$LDocumentGenerator$LParser$ = DocumentGenerator$_buildDocOfFile$LDocumentGenerator$LParser$;

DocumentGenerator.prototype._buildBodyOfFile$LParser$ = function (parser) {
	var _;
	_ = "";
	_ += "<div class=\"jsxdoc\">\n";
	_ += "<div class=\"file\">\n";
	_ += "<h1>";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, parser._filename).replace(/\n$/, "");
	_ += "</h1>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$(this, parser._fileLevelDocComment).replace(/\n$/, "");
	_ += "\n";
	_ += "</div><!--/file-->\n";
	_ += DocumentGenerator$_buildListOfClasses$LDocumentGenerator$LParser$(this, parser).replace(/\n$/, "");
	_ += "\n";
	_ += "</div><!--/jsxdoc-->\n";
	return _;
};


function DocumentGenerator$_buildBodyOfFile$LDocumentGenerator$LParser$($this, parser) {
	var _;
	_ = "";
	_ += "<div class=\"jsxdoc\">\n";
	_ += "<div class=\"file\">\n";
	_ += "<h1>";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, parser._filename).replace(/\n$/, "");
	_ += "</h1>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, parser._fileLevelDocComment).replace(/\n$/, "");
	_ += "\n";
	_ += "</div><!--/file-->\n";
	_ += DocumentGenerator$_buildListOfClasses$LDocumentGenerator$LParser$($this, parser).replace(/\n$/, "");
	_ += "\n";
	_ += "</div><!--/jsxdoc-->\n";
	return _;
};

DocumentGenerator._buildBodyOfFile$LDocumentGenerator$LParser$ = DocumentGenerator$_buildBodyOfFile$LDocumentGenerator$LParser$;

DocumentGenerator.prototype._buildFooterOfFile$LParser$ = function (parser) {
	var _;
	var docComment;
	var version;
	var author;
	var d;
	var endWithDot;
	_ = "";
	docComment = parser._fileLevelDocComment;
	if (docComment) {
		version = DocComment$getTagByName$LDocComment$S(docComment, "version");
		if (version) {
			_ += "<p>This is <strong>";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, parser._filename).replace(/\n$/, "");
			_ += " version ";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, version.getDescription$()).replace(/\n$/, "");
			_ += "</strong>.</p>\n";
		}
		author = DocComment$getTagByName$LDocComment$S(docComment, "author");
		if (author) {
			d = author.getDescription$();
			endWithDot = d.charAt(d.length - 1) === ".";
			_ += "<p>Copyright &copy; ";
			_ += (DocumentGenerator$_escape$LDocumentGenerator$S(this, d) + (endWithDot ? "" : ".")).replace(/\n$/, "");
			_ += "</p>\n";
		}
	}
	_ += "<p class=\"jsxdoc-notice\">This document was automatically generated by <a href=\"http://jsx.github.io/\">JSX</a> ";
	_ += "0.9.56".replace(/\n$/, "");
	_ += "<br />\n";
	_ += "at ";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, new Date().toISOString()).replace(/\n$/, "");
	_ += ".</p>\n";
	return _;
};


function DocumentGenerator$_buildFooterOfFile$LDocumentGenerator$LParser$($this, parser) {
	var _;
	var docComment;
	var version;
	var author;
	var d;
	var endWithDot;
	_ = "";
	docComment = parser._fileLevelDocComment;
	if (docComment) {
		version = DocComment$getTagByName$LDocComment$S(docComment, "version");
		if (version) {
			_ += "<p>This is <strong>";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, parser._filename).replace(/\n$/, "");
			_ += " version ";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, version.getDescription$()).replace(/\n$/, "");
			_ += "</strong>.</p>\n";
		}
		author = DocComment$getTagByName$LDocComment$S(docComment, "author");
		if (author) {
			d = author.getDescription$();
			endWithDot = d.charAt(d.length - 1) === ".";
			_ += "<p>Copyright &copy; ";
			_ += (DocumentGenerator$_escape$LDocumentGenerator$S($this, d) + (endWithDot ? "" : ".")).replace(/\n$/, "");
			_ += "</p>\n";
		}
	}
	_ += "<p class=\"jsxdoc-notice\">This document was automatically generated by <a href=\"http://jsx.github.io/\">JSX</a> ";
	_ += "0.9.56".replace(/\n$/, "");
	_ += "<br />\n";
	_ += "at ";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, new Date().toISOString()).replace(/\n$/, "");
	_ += ".</p>\n";
	return _;
};

DocumentGenerator._buildFooterOfFile$LDocumentGenerator$LParser$ = DocumentGenerator$_buildFooterOfFile$LDocumentGenerator$LParser$;

DocumentGenerator.prototype._buildListOfClasses$LParser$ = function (parser) {
	var $this = this;
	var _;
	var this$0;
	var i$0;
	var this$1;
	var i$1;
	_ = "";
	_ += "<div class=\"classes\">\n";
	this$0 = parser._templateClassDefs;
	for (i$0 in this$0) {
		(function (classDef) {
			var _docComment$0;
			if (! (classDef._className.charAt(0) === "_" || (_docComment$0 = classDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private'))) {
				_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
				_ += "\n";
			}
		})(this$0[i$0]);
	}
	this$1 = parser._classDefs;
	for (i$1 in this$1) {
		(function (classDef) {
			var _docComment$0;
			if (! (classDef instanceof InstantiatedClassDefinition) && ! (classDef.className$().charAt(0) === "_" || (_docComment$0 = classDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private'))) {
				_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
				_ += "\n";
			}
		})(this$1[i$1]);
	}
	_ += "</div>\n";
	return _;
};


function DocumentGenerator$_buildListOfClasses$LDocumentGenerator$LParser$($this, parser) {
	var _;
	var this$0;
	var i$0;
	var this$1;
	var i$1;
	_ = "";
	_ += "<div class=\"classes\">\n";
	this$0 = parser._templateClassDefs;
	for (i$0 in this$0) {
		(function (classDef) {
			var _docComment$0;
			if (! (classDef._className.charAt(0) === "_" || (_docComment$0 = classDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private'))) {
				_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
				_ += "\n";
			}
		})(this$0[i$0]);
	}
	this$1 = parser._classDefs;
	for (i$1 in this$1) {
		(function (classDef) {
			var _docComment$0;
			if (! (classDef instanceof InstantiatedClassDefinition) && ! (classDef.className$().charAt(0) === "_" || (_docComment$0 = classDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private'))) {
				_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
				_ += "\n";
			}
		})(this$1[i$1]);
	}
	_ += "</div>\n";
	return _;
};

DocumentGenerator._buildListOfClasses$LDocumentGenerator$LParser$ = DocumentGenerator$_buildListOfClasses$LDocumentGenerator$LParser$;

DocumentGenerator.prototype._buildDocOfClass$LParser$LClassDefinition$ = function (parser, classDef) {
	var $this = this;
	var _;
	var typeName;
	var typeArgs;
	var _name$name$0;
	var this$0;
	var i$0;
	var this$1;
	var i$1;
	_ = "";
	typeName = "class";
	if ((classDef.flags$() & 64) !== 0) {
		typeName = "interface";
	} else {
		if ((classDef.flags$() & 128) !== 0) {
			typeName = "mixin";
		}
	}
	typeArgs = (classDef instanceof TemplateClassDefinition ? classDef._typeArgs : []);
	_ += "<div class=\"class\" id=\"class-";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "\">\n";
	_ += "<h2>";
	_ += (DocumentGenerator$_flagsToHTML$LDocumentGenerator$N(this, classDef.flags$()) + " " + DocumentGenerator$_escape$LDocumentGenerator$S(this, typeName) + " " + (_name$name$0 = ClassDefinition$classFullName$LClassDefinition$(classDef), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S(this, _name$name$0) + "</strong>") + DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$(this, typeArgs) + DocumentGenerator$_inheritance$LDocumentGenerator$LParser$LClassDefinition$(this, parser, classDef)).replace(/\n$/, "");
	_ += "</h2>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$(this, classDef._docComment).replace(/\n$/, "");
	_ += "\n";
	this$0 = classDef._templateInners;
	for (i$0 in this$0) {
		(function (classDef) {
			var _docComment$0;
			if (! (classDef._className.charAt(0) === "_" || (_docComment$0 = classDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private'))) {
				_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
				_ += "\n";
			}
		})(this$0[i$0]);
	}
	this$1 = classDef._inners;
	for (i$1 in this$1) {
		(function (classDef) {
			var _docComment$0;
			if (! (classDef instanceof InstantiatedClassDefinition) && ! (classDef.className$().charAt(0) === "_" || (_docComment$0 = classDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private'))) {
				_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
				_ += "\n";
			}
		})(this$1[i$1]);
	}
	if (DocumentGenerator$_hasPublicProperties$LDocumentGenerator$LClassDefinition$(this, classDef)) {
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			var _docComment$0;
			if (! (varDef._nameToken._value.charAt(0) === "_" || (_docComment$0 = varDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (varDef._flags & 32768) !== 0)) {
				_ += "<div class=\"member property\">\n";
				_ += "<h3>\n";
				_ += DocumentGenerator$_flagsToHTML$LDocumentGenerator$N($this, varDef._flags).replace(/\n$/, "");
				_ += " var ";
				_ += ("<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, varDef._nameToken._value) + "</strong>").replace(/\n$/, "");
				_ += " : ";
				_ += DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, varDef.getType$()).replace(/\n$/, "");
				_ += "\n";
				_ += "</h3>\n";
				_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, varDef._docComment).replace(/\n$/, "");
				_ += "\n";
				_ += "</div>\n";
			}
			return true;
		}));
	}
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
		var _flags$0;
		var _value$0;
		var _docComment$0;
		if (! (funcDef instanceof InstantiatedMemberFunctionDefinition) && ((_value$0 = funcDef._nameToken._value) === "constructor" && ((_flags$0 = funcDef._flags) & 8) === 0) && (_flags$0 & 4096) === 0 && ! (_value$0.charAt(0) === "_" || (_docComment$0 = funcDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (funcDef._flags & 32768) !== 0)) {
			_ += DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$($this, parser, funcDef).replace(/\n$/, "");
			_ += "\n";
		}
		return true;
	}));
	if (DocumentGenerator$_hasPublicFunctions$LDocumentGenerator$LClassDefinition$(this, classDef)) {
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
			var _value$0;
			var _docComment$0;
			if (! (funcDef instanceof InstantiatedMemberFunctionDefinition) && ! ((_value$0 = funcDef._nameToken._value) === "constructor" && (funcDef._flags & 8) === 0) && ! (_value$0.charAt(0) === "_" || (_docComment$0 = funcDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (funcDef._flags & 32768) !== 0)) {
				_ += DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$($this, parser, funcDef).replace(/\n$/, "");
				_ += "\n";
			}
			return true;
		}));
	}
	_ += "</div>\n";
	return _;
};


function DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef) {
	var _;
	var typeName;
	var typeArgs;
	var _name$name$0;
	var this$0;
	var i$0;
	var this$1;
	var i$1;
	_ = "";
	typeName = "class";
	if ((classDef.flags$() & 64) !== 0) {
		typeName = "interface";
	} else {
		if ((classDef.flags$() & 128) !== 0) {
			typeName = "mixin";
		}
	}
	typeArgs = (classDef instanceof TemplateClassDefinition ? classDef._typeArgs : []);
	_ += "<div class=\"class\" id=\"class-";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "\">\n";
	_ += "<h2>";
	_ += (DocumentGenerator$_flagsToHTML$LDocumentGenerator$N($this, classDef.flags$()) + " " + DocumentGenerator$_escape$LDocumentGenerator$S($this, typeName) + " " + (_name$name$0 = ClassDefinition$classFullName$LClassDefinition$(classDef), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, _name$name$0) + "</strong>") + DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$($this, typeArgs) + DocumentGenerator$_inheritance$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef)).replace(/\n$/, "");
	_ += "</h2>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, classDef._docComment).replace(/\n$/, "");
	_ += "\n";
	this$0 = classDef._templateInners;
	for (i$0 in this$0) {
		(function (classDef) {
			var _docComment$0;
			if (! (classDef._className.charAt(0) === "_" || (_docComment$0 = classDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private'))) {
				_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
				_ += "\n";
			}
		})(this$0[i$0]);
	}
	this$1 = classDef._inners;
	for (i$1 in this$1) {
		(function (classDef) {
			var _docComment$0;
			if (! (classDef instanceof InstantiatedClassDefinition) && ! (classDef.className$().charAt(0) === "_" || (_docComment$0 = classDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private'))) {
				_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
				_ += "\n";
			}
		})(this$1[i$1]);
	}
	if (DocumentGenerator$_hasPublicProperties$LDocumentGenerator$LClassDefinition$($this, classDef)) {
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			var _docComment$0;
			if (! (varDef._nameToken._value.charAt(0) === "_" || (_docComment$0 = varDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (varDef._flags & 32768) !== 0)) {
				_ += "<div class=\"member property\">\n";
				_ += "<h3>\n";
				_ += DocumentGenerator$_flagsToHTML$LDocumentGenerator$N($this, varDef._flags).replace(/\n$/, "");
				_ += " var ";
				_ += ("<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, varDef._nameToken._value) + "</strong>").replace(/\n$/, "");
				_ += " : ";
				_ += DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, varDef.getType$()).replace(/\n$/, "");
				_ += "\n";
				_ += "</h3>\n";
				_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, varDef._docComment).replace(/\n$/, "");
				_ += "\n";
				_ += "</div>\n";
			}
			return true;
		}));
	}
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
		var _flags$0;
		var _value$0;
		var _docComment$0;
		if (! (funcDef instanceof InstantiatedMemberFunctionDefinition) && ((_value$0 = funcDef._nameToken._value) === "constructor" && ((_flags$0 = funcDef._flags) & 8) === 0) && (_flags$0 & 4096) === 0 && ! (_value$0.charAt(0) === "_" || (_docComment$0 = funcDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (funcDef._flags & 32768) !== 0)) {
			_ += DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$($this, parser, funcDef).replace(/\n$/, "");
			_ += "\n";
		}
		return true;
	}));
	if (DocumentGenerator$_hasPublicFunctions$LDocumentGenerator$LClassDefinition$($this, classDef)) {
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
			var _value$0;
			var _docComment$0;
			if (! (funcDef instanceof InstantiatedMemberFunctionDefinition) && ! ((_value$0 = funcDef._nameToken._value) === "constructor" && (funcDef._flags & 8) === 0) && ! (_value$0.charAt(0) === "_" || (_docComment$0 = funcDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (funcDef._flags & 32768) !== 0)) {
				_ += DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$($this, parser, funcDef).replace(/\n$/, "");
				_ += "\n";
			}
			return true;
		}));
	}
	_ += "</div>\n";
	return _;
};

DocumentGenerator._buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$ = DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$;

DocumentGenerator.prototype._inheritance$LParser$LClassDefinition$ = function (parser, classDef) {
	var $this = this;
	var extendClassDef;
	var _;
	var implementTypes;
	var this$0;
	if (classDef._extendType == null) {
		return "";
	}
	this$0 = classDef._extendType;
	extendClassDef = this$0._classDef;
	if (extendClassDef == null || ClassDefinition$classFullName$LClassDefinition$(extendClassDef) === "Object") {
		return "";
	}
	_ = " extends " + DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$(this, parser, extendClassDef);
	implementTypes = classDef._implementTypes;
	if (implementTypes.length > 0) {
		_ += " implements " + implementTypes.map((function (type) {
			return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, type._classDef);
		})).join(", ");
	}
	return _;
};


function DocumentGenerator$_inheritance$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef) {
	var extendClassDef;
	var _;
	var implementTypes;
	var this$0;
	if (classDef._extendType == null) {
		return "";
	}
	this$0 = classDef._extendType;
	extendClassDef = this$0._classDef;
	if (extendClassDef == null || ClassDefinition$classFullName$LClassDefinition$(extendClassDef) === "Object") {
		return "";
	}
	_ = " extends " + DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, extendClassDef);
	implementTypes = classDef._implementTypes;
	if (implementTypes.length > 0) {
		_ += " implements " + implementTypes.map((function (type) {
			return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, type._classDef);
		})).join(", ");
	}
	return _;
};

DocumentGenerator._inheritance$LDocumentGenerator$LParser$LClassDefinition$ = DocumentGenerator$_inheritance$LDocumentGenerator$LParser$LClassDefinition$;

DocumentGenerator.prototype._buildDocOfFunction$LParser$LMemberFunctionDefinition$ = function (parser, funcDef) {
	var $this = this;
	var _;
	var ignoreFlags;
	var funcName;
	var args;
	var argsHTML;
	var _name$name$0;
	var i$0;
	var arg$0;
	var argName$0;
	var this$0$0;
	var _argumentDescriptionToHTML$docComment$0$0;
	_ = "";
	ignoreFlags = funcDef._classDef.flags$() & 20 | 1024;
	funcName = (funcDef._nameToken._value === "constructor" && (funcDef._flags & 8) === 0 ? "new " + (_name$name$0 = ClassDefinition$classFullName$LClassDefinition$(funcDef._classDef), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S(this, _name$name$0) + "</strong>") : DocumentGenerator$_flagsToHTML$LDocumentGenerator$N(this, funcDef._flags & ~ ignoreFlags) + " function " + ("<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S(this, funcDef._nameToken._value) + "</strong>"));
	args = funcDef._args;
	argsHTML = args.map((function (arg) {
		return DocumentGenerator$_escape$LDocumentGenerator$S($this, arg._name._value) + " : " + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, arg._type);
	})).join(", ");
	_ += "<div class=\"member function\">\n";
	_ += "<h3>\n";
	_ += (funcName + DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$(this, funcDef instanceof TemplateFunctionDefinition ? funcDef._typeArgs : [])).replace(/\n$/, "");
	_ += "(";
	_ += argsHTML.replace(/\n$/, "");
	_ += ")\n";
	if (! (funcDef._nameToken._value === "constructor" && (funcDef._flags & 8) === 0)) {
		_ += " : ";
		_ += DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$(this, parser, funcDef._returnType).replace(/\n$/, "");
		_ += "\n";
	}
	_ += "</h3>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$(this, funcDef._docComment).replace(/\n$/, "");
	_ += "\n";
	if (DocumentGenerator$_argsHasDocComment$LDocumentGenerator$LMemberFunctionDefinition$(this, funcDef)) {
		_ += "<table class=\"arguments\">\n";
		for (i$0 in args) {
			arg$0 = args[i$0];
			this$0$0 = arg$0._name;
			argName$0 = this$0$0._value;
			_ += "<tr>\n";
			_ += "<td class=\"param-name\">";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, argName$0).replace(/\n$/, "");
			_ += "</td>\n";
			_ += "<td class=\"param-desc\">";
			_ += (_argumentDescriptionToHTML$docComment$0$0 = funcDef._docComment, _argumentDescriptionToHTML$docComment$0$0 != null ? DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S(this, _argumentDescriptionToHTML$docComment$0$0, argName$0) : "").replace(/\n$/, "");
			_ += "</td>\n";
			_ += "</tr>\n";
		}
		_ += "</table>\n";
	}
	_ += "</div>\n";
	return _;
};


function DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$($this, parser, funcDef) {
	var _;
	var ignoreFlags;
	var funcName;
	var args;
	var argsHTML;
	var _name$name$0;
	var i$0;
	var arg$0;
	var argName$0;
	var this$0$0;
	var _argumentDescriptionToHTML$docComment$0$0;
	_ = "";
	ignoreFlags = funcDef._classDef.flags$() & 20 | 1024;
	funcName = (funcDef._nameToken._value === "constructor" && (funcDef._flags & 8) === 0 ? "new " + (_name$name$0 = ClassDefinition$classFullName$LClassDefinition$(funcDef._classDef), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, _name$name$0) + "</strong>") : DocumentGenerator$_flagsToHTML$LDocumentGenerator$N($this, funcDef._flags & ~ ignoreFlags) + " function " + ("<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, funcDef._nameToken._value) + "</strong>"));
	args = funcDef._args;
	argsHTML = args.map((function (arg) {
		return DocumentGenerator$_escape$LDocumentGenerator$S($this, arg._name._value) + " : " + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, arg._type);
	})).join(", ");
	_ += "<div class=\"member function\">\n";
	_ += "<h3>\n";
	_ += (funcName + DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$($this, funcDef instanceof TemplateFunctionDefinition ? funcDef._typeArgs : [])).replace(/\n$/, "");
	_ += "(";
	_ += argsHTML.replace(/\n$/, "");
	_ += ")\n";
	if (! (funcDef._nameToken._value === "constructor" && (funcDef._flags & 8) === 0)) {
		_ += " : ";
		_ += DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, funcDef._returnType).replace(/\n$/, "");
		_ += "\n";
	}
	_ += "</h3>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, funcDef._docComment).replace(/\n$/, "");
	_ += "\n";
	if (DocumentGenerator$_argsHasDocComment$LDocumentGenerator$LMemberFunctionDefinition$($this, funcDef)) {
		_ += "<table class=\"arguments\">\n";
		for (i$0 in args) {
			arg$0 = args[i$0];
			this$0$0 = arg$0._name;
			argName$0 = this$0$0._value;
			_ += "<tr>\n";
			_ += "<td class=\"param-name\">";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, argName$0).replace(/\n$/, "");
			_ += "</td>\n";
			_ += "<td class=\"param-desc\">";
			_ += (_argumentDescriptionToHTML$docComment$0$0 = funcDef._docComment, _argumentDescriptionToHTML$docComment$0$0 != null ? DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S($this, _argumentDescriptionToHTML$docComment$0$0, argName$0) : "").replace(/\n$/, "");
			_ += "</td>\n";
			_ += "</tr>\n";
		}
		_ += "</table>\n";
	}
	_ += "</div>\n";
	return _;
};

DocumentGenerator._buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$ = DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$;

DocumentGenerator.prototype._descriptionToHTML$LDocComment$ = function (docComment) {
	var $this = this;
	var _;
	var seeTags;
	var i$0;
	var tag$0;
	_ = "";
	if (docComment != null) {
		if (docComment.getDescription$() !== "") {
			_ += "<div class=\"description\">\n";
			_ += docComment.getDescription$().replace(/\t/g, "  ").replace(/\n$/, "");
			_ += "\n";
			_ += "</div>\n";
		}
		seeTags = DocComment$getTagsByName$LDocComment$S(docComment, "see");
		if (seeTags.length > 0) {
			_ += "<ul class=\"see\">\n";
			for (i$0 in seeTags) {
				tag$0 = seeTags[i$0];
				_ += "<li>";
				_ += DocumentGenerator$_autoLink$LDocumentGenerator$S(this, tag$0.getDescription$()).replace(/\n$/, "");
				_ += "</li>\n";
			}
			_ += "</ul>\n";
		}
	}
	return _;
};


function DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, docComment) {
	var _;
	var seeTags;
	var i$0;
	var tag$0;
	_ = "";
	if (docComment != null) {
		if (docComment.getDescription$() !== "") {
			_ += "<div class=\"description\">\n";
			_ += docComment.getDescription$().replace(/\t/g, "  ").replace(/\n$/, "");
			_ += "\n";
			_ += "</div>\n";
		}
		seeTags = DocComment$getTagsByName$LDocComment$S(docComment, "see");
		if (seeTags.length > 0) {
			_ += "<ul class=\"see\">\n";
			for (i$0 in seeTags) {
				tag$0 = seeTags[i$0];
				_ += "<li>";
				_ += DocumentGenerator$_autoLink$LDocumentGenerator$S($this, tag$0.getDescription$()).replace(/\n$/, "");
				_ += "</li>\n";
			}
			_ += "</ul>\n";
		}
	}
	return _;
};

DocumentGenerator._descriptionToHTML$LDocumentGenerator$LDocComment$ = DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$;

DocumentGenerator.prototype._autoLink$S = function (str) {
	var $this = this;
	var uri;
	uri = /^https?:\/\/[A-Za-z0-9\-\._~:\/?#\[\]@!$&'()*+,;=]+/g;
	return str.replace(uri, (function (matched) {
		return Util$format$SAS('<a href="%1">%1</a>', [ matched ]);
	}));
};


function DocumentGenerator$_autoLink$LDocumentGenerator$S($this, str) {
	var uri;
	uri = /^https?:\/\/[A-Za-z0-9\-\._~:\/?#\[\]@!$&'()*+,;=]+/g;
	return str.replace(uri, (function (matched) {
		return Util$format$SAS('<a href="%1">%1</a>', [ matched ]);
	}));
};

DocumentGenerator._autoLink$LDocumentGenerator$S = DocumentGenerator$_autoLink$LDocumentGenerator$S;

DocumentGenerator.prototype._argumentDescriptionToHTML$SLDocComment$ = function (name, docComment) {
	return (docComment != null ? DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S(this, docComment, name) : "");
};


function DocumentGenerator$_argumentDescriptionToHTML$LDocumentGenerator$SLDocComment$($this, name, docComment) {
	return (docComment != null ? DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S($this, docComment, name) : "");
};

DocumentGenerator._argumentDescriptionToHTML$LDocumentGenerator$SLDocComment$ = DocumentGenerator$_argumentDescriptionToHTML$LDocumentGenerator$SLDocComment$;

DocumentGenerator.prototype._formalTypeArgsToHTML$ALToken$ = function (typeArgs) {
	var $this = this;
	return (typeArgs.length === 0 ? "" : ".&lt;" + typeArgs.map((function (typeArg) {
		return DocumentGenerator$_escape$LDocumentGenerator$S($this, typeArg._value);
	})).join(", ") + "&gt;");
};


function DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$($this, typeArgs) {
	return (typeArgs.length === 0 ? "" : ".&lt;" + typeArgs.map((function (typeArg) {
		return DocumentGenerator$_escape$LDocumentGenerator$S($this, typeArg._value);
	})).join(", ") + "&gt;");
};

DocumentGenerator._formalTypeArgsToHTML$LDocumentGenerator$ALToken$ = DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$;

DocumentGenerator.prototype._typeToHTML$LParser$LType$ = function (parser, type) {
	var $this = this;
	var classDef;
	if (type instanceof ObjectType) {
		classDef = type.getClassDef$();
		if (classDef != null) {
			return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$(this, parser, classDef);
		} else {
			if (type instanceof ParsedObjectType && type._typeArguments.length !== 0) {
				classDef = QualifiedName$getTemplateClass$LQualifiedName$LParser$(type._qualifiedName, parser);
				if (classDef != null) {
					return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$(this, parser, classDef) + ".&lt;" + type._typeArguments.map((function (type) {
						return DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
					})).join(", ") + "&gt;";
				}
			}
		}
	} else {
		if (type instanceof FunctionType) {
			return "function (" + type._argTypes.map((function (type) {
				return ":" + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
			})).join(", ") + ") : " + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$(this, parser, type._returnType);
		} else {
			if (type instanceof VariableLengthArgumentType) {
				return "..." + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$(this, parser, type._baseType);
			}
		}
	}
	return DocumentGenerator$_escape$LDocumentGenerator$S(this, type.toString());
};


function DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type) {
	var classDef;
	if (type instanceof ObjectType) {
		classDef = type.getClassDef$();
		if (classDef != null) {
			return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef);
		} else {
			if (type instanceof ParsedObjectType && type._typeArguments.length !== 0) {
				classDef = QualifiedName$getTemplateClass$LQualifiedName$LParser$(type._qualifiedName, parser);
				if (classDef != null) {
					return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef) + ".&lt;" + type._typeArguments.map((function (type) {
						return DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
					})).join(", ") + "&gt;";
				}
			}
		}
	} else {
		if (type instanceof FunctionType) {
			return "function (" + type._argTypes.map((function (type) {
				return ":" + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
			})).join(", ") + ") : " + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type._returnType);
		} else {
			if (type instanceof VariableLengthArgumentType) {
				return "..." + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type._baseType);
			}
		}
	}
	return DocumentGenerator$_escape$LDocumentGenerator$S($this, type.toString());
};

DocumentGenerator._typeToHTML$LDocumentGenerator$LParser$LType$ = DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$;

DocumentGenerator.prototype._classDefToHTML$LParser$LClassDefinition$ = function (parser, classDef) {
	var $this = this;
	var result;
	var determineParserOfClassDef;
	var parserOfClassDef;
	var _;
	if (classDef instanceof InstantiatedClassDefinition) {
		return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$(this, parser, classDef._templateClassDef) + ".&lt;" + classDef._typeArguments.map((function (type) {
			return DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
		})).join(", ") + "&gt;";
	}
	result = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$get$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$(this._classDefToHTMLCache, classDef);
	if (result != null) {
		return result;
	}
	function determineParserOfClassDef() {
		var parsers;
		var i;
		var templateClassDefs;
		var j;
		var classDefs;
		parsers = $this._compiler._parsers;
		for (i = 0; i < parsers.length; ++ i) {
			if (classDef instanceof TemplateClassDefinition) {
				templateClassDefs = parsers[i]._templateClassDefs;
				for (j = 0; j < templateClassDefs.length; ++ j) {
					templateClassDefs = templateClassDefs.concat(templateClassDefs[j]._templateInners);
				}
				if (templateClassDefs.indexOf(classDef) !== -1) {
					return parsers[i];
				}
			} else {
				classDefs = parsers[i]._classDefs;
				for (j = 0; j < classDefs.length; ++ j) {
					classDefs = classDefs.concat(classDefs[j]._inners);
				}
				if (classDefs.indexOf(classDef) !== -1) {
					return parsers[i];
				}
			}
		}
		throw new Error("could not determine the parser to which the class belongs:" + ClassDefinition$classFullName$LClassDefinition$(classDef));
	}
	parserOfClassDef = determineParserOfClassDef();
	if (! this._pathFilter(parserOfClassDef._filename)) {
		return DocumentGenerator$_escape$LDocumentGenerator$S(this, ClassDefinition$classFullName$LClassDefinition$(classDef));
	}
	_ = "";
	_ += "<a href=\"";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, parserOfClassDef._filename).replace(/\n$/, "");
	_ += ".html#class-";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "\">";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "</a>\n";
	_ = _.trim();
	TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$set$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$S(this._classDefToHTMLCache, classDef, _);
	return _;
};


function DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef) {
	var result;
	var determineParserOfClassDef;
	var parserOfClassDef;
	var _;
	if (classDef instanceof InstantiatedClassDefinition) {
		return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef._templateClassDef) + ".&lt;" + classDef._typeArguments.map((function (type) {
			return DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
		})).join(", ") + "&gt;";
	}
	result = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$get$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$($this._classDefToHTMLCache, classDef);
	if (result != null) {
		return result;
	}
	function determineParserOfClassDef() {
		var parsers;
		var i;
		var templateClassDefs;
		var j;
		var classDefs;
		parsers = $this._compiler._parsers;
		for (i = 0; i < parsers.length; ++ i) {
			if (classDef instanceof TemplateClassDefinition) {
				templateClassDefs = parsers[i]._templateClassDefs;
				for (j = 0; j < templateClassDefs.length; ++ j) {
					templateClassDefs = templateClassDefs.concat(templateClassDefs[j]._templateInners);
				}
				if (templateClassDefs.indexOf(classDef) !== -1) {
					return parsers[i];
				}
			} else {
				classDefs = parsers[i]._classDefs;
				for (j = 0; j < classDefs.length; ++ j) {
					classDefs = classDefs.concat(classDefs[j]._inners);
				}
				if (classDefs.indexOf(classDef) !== -1) {
					return parsers[i];
				}
			}
		}
		throw new Error("could not determine the parser to which the class belongs:" + ClassDefinition$classFullName$LClassDefinition$(classDef));
	}
	parserOfClassDef = determineParserOfClassDef();
	if (! $this._pathFilter(parserOfClassDef._filename)) {
		return DocumentGenerator$_escape$LDocumentGenerator$S($this, ClassDefinition$classFullName$LClassDefinition$(classDef));
	}
	_ = "";
	_ += "<a href=\"";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, parserOfClassDef._filename).replace(/\n$/, "");
	_ += ".html#class-";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "\">";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "</a>\n";
	_ = _.trim();
	TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$set$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$S($this._classDefToHTMLCache, classDef, _);
	return _;
};

DocumentGenerator._classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$ = DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$;

DocumentGenerator.prototype._flagsToHTML$N = function (flags) {
	var strs;
	strs = [];
	if ((flags & 8) !== 0) {
		strs.push("static");
	}
	if ((flags & 1) !== 0) {
		strs.push("const");
	}
	if ((flags & 512) !== 0) {
		strs.push("__readonly__");
	}
	if ((flags & 2) !== 0) {
		strs.push("abstract");
	}
	if ((flags & 4) !== 0) {
		strs.push("final");
	}
	if ((flags & 32) !== 0) {
		strs.push("override");
	}
	if ((flags & 1024) !== 0) {
		strs.push("inline");
	}
	if ((flags & 16) !== 0) {
		strs.push("native");
	}
	if ((flags & 16384) !== 0) {
		strs.push("__export__");
	}
	return strs.join(" ");
};


function DocumentGenerator$_flagsToHTML$LDocumentGenerator$N($this, flags) {
	var strs;
	strs = [];
	if ((flags & 8) !== 0) {
		strs.push("static");
	}
	if ((flags & 1) !== 0) {
		strs.push("const");
	}
	if ((flags & 512) !== 0) {
		strs.push("__readonly__");
	}
	if ((flags & 2) !== 0) {
		strs.push("abstract");
	}
	if ((flags & 4) !== 0) {
		strs.push("final");
	}
	if ((flags & 32) !== 0) {
		strs.push("override");
	}
	if ((flags & 1024) !== 0) {
		strs.push("inline");
	}
	if ((flags & 16) !== 0) {
		strs.push("native");
	}
	if ((flags & 16384) !== 0) {
		strs.push("__export__");
	}
	return strs.join(" ");
};

DocumentGenerator._flagsToHTML$LDocumentGenerator$N = DocumentGenerator$_flagsToHTML$LDocumentGenerator$N;

DocumentGenerator.prototype._escape$S = function (str) {
	var $this = this;
	return str.replace(/[<>&'"]/g, (function (ch) {
		return ({ "<": "&lt;", ">": "&gt;", "&": "&amp;", "'": "&#39;", "\"": "&quot;" })[ch];
	}));
};


function DocumentGenerator$_escape$LDocumentGenerator$S($this, str) {
	return str.replace(/[<>&'"]/g, (function (ch) {
		return ({ "<": "&lt;", ">": "&gt;", "&": "&amp;", "'": "&#39;", "\"": "&quot;" })[ch];
	}));
};

DocumentGenerator._escape$LDocumentGenerator$S = DocumentGenerator$_escape$LDocumentGenerator$S;

DocumentGenerator.prototype._hasPublicProperties$LClassDefinition$ = function (classDef) {
	var $this = this;
	return ! ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
		var _docComment$0;
		return (! (varDef._nameToken._value.charAt(0) === "_" || (_docComment$0 = varDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (varDef._flags & 32768) !== 0) ? false : true);
	}));
};


function DocumentGenerator$_hasPublicProperties$LDocumentGenerator$LClassDefinition$($this, classDef) {
	return ! ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
		var _docComment$0;
		return (! (varDef._nameToken._value.charAt(0) === "_" || (_docComment$0 = varDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (varDef._flags & 32768) !== 0) ? false : true);
	}));
};

DocumentGenerator._hasPublicProperties$LDocumentGenerator$LClassDefinition$ = DocumentGenerator$_hasPublicProperties$LDocumentGenerator$LClassDefinition$;

DocumentGenerator.prototype._hasPublicFunctions$LClassDefinition$ = function (classDef) {
	var $this = this;
	return ! ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
		var _value$0;
		var _docComment$0;
		return (funcDef instanceof InstantiatedMemberFunctionDefinition || (_value$0 = funcDef._nameToken._value) === "constructor" && (funcDef._flags & 8) === 0 || (_value$0.charAt(0) === "_" || (_docComment$0 = funcDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (funcDef._flags & 32768) !== 0) ? true : false);
	}));
};


function DocumentGenerator$_hasPublicFunctions$LDocumentGenerator$LClassDefinition$($this, classDef) {
	return ! ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
		var _value$0;
		var _docComment$0;
		return (funcDef instanceof InstantiatedMemberFunctionDefinition || (_value$0 = funcDef._nameToken._value) === "constructor" && (funcDef._flags & 8) === 0 || (_value$0.charAt(0) === "_" || (_docComment$0 = funcDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (funcDef._flags & 32768) !== 0) ? true : false);
	}));
};

DocumentGenerator._hasPublicFunctions$LDocumentGenerator$LClassDefinition$ = DocumentGenerator$_hasPublicFunctions$LDocumentGenerator$LClassDefinition$;

DocumentGenerator.prototype._argsHasDocComment$LMemberFunctionDefinition$ = function (funcDef) {
	var docComment;
	var args;
	var argIndex;
	var args$len$0;
	docComment = funcDef._docComment;
	if (docComment == null) {
		return false;
	}
	args = funcDef._args;
	for ((argIndex = 0, args$len$0 = args.length); argIndex < args$len$0; ++ argIndex) {
		if (DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S(this, docComment, args[argIndex]._name._value) !== "") {
			return true;
		}
	}
	return false;
};


function DocumentGenerator$_argsHasDocComment$LDocumentGenerator$LMemberFunctionDefinition$($this, funcDef) {
	var docComment;
	var args;
	var argIndex;
	var args$len$0;
	docComment = funcDef._docComment;
	if (docComment == null) {
		return false;
	}
	args = funcDef._args;
	for ((argIndex = 0, args$len$0 = args.length); argIndex < args$len$0; ++ argIndex) {
		if (DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S($this, docComment, args[argIndex]._name._value) !== "") {
			return true;
		}
	}
	return false;
};

DocumentGenerator._argsHasDocComment$LDocumentGenerator$LMemberFunctionDefinition$ = DocumentGenerator$_argsHasDocComment$LDocumentGenerator$LMemberFunctionDefinition$;

DocumentGenerator.prototype._getDescriptionOfNamedArgument$LDocComment$S = function (docComment, argName) {
	var params;
	var paramIndex;
	params = docComment._params;
	for (paramIndex = 0; paramIndex < params.length; ++ paramIndex) {
		if (params[paramIndex]._token._value === argName) {
			return params[paramIndex].getDescription$();
		}
	}
	return "";
};


function DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S($this, docComment, argName) {
	var params;
	var paramIndex;
	params = docComment._params;
	for (paramIndex = 0; paramIndex < params.length; ++ paramIndex) {
		if (params[paramIndex]._token._value === argName) {
			return params[paramIndex].getDescription$();
		}
	}
	return "";
};

DocumentGenerator._getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S = DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S;

DocumentGenerator.prototype._isConstructor$LMemberFunctionDefinition$ = function (funcDef) {
	return funcDef._nameToken._value === "constructor" && (funcDef._flags & 8) === 0;
};


function DocumentGenerator$_isConstructor$LDocumentGenerator$LMemberFunctionDefinition$($this, funcDef) {
	return funcDef._nameToken._value === "constructor" && (funcDef._flags & 8) === 0;
};

DocumentGenerator._isConstructor$LDocumentGenerator$LMemberFunctionDefinition$ = DocumentGenerator$_isConstructor$LDocumentGenerator$LMemberFunctionDefinition$;

DocumentGenerator.prototype._isPrivate$LClassDefinition$ = function (classDef) {
	var _docComment$0;
	return !! (classDef.className$().charAt(0) === "_" || (_docComment$0 = classDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private'));
};


function DocumentGenerator$_isPrivate$LDocumentGenerator$LClassDefinition$($this, classDef) {
	var _docComment$0;
	return !! (classDef.className$().charAt(0) === "_" || (_docComment$0 = classDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private'));
};

DocumentGenerator._isPrivate$LDocumentGenerator$LClassDefinition$ = DocumentGenerator$_isPrivate$LDocumentGenerator$LClassDefinition$;

DocumentGenerator.prototype._isPrivate$LMemberDefinition$ = function (memberDef) {
	var _docComment$0;
	return !! (memberDef._nameToken._value.charAt(0) === "_" || (_docComment$0 = memberDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (memberDef._flags & 32768) !== 0);
};


function DocumentGenerator$_isPrivate$LDocumentGenerator$LMemberDefinition$($this, memberDef) {
	var _docComment$0;
	return !! (memberDef._nameToken._value.charAt(0) === "_" || (_docComment$0 = memberDef._docComment) && DocComment$getTagByName$LDocComment$S(_docComment$0, 'private') || (memberDef._flags & 32768) !== 0);
};

DocumentGenerator._isPrivate$LDocumentGenerator$LMemberDefinition$ = DocumentGenerator$_isPrivate$LDocumentGenerator$LMemberDefinition$;

DocumentGenerator.prototype._name$S = function (name) {
	return "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S(this, name) + "</strong>";
};


function DocumentGenerator$_name$LDocumentGenerator$S($this, name) {
	return "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, name) + "</strong>";
};

DocumentGenerator._name$LDocumentGenerator$S = DocumentGenerator$_name$LDocumentGenerator$S;

function node() {
};

$__jsx_extend([node], Object);
function node$require$S(source) {
	var src;
	src = 'require(' + JSON.stringify(source) + ')';
	return eval(src);
};

node.require$S = node$require$S;

function _LinkTimeOptimizationCommand$x2EStash() {
	this.extendedBy = [];
};

$__jsx_extend([_LinkTimeOptimizationCommand$x2EStash], Stash);
_LinkTimeOptimizationCommand$x2EStash.prototype.clone$ = function () {
	throw new Error("not supported");
};


function _StripOptimizeCommand$x2E_Stash() {
	this.touched = false;
};

$__jsx_extend([_StripOptimizeCommand$x2E_Stash], Stash);
_StripOptimizeCommand$x2E_Stash.prototype.clone$ = function () {
	throw new Error("not supported");
};


function _DetermineCalleeCommand$x2EStash() {
	this.callingFuncDef = null;
};

function _DetermineCalleeCommand$x2EStash$0(that) {
	this.callingFuncDef = that.callingFuncDef;
};

$__jsx_extend([_DetermineCalleeCommand$x2EStash, _DetermineCalleeCommand$x2EStash$0], Stash);
_DetermineCalleeCommand$x2EStash.prototype.clone$ = function () {
	return new _DetermineCalleeCommand$x2EStash$0(this);
};


function _StaticizeOptimizeCommand$x2EStash() {
	this.altName = null;
};

function _StaticizeOptimizeCommand$x2EStash$0(that) {
	this.altName = that.altName;
};

$__jsx_extend([_StaticizeOptimizeCommand$x2EStash, _StaticizeOptimizeCommand$x2EStash$0], Stash);
_StaticizeOptimizeCommand$x2EStash.prototype.clone$ = function () {
	return new _StaticizeOptimizeCommand$x2EStash$0(this);
};


function _UnclassifyOptimizationCommand$x2EStash() {
	this.inliner = null;
};

function _UnclassifyOptimizationCommand$x2EStash$0(that) {
	this.inliner = that.inliner;
};

$__jsx_extend([_UnclassifyOptimizationCommand$x2EStash, _UnclassifyOptimizationCommand$x2EStash$0], Stash);
_UnclassifyOptimizationCommand$x2EStash.prototype.clone$ = function () {
	return new _UnclassifyOptimizationCommand$x2EStash$0(this);
};


function _FoldConstantCommand$x2EStash() {
	this.isOptimized = false;
};

function _FoldConstantCommand$x2EStash$0(that) {
	this.isOptimized = that.isOptimized;
};

$__jsx_extend([_FoldConstantCommand$x2EStash, _FoldConstantCommand$x2EStash$0], Stash);
_FoldConstantCommand$x2EStash.prototype.clone$ = function () {
	return new _FoldConstantCommand$x2EStash$0(this);
};


function _InlineOptimizeCommand$x2EStash() {
	this.isOptimized = false;
	this.isInlineable = null;
};

function _InlineOptimizeCommand$x2EStash$0(that) {
	this.isOptimized = that.isOptimized;
	this.isInlineable = that.isInlineable;
};

$__jsx_extend([_InlineOptimizeCommand$x2EStash, _InlineOptimizeCommand$x2EStash$0], Stash);
_InlineOptimizeCommand$x2EStash.prototype.clone$ = function () {
	return new _InlineOptimizeCommand$x2EStash$0(this);
};


function _UnboxOptimizeCommand$x2EStash() {
	this.canUnbox = null;
};

$__jsx_extend([_UnboxOptimizeCommand$x2EStash], Stash);
_UnboxOptimizeCommand$x2EStash.prototype.clone$ = function () {
	var tmp;
	tmp = new _UnboxOptimizeCommand$x2EStash();
	tmp.canUnbox = this.canUnbox;
	return tmp;
};


function _NoDebugCommand$x2EStash() {
	this.debugValue = true;
};

$__jsx_extend([_NoDebugCommand$x2EStash], Stash);
_NoDebugCommand$x2EStash.prototype.clone$ = function () {
	var tmp;
	tmp = new _NoDebugCommand$x2EStash();
	tmp.debugValue = this.debugValue;
	return tmp;
};


function _Util$x2EOutputNameStash(outputName) {
	this.outputName = outputName;
};

$__jsx_extend([_Util$x2EOutputNameStash], Stash);
_Util$x2EOutputNameStash.prototype.clone$ = function () {
	throw new Error("not supported");
};


function _Namer$x2E_TryStash(catchName) {
	this.catchName = catchName;
};

$__jsx_extend([_Namer$x2E_TryStash], Stash);
_Namer$x2E_TryStash.prototype.clone$ = function () {
	throw new Error("operation not supported");
};


function _Namer$x2E_CatchTargetStash(tryStmt) {
	this.tryStmt = tryStmt;
};

$__jsx_extend([_Namer$x2E_CatchTargetStash], Stash);
_Namer$x2E_CatchTargetStash.prototype.clone$ = function () {
	throw new Error("operation not supported");
};


function _Minifier$x2E_ClassStash() {
	this.staticVariableUseCount = {};
	this.staticVariableConversionTable = {};
};

$__jsx_extend([_Minifier$x2E_ClassStash], Stash);
_Minifier$x2E_ClassStash.prototype.clone$ = function () {
	throw new Error("operation not supported");
};


function _Minifier$x2E_ScopeStash() {
	this.usedGlobals = {};
	this.usedOuterLocals = [];
};

$__jsx_extend([_Minifier$x2E_ScopeStash], Stash);
_Minifier$x2E_ScopeStash.prototype.clone$ = function () {
	throw new Error("operation not supported");
};


function _Minifier$x2E_LocalStash() {
	this.useCount = 0;
	this.minifiedName = null;
};

$__jsx_extend([_Minifier$x2E_LocalStash], Stash);
_Minifier$x2E_LocalStash.prototype.clone$ = function () {
	throw new Error("operation not supported");
};


function _Minifier$x2E_MinifyingNamer() {
	this._emitter = null;
	this._catchLevel = -1;
	this._minifier = null;
};

$__jsx_extend([_Minifier$x2E_MinifyingNamer], _Namer);
_Minifier$x2E_MinifyingNamer.prototype.setup$L_Minifier$ = function (minifier) {
	this._minifier = minifier;
	_Namer$setup$L_Namer$LJavaScriptEmitter$(this, minifier._emitter);
	return this;
};


function _Minifier$x2E_MinifyingNamer$setup$L_Minifier$x2E_MinifyingNamer$L_Minifier$($this, minifier) {
	$this._minifier = minifier;
	_Namer$setup$L_Namer$LJavaScriptEmitter$($this, minifier._emitter);
	return $this;
};

_Minifier$x2E_MinifyingNamer.setup$L_Minifier$x2E_MinifyingNamer$L_Minifier$ = _Minifier$x2E_MinifyingNamer$setup$L_Minifier$x2E_MinifyingNamer$L_Minifier$;

_Minifier$x2E_MinifyingNamer.prototype._getMangler$ = function () {
	return this._minifier._emitter._mangler;
};


function _Minifier$x2E_MinifyingNamer$_getMangler$L_Minifier$x2E_MinifyingNamer$($this) {
	return $this._minifier._emitter._mangler;
};

_Minifier$x2E_MinifyingNamer._getMangler$L_Minifier$x2E_MinifyingNamer$ = _Minifier$x2E_MinifyingNamer$_getMangler$L_Minifier$x2E_MinifyingNamer$;

_Minifier$x2E_MinifyingNamer.prototype._isCounting$ = function () {
	return this._minifier._propertyConversionTable == null;
};


function _Minifier$x2E_MinifyingNamer$_isCounting$L_Minifier$x2E_MinifyingNamer$($this) {
	return $this._minifier._propertyConversionTable == null;
};

_Minifier$x2E_MinifyingNamer._isCounting$L_Minifier$x2E_MinifyingNamer$ = _Minifier$x2E_MinifyingNamer$_isCounting$L_Minifier$x2E_MinifyingNamer$;

_Minifier$x2E_MinifyingNamer.prototype.getNameOfProperty$LClassDefinition$S = function (classDef, name) {
	if (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, null, false) || Util$memberIsExported$LClassDefinition$SALType$B(classDef, name, null, false)) {
		return name;
	}
	if (this._minifier._propertyConversionTable == null) {
		_Minifier$_incr$HNS(this._minifier._propertyUseCount, name);
	} else {
		name = this._minifier._propertyConversionTable[name];
	}
	return name;
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfMethod$LClassDefinition$SALType$ = function (classDef, name, argTypes) {
	var mangledName;
	var this$0;
	if (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, false)) {
		return name;
	}
	this$0 = this._minifier._emitter._mangler;
	mangledName = name + _Mangler$mangleFunctionArguments$L_Mangler$ALType$(this$0, argTypes);
	if (this._minifier._propertyConversionTable == null) {
		_Minifier$_incr$HNS(this._minifier._propertyUseCount, mangledName);
	} else {
		mangledName = this._minifier._propertyConversionTable[mangledName];
	}
	return mangledName;
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfStaticVariable$LClassDefinition$S = function (classDef, name) {
	if (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, null, true) || Util$memberIsExported$LClassDefinition$SALType$B(classDef, name, null, true)) {
		return name;
	}
	if (this._minifier._propertyConversionTable == null) {
		_Minifier$_incr$HNS(_Minifier$_getClassStash$LClassDefinition$(classDef).staticVariableUseCount, name);
	} else {
		name = _Minifier$_getClassStash$LClassDefinition$(classDef).staticVariableConversionTable[name];
	}
	return name;
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfStaticFunction$LClassDefinition$SALType$ = function (classDef, name, argTypes) {
	var mangledName;
	if (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, true)) {
		return this.getNameOfClass$LClassDefinition$(classDef) + "." + name;
	}
	mangledName = _Util$0$getOutputClassName$LClassDefinition$(classDef) + "$" + (name + _Mangler$mangleFunctionArguments$L_Mangler$ALType$(this._minifier._emitter._mangler, argTypes));
	if (this._minifier._propertyConversionTable == null) {
		_Minifier$_incr$HNS(this._minifier._globalUseCount, mangledName);
	} else {
		mangledName = this._minifier._globalConversionTable[mangledName];
	}
	return mangledName;
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfConstructor$LClassDefinition$ALType$ = function (classDef, argTypes) {
	var name;
	var mangledName;
	var ctor$0;
	if ((classDef.flags$() & 16) !== 0) {
		name = _Util$0$getNameOfNativeConstructor$LClassDefinition$(classDef);
		if (this._minifier._propertyConversionTable == null) {
			_Minifier$_incr$HNS(this._minifier._globalUseCount, name);
		}
		return name;
	}
	ctor$0 = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, "constructor", argTypes, false);
	mangledName = _Util$0$getOutputConstructorName$LMemberFunctionDefinition$(ctor$0);
	if (this._minifier._propertyConversionTable == null) {
		_Minifier$_incr$HNS(this._minifier._globalUseCount, mangledName);
	} else {
		mangledName = this._minifier._globalConversionTable[mangledName];
	}
	return mangledName;
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfClass$LClassDefinition$ = function (classDef) {
	var name;
	var stash$0;
	stash$0 = classDef.getStash$S("emitter.outputname");
	name = stash$0.outputName;
	if (this._minifier._propertyConversionTable == null) {
		_Minifier$_incr$HNS(this._minifier._globalUseCount, name);
	}
	return ((classDef.flags$() & 272) === 0 && ! (this._minifier._propertyConversionTable == null) ? this._minifier._globalConversionTable[name] : name);
};


_Minifier$x2E_MinifyingNamer.prototype.enterScope$LLocalVariable$F$V$ = function (local, cb) {
	var $this = this;
	if (local == null) {
		cb();
	} else {
		if (this._minifier._propertyConversionTable == null) {
			_Minifier$_recordUsedIdentifiers$L_Minifier$LStashable$F$V$(this._minifier, local, (function () {
				$this._minifier._outerLocals.push(local);
				cb();
				$this._minifier._outerLocals.pop();
			}));
		} else {
			_Minifier$_buildConversionTable$L_Minifier$ALLocalVariable$L_Minifier$x2E_ScopeStash$(this._minifier, [ local ], _Minifier$_getScopeStash$LStashable$(local));
			cb();
		}
	}
};


_Minifier$x2E_MinifyingNamer.prototype.enterFunction$LMemberFunctionDefinition$F$V$ = function (funcDef, cb) {
	var $this = this;
	if (this._minifier._propertyConversionTable == null) {
		_Minifier$_recordUsedIdentifiers$L_Minifier$LStashable$F$V$(this._minifier, funcDef, (function () {
			var _minifier$0;
			(_minifier$0 = $this._minifier)._outerLocals = _minifier$0._outerLocals.concat(_Minifier$_getArgsAndLocals$LMemberFunctionDefinition$(funcDef));
			cb();
			$this._minifier._outerLocals.length -= funcDef._args.length + funcDef._locals.length;
		}));
	} else {
		_Minifier$_buildConversionTable$L_Minifier$ALLocalVariable$L_Minifier$x2E_ScopeStash$(this._minifier, _Minifier$_getArgsAndLocals$LMemberFunctionDefinition$(funcDef), _Minifier$_getScopeStash$LStashable$(funcDef));
		cb();
	}
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfLocalVariable$LLocalVariable$ = function (local) {
	var caught$0;
	var tryStmt$0$0;
	var this$0;
	if (local instanceof CaughtVariable) {
		caught$0 = local;
		tryStmt$0$0 = caught$0.getStash$S("namer").tryStmt;
		return tryStmt$0$0.getStash$S("namer").catchName;
	}
	if (this._minifier._propertyConversionTable == null) {
		++ _Minifier$_getLocalStash$LLocalVariable$(local).useCount;
		this$0 = local._name;
		return this$0._value;
	} else {
		return _Minifier$_getLocalStash$LLocalVariable$(local).minifiedName;
	}
};


function MemberFunctionDefinition$x2E_CloneStash() {
	this.newLocal = null;
	this.newFuncDef = null;
};

function MemberFunctionDefinition$x2E_CloneStash$0(that) {
	this.newLocal = that.newLocal;
	this.newFuncDef = that.newFuncDef;
};

$__jsx_extend([MemberFunctionDefinition$x2E_CloneStash, MemberFunctionDefinition$x2E_CloneStash$0], Stash);
MemberFunctionDefinition$x2E_CloneStash.prototype.clone$ = function () {
	return new MemberFunctionDefinition$x2E_CloneStash$0(this);
};


$__jsx_lazy_init(ScriptLoader, "seen", function () {
	return {};
});
ScriptLoader.optimizationLevel = 0;
var js = { global: function () { return this; }() };
$__jsx_lazy_init(dom, "window", function () {
	return js.global.window;
});
$__jsx_lazy_init(dom, "document", function () {
	return js.global.document;
});
Compiler.MODE_COMPILE = 0;
Compiler.MODE_PARSE = 1;
Compiler.MODE_COMPLETE = 2;
Compiler.MODE_DOC = 3;
_LinkTimeOptimizationCommand.IDENTIFIER = "lto";
_StripOptimizeCommand.IDENTIFIER = "strip";
_NoAssertCommand.IDENTIFIER = "no-assert";
_NoLogCommand.IDENTIFIER = "no-log";
_DetermineCalleeCommand.IDENTIFIER = "determine-callee";
_StaticizeOptimizeCommand.IDENTIFIER = "staticize";
_UnclassifyOptimizationCommand.IDENTIFIER = "unclassify";
_FoldConstantCommand.IDENTIFIER = "fold-const";
_FoldConstantCommand.LONG_STRING_LITERAL = 64;
_DeadCodeEliminationOptimizeCommand.IDENTIFIER = "dce";
_InlineOptimizeCommand.IDENTIFIER = "inline";
_InlineOptimizeCommand.INLINE_THRESHOLD = 30;
_ReturnIfOptimizeCommand.IDENTIFIER = "return-if";
_LCSEOptimizeCommand.IDENTIFIER = "lcse";
_UnboxOptimizeCommand.IDENTIFIER = "unbox";
_ArrayLengthOptimizeCommand.IDENTIFIER = "array-length";
_NoDebugCommand.IDENTIFIER = "no-debug";
_Util$0.OUTPUTNAME_IDENTIFIER = "emitter.outputname";
_Namer.IDENTIFIER = "namer";
_MinifiedNameGenerator._MINIFY_CHARS = "$_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
$__jsx_lazy_init(_MinifiedNameGenerator, "GLOBALS", function () {
	return "NaN Infinity undefined evalparseInt parseFloat isNaN isFinite decodeURI decodeURIComponent encodeURI encodeURIComponent Object Function Array String Boolean Number Date RegExp Error EvalError RangeError ReferenceError SyntaxError TypeError URIError Math".split(/\s+/);
});
_Minifier.CLASSSTASH_IDENTIFIER = "minifier.class";
_Minifier.SCOPESTASH_IDENTIFIER = "minifier.scope";
_Minifier.LOCALSTASH_IDENTIFIER = "minifier.local";
$__jsx_lazy_init(_UnaryExpressionEmitter, "_operatorPrecedence", function () {
	return {};
});
$__jsx_lazy_init(_PostfixExpressionEmitter, "_operatorPrecedence", function () {
	return {};
});
_InstanceofExpressionEmitter._operatorPrecedence = 0;
_PropertyExpressionEmitter._operatorPrecedence = 0;
_FunctionExpressionEmitter._operatorPrecedence = 0;
_AdditiveExpressionEmitter._operatorPrecedence = 0;
$__jsx_lazy_init(_AssignmentExpressionEmitter, "_operatorPrecedence", function () {
	return {};
});
$__jsx_lazy_init(_EqualityExpressionEmitter, "_operatorPrecedence", function () {
	return {};
});
_InExpressionEmitter._operatorPrecedence = 0;
$__jsx_lazy_init(_LogicalExpressionEmitter, "_operatorPrecedence", function () {
	return {};
});
$__jsx_lazy_init(_ShiftExpressionEmitter, "_operatorPrecedence", function () {
	return {};
});
$__jsx_lazy_init(_BinaryNumberExpressionEmitter, "_operatorPrecedence", function () {
	return {};
});
_ArrayExpressionEmitter._operatorPrecedence = 0;
_ConditionalExpressionEmitter._operatorPrecedence = 0;
_CallExpressionEmitter._operatorPrecedence = 0;
_SuperExpressionEmitter._operatorPrecedence = 0;
_NewExpressionEmitter._operatorPrecedence = 0;
_CommaExpressionEmitter._operatorPrecedence = 0;
$__jsx_lazy_init(Util, "_builtInContainer", function () {
	return Util$asSet$AS([ "Array", "Map", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array" ]);
});
$__jsx_lazy_init(Util, "_stringLiteralEncodingMap", function () {
	return ({ "\0": "\\0", "\r": "\\r", "\n": "\\n", "\t": "\\t", "\"": "\\\"", "\'": "\\\'", "\\": "\\\\" });
});
$__jsx_lazy_init(Util, "_ecma262reserved", function () {
	return Util$asSet$AS([ "break", "do", "instanceof", "typeof", "case", "else", "new", "var", "catch", "finally", "return", "void", "continue", "for", "switch", "while", "debugger", "function", "this", "with", "default", "if", "throw", "delete", "in", "try", "class", "enum", "extends", "super", "const", "export", "import", "implements", "let", "private", "public", "yield", "interface", "package", "protected", "static", "null", "true", "false" ]);
});
$__jsx_lazy_init(BrowserPlatform, "debug", function () {
	return dom.window.location.hash === "#debug";
});
JavaScriptEmitter.BOOTSTRAP_NONE = 0;
JavaScriptEmitter.BOOTSTRAP_EXECUTABLE = 1;
JavaScriptEmitter.BOOTSTRAP_TEST = 2;
JavaScriptEmitter._initialized = false;
LocalVariableStatuses.UNTYPED_RECURSIVE_FUNCTION = -1;
LocalVariableStatuses.UNSET = 0;
LocalVariableStatuses.ISSET = 1;
LocalVariableStatuses.MAYBESET = 2;
_Lexer.ident = " [a-zA-Z_] [a-zA-Z0-9_]* ";
_Lexer.doubleQuoted = ' "  [^"\\\\]* (?: \\\\. [^"\\\\]* )* " ';
_Lexer.singleQuoted = " '  [^'\\\\]* (?: \\\\. [^'\\\\]* )* ' ";
$__jsx_lazy_init(_Lexer, "stringLiteral", function () {
	return _Lexer$makeAlt$AS([ " '  [^'\\\\]* (?: \\\\. [^'\\\\]* )* ' ", ' "  [^"\\\\]* (?: \\\\. [^"\\\\]* )* " ' ]);
});
$__jsx_lazy_init(_Lexer, "regexpLiteral", function () {
	return ' "  [^"\\\\]* (?: \\\\. [^"\\\\]* )* " '.replace(/"/g, "/") + "[mgi]*";
});
_Lexer.decimalIntegerLiteral = "(?: 0 | [1-9][0-9]* )";
_Lexer.exponentPart = "(?: [eE] [+-]? [0-9]+ )";
$__jsx_lazy_init(_Lexer, "numberLiteral", function () {
	return _Lexer$makeAlt$AS([ "(?: (?: 0 | [1-9][0-9]* ) \\. [0-9]* (?: [eE] [+-]? [0-9]+ )? )", "(?: \\. [0-9]+ (?: [eE] [+-]? [0-9]+ )? )", "(?: (?: 0 | [1-9][0-9]* )(?: [eE] [+-]? [0-9]+ ) )", "NaN", "Infinity" ]) + "\\b";
});
$__jsx_lazy_init(_Lexer, "integerLiteral", function () {
	return _Lexer$makeAlt$AS([ "(?: 0 [xX] [0-9a-fA-F]+ )", "(?: 0 | [1-9][0-9]* )" ]) + "(?![\\.0-9eE])\\b";
});
$__jsx_lazy_init(_Lexer, "rxIdent", function () {
	return _Lexer$rx$S("^ [a-zA-Z_] [a-zA-Z0-9_]* ");
});
$__jsx_lazy_init(_Lexer, "rxStringLiteral", function () {
	return _Lexer$rx$S("^" + _Lexer.stringLiteral);
});
$__jsx_lazy_init(_Lexer, "rxNumberLiteral", function () {
	return _Lexer$rx$S("^" + _Lexer.numberLiteral);
});
$__jsx_lazy_init(_Lexer, "rxIntegerLiteral", function () {
	return _Lexer$rx$S("^" + _Lexer.integerLiteral);
});
$__jsx_lazy_init(_Lexer, "rxRegExpLiteral", function () {
	return _Lexer$rx$S("^" + _Lexer.regexpLiteral);
});
_Lexer.rxNewline = /(?:\r\n?|\n)/;
$__jsx_lazy_init(_Lexer, "keywords", function () {
	return Util$asSet$AS([ "null", "true", "false", "NaN", "Infinity", "break", "do", "instanceof", "typeof", "case", "else", "new", "var", "catch", "finally", "return", "void", "for", "switch", "while", "function", "this", "if", "throw", "in", "try", "class", "extends", "super", "import", "implements", "static", "__FILE__", "__LINE__", "undefined" ]);
});
$__jsx_lazy_init(_Lexer, "reserved", function () {
	return Util$asSet$AS([ "debugger", "with", "const", "export", "let", "private", "public", "yield", "protected", "extern", "native", "as", "operator" ]);
});
$__jsx_lazy_init(_Lexer, "builtInClasses", function () {
	return Util$asSet$AS([ "Array", "Boolean", "Date", "Function", "Map", "Math", "Number", "Object", "RegExp", "String", "JSON", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "JSX", "Transferable", "ArrayBuffer", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "DataView" ]);
});
ClassDefinition.IS_CONST = 1;
ClassDefinition.IS_ABSTRACT = 2;
ClassDefinition.IS_FINAL = 4;
ClassDefinition.IS_STATIC = 8;
ClassDefinition.IS_NATIVE = 16;
ClassDefinition.IS_OVERRIDE = 32;
ClassDefinition.IS_INTERFACE = 64;
ClassDefinition.IS_MIXIN = 128;
ClassDefinition.IS_FAKE = 256;
ClassDefinition.IS_READONLY = 512;
ClassDefinition.IS_INLINE = 1024;
ClassDefinition.IS_PURE = 2048;
ClassDefinition.IS_DELETE = 4096;
ClassDefinition.IS_GENERATOR = 8192;
ClassDefinition.IS_EXPORT = 16384;
ClassDefinition.IS_GENERATED = 32768;
ClassDefinition.GET_MEMBER_MODE_ALL = 0;
ClassDefinition.GET_MEMBER_MODE_CLASS_ONLY = 1;
ClassDefinition.GET_MEMBER_MODE_SUPER = 2;
ClassDefinition.GET_MEMBER_MODE_FUNCTION_WITH_BODY = 3;
MemberVariableDefinition.NOT_ANALYZED = 0;
MemberVariableDefinition.IS_ANALYZING = 1;
MemberVariableDefinition.ANALYZE_SUCEEDED = 2;
MemberVariableDefinition.ANALYZE_FAILED = 3;
$__jsx_lazy_init(Type, "voidType", function () {
	return new VoidType();
});
$__jsx_lazy_init(Type, "nullType", function () {
	return new NullType();
});
$__jsx_lazy_init(Type, "booleanType", function () {
	return new BooleanType();
});
$__jsx_lazy_init(Type, "integerType", function () {
	return new IntegerType();
});
$__jsx_lazy_init(Type, "numberType", function () {
	return new NumberType();
});
$__jsx_lazy_init(Type, "stringType", function () {
	return new StringType();
});
$__jsx_lazy_init(Type, "variantType", function () {
	return new VariantType();
});
BooleanType._classDef = null;
IntegerType._classDef = null;
NumberType._classDef = null;
StringType._classDef = null;
FunctionType._classDef = null;
$__jsx_lazy_init(_StatementTransformer, "_statementCountMap", function () {
	return {};
});
CodeTransformer.stopIterationType = null;
CodeTransformer.jsxGeneratorClassDef = null;
Meta.VERSION_STRING = "0.9.56";
Meta.VERSION_NUMBER = 0.009056;
Meta.LAST_COMMIT_HASH = "6acc52a3f509ed30c9e04715405d1181adc00070";
Meta.LAST_COMMIT_DATE = "2013-07-17 21:18:01 -0700";
Meta.IDENTIFIER = "0.9.56 (2013-07-17 21:18:01 -0700; 6acc52a3f509ed30c9e04715405d1181adc00070)";
SourceMapper.NODE_SOURCE_MAP_HEADER = "require('source-map-support').install();\n\n";
SourceMapper.WEB_SOURCE_MAP_HEADER = "";
$__jsx_lazy_init(node, "__dirname", function () {
	return eval("__dirname") + "";
});
$__jsx_lazy_init(node, "__filename", function () {
	return eval("__filename") + "";
});
$__jsx_lazy_init(node, "fs", function () {
	return node$require$S('fs');
});
$__jsx_lazy_init(node, "path", function () {
	return node$require$S('path');
});
$__jsx_lazy_init(node, "child_process", function () {
	return node$require$S('child_process');
});
$__jsx_lazy_init(node, "url", function () {
	return node$require$S('url');
});
$__jsx_lazy_init(node, "http", function () {
	return node$require$S('http');
});
$__jsx_lazy_init(node, "https", function () {
	return node$require$S('https');
});
$__jsx_lazy_init(node, "net", function () {
	return node$require$S('net');
});
$__jsx_lazy_init(node, "util", function () {
	return node$require$S('util');
});

var $__jsx_classMap = {
	"system:lib/built-in.jsx": {
		g_StopIteration: g_StopIteration,
		g_StopIteration$: g_StopIteration
	},
	"system:src/web/jsx-script-loader.jsx": {
		ScriptLoader: ScriptLoader,
		ScriptLoader$: ScriptLoader,
		_Main: _Main,
		_Main$: _Main
	},
	"system:lib/js/js/web.jsx": {
		dom: dom,
		dom$: dom,
		EventInit: EventInit,
		EventInit$: EventInit,
		CustomEventInit: CustomEventInit,
		CustomEventInit$: CustomEventInit,
		MutationObserverInit: MutationObserverInit,
		MutationObserverInit$: MutationObserverInit,
		UIEventInit: UIEventInit,
		UIEventInit$: UIEventInit,
		FocusEventInit: FocusEventInit,
		FocusEventInit$: FocusEventInit,
		MouseEventInit: MouseEventInit,
		MouseEventInit$: MouseEventInit,
		WheelEventInit: WheelEventInit,
		WheelEventInit$: WheelEventInit,
		KeyboardEventInit: KeyboardEventInit,
		KeyboardEventInit$: KeyboardEventInit,
		CompositionEventInit: CompositionEventInit,
		CompositionEventInit$: CompositionEventInit,
		ProgressEventInit: ProgressEventInit,
		ProgressEventInit$: ProgressEventInit,
		XMLHttpRequestOptions: XMLHttpRequestOptions,
		XMLHttpRequestOptions$: XMLHttpRequestOptions,
		TrackEventInit: TrackEventInit,
		TrackEventInit$: TrackEventInit,
		PopStateEventInit: PopStateEventInit,
		PopStateEventInit$: PopStateEventInit,
		HashChangeEventInit: HashChangeEventInit,
		HashChangeEventInit$: HashChangeEventInit,
		PageTransitionEventInit: PageTransitionEventInit,
		PageTransitionEventInit$: PageTransitionEventInit,
		DragEventInit: DragEventInit,
		DragEventInit$: DragEventInit,
		CloseEventInit: CloseEventInit,
		CloseEventInit$: CloseEventInit,
		StorageEventInit: StorageEventInit,
		StorageEventInit$: StorageEventInit,
		MessageEventInit: MessageEventInit,
		MessageEventInit$: MessageEventInit,
		ErrorEventInit: ErrorEventInit,
		ErrorEventInit$: ErrorEventInit,
		EventSourceInit: EventSourceInit,
		EventSourceInit$: EventSourceInit,
		IDBObjectStoreParameters: IDBObjectStoreParameters,
		IDBObjectStoreParameters$: IDBObjectStoreParameters,
		IDBIndexParameters: IDBIndexParameters,
		IDBIndexParameters$: IDBIndexParameters,
		IDBVersionChangeEventInit: IDBVersionChangeEventInit,
		IDBVersionChangeEventInit$: IDBVersionChangeEventInit,
		NotificationOptions: NotificationOptions,
		NotificationOptions$: NotificationOptions,
		RTCSessionDescriptionInit: RTCSessionDescriptionInit,
		RTCSessionDescriptionInit$: RTCSessionDescriptionInit,
		RTCIceCandidateInit: RTCIceCandidateInit,
		RTCIceCandidateInit$: RTCIceCandidateInit,
		RTCIceServer: RTCIceServer,
		RTCIceServer$: RTCIceServer,
		RTCConfiguration: RTCConfiguration,
		RTCConfiguration$: RTCConfiguration,
		DataChannelInit: DataChannelInit,
		DataChannelInit$: DataChannelInit,
		RTCPeerConnectionIceEventInit: RTCPeerConnectionIceEventInit,
		RTCPeerConnectionIceEventInit$: RTCPeerConnectionIceEventInit,
		MediaStreamEventInit: MediaStreamEventInit,
		MediaStreamEventInit$: MediaStreamEventInit,
		DataChannelEventInit: DataChannelEventInit,
		DataChannelEventInit$: DataChannelEventInit,
		MediaStreamConstraints: MediaStreamConstraints,
		MediaStreamConstraints$: MediaStreamConstraints,
		MediaTrackConstraints: MediaTrackConstraints,
		MediaTrackConstraints$: MediaTrackConstraints,
		HitRegionOptions: HitRegionOptions,
		HitRegionOptions$: HitRegionOptions,
		WebGLContextAttributes: WebGLContextAttributes,
		WebGLContextAttributes$: WebGLContextAttributes,
		WebGLContextEventInit: WebGLContextEventInit,
		WebGLContextEventInit$: WebGLContextEventInit,
		DeviceOrientationEventInit: DeviceOrientationEventInit,
		DeviceOrientationEventInit$: DeviceOrientationEventInit,
		DeviceMotionEventInit: DeviceMotionEventInit,
		DeviceMotionEventInit$: DeviceMotionEventInit
	},
	"system:src/compiler.jsx": {
		Compiler: Compiler,
		Compiler$LPlatform$: Compiler
	},
	"system:src/optimizer.jsx": {
		_Util: _Util,
		_Util$: _Util,
		Optimizer: Optimizer,
		Optimizer$: Optimizer,
		_OptimizeCommand: _OptimizeCommand,
		_OptimizeCommand$S: _OptimizeCommand,
		_FunctionOptimizeCommand: _FunctionOptimizeCommand,
		_FunctionOptimizeCommand$S: _FunctionOptimizeCommand,
		_LinkTimeOptimizationCommand: _LinkTimeOptimizationCommand,
		_LinkTimeOptimizationCommand$: _LinkTimeOptimizationCommand,
		_StripOptimizeCommand: _StripOptimizeCommand,
		_StripOptimizeCommand$: _StripOptimizeCommand,
		_NoAssertCommand: _NoAssertCommand,
		_NoAssertCommand$: _NoAssertCommand,
		_NoLogCommand: _NoLogCommand,
		_NoLogCommand$: _NoLogCommand,
		_DetermineCalleeCommand: _DetermineCalleeCommand,
		_DetermineCalleeCommand$: _DetermineCalleeCommand,
		_StaticizeOptimizeCommand: _StaticizeOptimizeCommand,
		_StaticizeOptimizeCommand$: _StaticizeOptimizeCommand,
		_UnclassifyOptimizationCommand: _UnclassifyOptimizationCommand,
		_UnclassifyOptimizationCommand$: _UnclassifyOptimizationCommand,
		_FoldConstantCommand: _FoldConstantCommand,
		_FoldConstantCommand$: _FoldConstantCommand,
		_DeadCodeEliminationOptimizeCommand: _DeadCodeEliminationOptimizeCommand,
		_DeadCodeEliminationOptimizeCommand$: _DeadCodeEliminationOptimizeCommand,
		_InlineOptimizeCommand: _InlineOptimizeCommand,
		_InlineOptimizeCommand$: _InlineOptimizeCommand,
		_ReturnIfOptimizeCommand: _ReturnIfOptimizeCommand,
		_ReturnIfOptimizeCommand$: _ReturnIfOptimizeCommand,
		_LCSECachedExpression: _LCSECachedExpression,
		_LCSECachedExpression$LExpression$F$LExpression$V$: _LCSECachedExpression,
		_LCSEOptimizeCommand: _LCSEOptimizeCommand,
		_LCSEOptimizeCommand$: _LCSEOptimizeCommand,
		_UnboxOptimizeCommand: _UnboxOptimizeCommand,
		_UnboxOptimizeCommand$: _UnboxOptimizeCommand,
		_ArrayLengthOptimizeCommand: _ArrayLengthOptimizeCommand,
		_ArrayLengthOptimizeCommand$: _ArrayLengthOptimizeCommand,
		_NoDebugCommand: _NoDebugCommand,
		_NoDebugCommand$: _NoDebugCommand,
		"_LinkTimeOptimizationCommand.Stash": _LinkTimeOptimizationCommand$x2EStash,
		"_LinkTimeOptimizationCommand.Stash$": _LinkTimeOptimizationCommand$x2EStash,
		"_StripOptimizeCommand._Stash": _StripOptimizeCommand$x2E_Stash,
		"_StripOptimizeCommand._Stash$": _StripOptimizeCommand$x2E_Stash,
		"_DetermineCalleeCommand.Stash": _DetermineCalleeCommand$x2EStash,
		"_DetermineCalleeCommand.Stash$": _DetermineCalleeCommand$x2EStash,
		"_DetermineCalleeCommand.Stash$L_DetermineCalleeCommand$x2EStash$": _DetermineCalleeCommand$x2EStash$0,
		"_StaticizeOptimizeCommand.Stash": _StaticizeOptimizeCommand$x2EStash,
		"_StaticizeOptimizeCommand.Stash$": _StaticizeOptimizeCommand$x2EStash,
		"_StaticizeOptimizeCommand.Stash$L_StaticizeOptimizeCommand$x2EStash$": _StaticizeOptimizeCommand$x2EStash$0,
		"_UnclassifyOptimizationCommand.Stash": _UnclassifyOptimizationCommand$x2EStash,
		"_UnclassifyOptimizationCommand.Stash$": _UnclassifyOptimizationCommand$x2EStash,
		"_UnclassifyOptimizationCommand.Stash$L_UnclassifyOptimizationCommand$x2EStash$": _UnclassifyOptimizationCommand$x2EStash$0,
		"_FoldConstantCommand.Stash": _FoldConstantCommand$x2EStash,
		"_FoldConstantCommand.Stash$": _FoldConstantCommand$x2EStash,
		"_FoldConstantCommand.Stash$L_FoldConstantCommand$x2EStash$": _FoldConstantCommand$x2EStash$0,
		"_InlineOptimizeCommand.Stash": _InlineOptimizeCommand$x2EStash,
		"_InlineOptimizeCommand.Stash$": _InlineOptimizeCommand$x2EStash,
		"_InlineOptimizeCommand.Stash$L_InlineOptimizeCommand$x2EStash$": _InlineOptimizeCommand$x2EStash$0,
		"_UnboxOptimizeCommand.Stash": _UnboxOptimizeCommand$x2EStash,
		"_UnboxOptimizeCommand.Stash$": _UnboxOptimizeCommand$x2EStash,
		"_NoDebugCommand.Stash": _NoDebugCommand$x2EStash,
		"_NoDebugCommand.Stash$": _NoDebugCommand$x2EStash
	},
	"system:src/jsemitter.jsx": {
		_Util: _Util$0,
		_Util$: _Util$0,
		_Mangler: _Mangler,
		_Mangler$: _Mangler,
		_Namer: _Namer,
		_Namer$: _Namer,
		_MinifiedNameGenerator: _MinifiedNameGenerator,
		_MinifiedNameGenerator$AS: _MinifiedNameGenerator,
		_Minifier: _Minifier,
		_Minifier$LJavaScriptEmitter$ALClassDefinition$: _Minifier,
		_StatementEmitter: _StatementEmitter,
		_StatementEmitter$LJavaScriptEmitter$: _StatementEmitter,
		_ConstructorInvocationStatementEmitter: _ConstructorInvocationStatementEmitter,
		_ConstructorInvocationStatementEmitter$LJavaScriptEmitter$LConstructorInvocationStatement$: _ConstructorInvocationStatementEmitter,
		_ExpressionStatementEmitter: _ExpressionStatementEmitter,
		_ExpressionStatementEmitter$LJavaScriptEmitter$LExpressionStatement$: _ExpressionStatementEmitter,
		_FunctionStatementEmitter: _FunctionStatementEmitter,
		_FunctionStatementEmitter$LJavaScriptEmitter$LFunctionStatement$: _FunctionStatementEmitter,
		_ReturnStatementEmitter: _ReturnStatementEmitter,
		_ReturnStatementEmitter$LJavaScriptEmitter$LReturnStatement$: _ReturnStatementEmitter,
		_DeleteStatementEmitter: _DeleteStatementEmitter,
		_DeleteStatementEmitter$LJavaScriptEmitter$LDeleteStatement$: _DeleteStatementEmitter,
		_BreakStatementEmitter: _BreakStatementEmitter,
		_BreakStatementEmitter$LJavaScriptEmitter$LBreakStatement$: _BreakStatementEmitter,
		_ContinueStatementEmitter: _ContinueStatementEmitter,
		_ContinueStatementEmitter$LJavaScriptEmitter$LContinueStatement$: _ContinueStatementEmitter,
		_DoWhileStatementEmitter: _DoWhileStatementEmitter,
		_DoWhileStatementEmitter$LJavaScriptEmitter$LDoWhileStatement$: _DoWhileStatementEmitter,
		_ForInStatementEmitter: _ForInStatementEmitter,
		_ForInStatementEmitter$LJavaScriptEmitter$LForInStatement$: _ForInStatementEmitter,
		_ForStatementEmitter: _ForStatementEmitter,
		_ForStatementEmitter$LJavaScriptEmitter$LForStatement$: _ForStatementEmitter,
		_IfStatementEmitter: _IfStatementEmitter,
		_IfStatementEmitter$LJavaScriptEmitter$LIfStatement$: _IfStatementEmitter,
		_SwitchStatementEmitter: _SwitchStatementEmitter,
		_SwitchStatementEmitter$LJavaScriptEmitter$LSwitchStatement$: _SwitchStatementEmitter,
		_CaseStatementEmitter: _CaseStatementEmitter,
		_CaseStatementEmitter$LJavaScriptEmitter$LCaseStatement$: _CaseStatementEmitter,
		_DefaultStatementEmitter: _DefaultStatementEmitter,
		_DefaultStatementEmitter$LJavaScriptEmitter$LDefaultStatement$: _DefaultStatementEmitter,
		_WhileStatementEmitter: _WhileStatementEmitter,
		_WhileStatementEmitter$LJavaScriptEmitter$LWhileStatement$: _WhileStatementEmitter,
		_TryStatementEmitter: _TryStatementEmitter,
		_TryStatementEmitter$LJavaScriptEmitter$LTryStatement$: _TryStatementEmitter,
		_CatchStatementEmitter: _CatchStatementEmitter,
		_CatchStatementEmitter$LJavaScriptEmitter$LCatchStatement$: _CatchStatementEmitter,
		_ThrowStatementEmitter: _ThrowStatementEmitter,
		_ThrowStatementEmitter$LJavaScriptEmitter$LThrowStatement$: _ThrowStatementEmitter,
		_AssertStatementEmitter: _AssertStatementEmitter,
		_AssertStatementEmitter$LJavaScriptEmitter$LAssertStatement$: _AssertStatementEmitter,
		_LogStatementEmitter: _LogStatementEmitter,
		_LogStatementEmitter$LJavaScriptEmitter$LLogStatement$: _LogStatementEmitter,
		_DebuggerStatementEmitter: _DebuggerStatementEmitter,
		_DebuggerStatementEmitter$LJavaScriptEmitter$LDebuggerStatement$: _DebuggerStatementEmitter,
		_ExpressionEmitter: _ExpressionEmitter,
		_ExpressionEmitter$LJavaScriptEmitter$: _ExpressionEmitter,
		_LocalExpressionEmitter: _LocalExpressionEmitter,
		_LocalExpressionEmitter$LJavaScriptEmitter$LLocalExpression$: _LocalExpressionEmitter,
		_ClassExpressionEmitter: _ClassExpressionEmitter,
		_ClassExpressionEmitter$LJavaScriptEmitter$LClassExpression$: _ClassExpressionEmitter,
		_NullExpressionEmitter: _NullExpressionEmitter,
		_NullExpressionEmitter$LJavaScriptEmitter$LNullExpression$: _NullExpressionEmitter,
		_BooleanLiteralExpressionEmitter: _BooleanLiteralExpressionEmitter,
		_BooleanLiteralExpressionEmitter$LJavaScriptEmitter$LBooleanLiteralExpression$: _BooleanLiteralExpressionEmitter,
		_IntegerLiteralExpressionEmitter: _IntegerLiteralExpressionEmitter,
		_IntegerLiteralExpressionEmitter$LJavaScriptEmitter$LIntegerLiteralExpression$: _IntegerLiteralExpressionEmitter,
		_NumberLiteralExpressionEmitter: _NumberLiteralExpressionEmitter,
		_NumberLiteralExpressionEmitter$LJavaScriptEmitter$LNumberLiteralExpression$: _NumberLiteralExpressionEmitter,
		_StringLiteralExpressionEmitter: _StringLiteralExpressionEmitter,
		_StringLiteralExpressionEmitter$LJavaScriptEmitter$LStringLiteralExpression$: _StringLiteralExpressionEmitter,
		_RegExpLiteralExpressionEmitter: _RegExpLiteralExpressionEmitter,
		_RegExpLiteralExpressionEmitter$LJavaScriptEmitter$LRegExpLiteralExpression$: _RegExpLiteralExpressionEmitter,
		_ArrayLiteralExpressionEmitter: _ArrayLiteralExpressionEmitter,
		_ArrayLiteralExpressionEmitter$LJavaScriptEmitter$LArrayLiteralExpression$: _ArrayLiteralExpressionEmitter,
		_MapLiteralExpressionEmitter: _MapLiteralExpressionEmitter,
		_MapLiteralExpressionEmitter$LJavaScriptEmitter$LMapLiteralExpression$: _MapLiteralExpressionEmitter,
		_ThisExpressionEmitter: _ThisExpressionEmitter,
		_ThisExpressionEmitter$LJavaScriptEmitter$LThisExpression$: _ThisExpressionEmitter,
		_AsExpressionEmitter: _AsExpressionEmitter,
		_AsExpressionEmitter$LJavaScriptEmitter$LAsExpression$: _AsExpressionEmitter,
		_AsNoConvertExpressionEmitter: _AsNoConvertExpressionEmitter,
		_AsNoConvertExpressionEmitter$LJavaScriptEmitter$LAsNoConvertExpression$: _AsNoConvertExpressionEmitter,
		_OperatorExpressionEmitter: _OperatorExpressionEmitter,
		_OperatorExpressionEmitter$LJavaScriptEmitter$: _OperatorExpressionEmitter,
		_UnaryExpressionEmitter: _UnaryExpressionEmitter,
		_UnaryExpressionEmitter$LJavaScriptEmitter$LUnaryExpression$: _UnaryExpressionEmitter,
		_PostfixExpressionEmitter: _PostfixExpressionEmitter,
		_PostfixExpressionEmitter$LJavaScriptEmitter$LUnaryExpression$: _PostfixExpressionEmitter,
		_InstanceofExpressionEmitter: _InstanceofExpressionEmitter,
		_InstanceofExpressionEmitter$LJavaScriptEmitter$LInstanceofExpression$: _InstanceofExpressionEmitter,
		_PropertyExpressionEmitter: _PropertyExpressionEmitter,
		_PropertyExpressionEmitter$LJavaScriptEmitter$LPropertyExpression$: _PropertyExpressionEmitter,
		_FunctionExpressionEmitter: _FunctionExpressionEmitter,
		_FunctionExpressionEmitter$LJavaScriptEmitter$LFunctionExpression$: _FunctionExpressionEmitter,
		_AdditiveExpressionEmitter: _AdditiveExpressionEmitter,
		_AdditiveExpressionEmitter$LJavaScriptEmitter$LAdditiveExpression$: _AdditiveExpressionEmitter,
		_AssignmentExpressionEmitter: _AssignmentExpressionEmitter,
		_AssignmentExpressionEmitter$LJavaScriptEmitter$LAssignmentExpression$: _AssignmentExpressionEmitter,
		_EqualityExpressionEmitter: _EqualityExpressionEmitter,
		_EqualityExpressionEmitter$LJavaScriptEmitter$LEqualityExpression$: _EqualityExpressionEmitter,
		_InExpressionEmitter: _InExpressionEmitter,
		_InExpressionEmitter$LJavaScriptEmitter$LInExpression$: _InExpressionEmitter,
		_LogicalExpressionEmitter: _LogicalExpressionEmitter,
		_LogicalExpressionEmitter$LJavaScriptEmitter$LLogicalExpression$: _LogicalExpressionEmitter,
		_ShiftExpressionEmitter: _ShiftExpressionEmitter,
		_ShiftExpressionEmitter$LJavaScriptEmitter$LShiftExpression$: _ShiftExpressionEmitter,
		_BinaryNumberExpressionEmitter: _BinaryNumberExpressionEmitter,
		_BinaryNumberExpressionEmitter$LJavaScriptEmitter$LBinaryNumberExpression$: _BinaryNumberExpressionEmitter,
		_ArrayExpressionEmitter: _ArrayExpressionEmitter,
		_ArrayExpressionEmitter$LJavaScriptEmitter$LArrayExpression$: _ArrayExpressionEmitter,
		_ConditionalExpressionEmitter: _ConditionalExpressionEmitter,
		_ConditionalExpressionEmitter$LJavaScriptEmitter$LConditionalExpression$: _ConditionalExpressionEmitter,
		_CallExpressionEmitter: _CallExpressionEmitter,
		_CallExpressionEmitter$LJavaScriptEmitter$LCallExpression$: _CallExpressionEmitter,
		_SuperExpressionEmitter: _SuperExpressionEmitter,
		_SuperExpressionEmitter$LJavaScriptEmitter$LSuperExpression$: _SuperExpressionEmitter,
		_NewExpressionEmitter: _NewExpressionEmitter,
		_NewExpressionEmitter$LJavaScriptEmitter$LNewExpression$: _NewExpressionEmitter,
		_CommaExpressionEmitter: _CommaExpressionEmitter,
		_CommaExpressionEmitter$LJavaScriptEmitter$LCommaExpression$: _CommaExpressionEmitter,
		_BootstrapBuilder: _BootstrapBuilder,
		_BootstrapBuilder$: _BootstrapBuilder,
		_ExecutableBootstrapBuilder: _ExecutableBootstrapBuilder,
		_ExecutableBootstrapBuilder$: _ExecutableBootstrapBuilder,
		_TestBootstrapBuilder: _TestBootstrapBuilder,
		_TestBootstrapBuilder$: _TestBootstrapBuilder,
		_JSEmitterStash: _JSEmitterStash,
		_JSEmitterStash$: _JSEmitterStash,
		JavaScriptEmitter: JavaScriptEmitter,
		JavaScriptEmitter$LPlatform$: JavaScriptEmitter,
		"_Util.OutputNameStash": _Util$x2EOutputNameStash,
		"_Util.OutputNameStash$S": _Util$x2EOutputNameStash,
		"_Namer._TryStash": _Namer$x2E_TryStash,
		"_Namer._TryStash$S": _Namer$x2E_TryStash,
		"_Namer._CatchTargetStash": _Namer$x2E_CatchTargetStash,
		"_Namer._CatchTargetStash$LTryStatement$": _Namer$x2E_CatchTargetStash,
		"_Minifier._ClassStash": _Minifier$x2E_ClassStash,
		"_Minifier._ClassStash$": _Minifier$x2E_ClassStash,
		"_Minifier._ScopeStash": _Minifier$x2E_ScopeStash,
		"_Minifier._ScopeStash$": _Minifier$x2E_ScopeStash,
		"_Minifier._LocalStash": _Minifier$x2E_LocalStash,
		"_Minifier._LocalStash$": _Minifier$x2E_LocalStash,
		"_Minifier._MinifyingNamer": _Minifier$x2E_MinifyingNamer,
		"_Minifier._MinifyingNamer$": _Minifier$x2E_MinifyingNamer
	},
	"system:src/util.jsx": {
		Util: Util,
		Util$: Util
	},
	"system:src/platform.jsx": {
		Platform: Platform,
		Platform$: Platform
	},
	"system:src/web/browser-platform.jsx": {
		BrowserPlatform: BrowserPlatform,
		BrowserPlatform$: BrowserPlatform
	},
	"system:src/analysis.jsx": {
		InstantiationContext: InstantiationContext,
		InstantiationContext$ALCompileError$HLType$: InstantiationContext,
		TemplateInstantiationRequest: TemplateInstantiationRequest,
		TemplateInstantiationRequest$LToken$SALType$: TemplateInstantiationRequest,
		Block: Block,
		Block$: Block,
		BlockContext: BlockContext,
		BlockContext$LLocalVariableStatuses$LBlock$: BlockContext,
		AnalysisContext: AnalysisContext,
		AnalysisContext$ALCompileError$LParser$F$LParser$LClassDefinition$LClassDefinition$$: AnalysisContext,
		Stash: Stash,
		Stash$: Stash,
		Stashable: Stashable,
		Stashable$: Stashable,
		LocalVariable: LocalVariable,
		LocalVariable$LToken$LType$: LocalVariable,
		CaughtVariable: CaughtVariable,
		CaughtVariable$LToken$LType$: CaughtVariable,
		ArgumentDeclaration: ArgumentDeclaration,
		ArgumentDeclaration$LToken$LType$: ArgumentDeclaration,
		ArgumentDeclaration$LToken$LType$LExpression$: ArgumentDeclaration$0,
		LocalVariableStatuses: LocalVariableStatuses,
		LocalVariableStatuses$LMemberFunctionDefinition$LLocalVariableStatuses$: LocalVariableStatuses,
		LocalVariableStatuses$LLocalVariableStatuses$: LocalVariableStatuses$0,
		CompileIssue: CompileIssue,
		CompileIssue$LToken$S: CompileIssue,
		CompileIssue$SNNS: CompileIssue$0,
		CompileError: CompileError,
		CompileError$LToken$S: CompileError,
		CompileError$SNNS: CompileError$0,
		CompileWarning: CompileWarning,
		CompileWarning$LToken$S: CompileWarning,
		CompileWarning$SNNS: CompileWarning$0,
		DeprecatedWarning: DeprecatedWarning,
		DeprecatedWarning$LToken$S: DeprecatedWarning,
		DeprecatedWarning$SNNS: DeprecatedWarning$0,
		CompileNote: CompileNote,
		CompileNote$LToken$S: CompileNote,
		CompileNote$SNNS: CompileNote$0
	},
	"system:src/emitter.jsx": {
		Emitter: Emitter,
		Emitter$: Emitter
	},
	"system:src/parser.jsx": {
		Token: Token,
		Token$SBUSNN: Token,
		Token$S: Token$0,
		Token$SB: Token$1,
		Token$SBUS: Token$2,
		Token$SBUSN: Token$3,
		_Lexer: _Lexer,
		_Lexer$: _Lexer,
		Import: Import,
		Import$LParser$: Import,
		Import$LToken$LToken$ALToken$: Import$0,
		WildcardImport: WildcardImport,
		WildcardImport$LToken$LToken$ALToken$SS: WildcardImport,
		QualifiedName: QualifiedName,
		QualifiedName$LToken$: QualifiedName,
		QualifiedName$LToken$LImport$: QualifiedName$0,
		QualifiedName$LToken$LParsedObjectType$: QualifiedName$1,
		ParserState: ParserState,
		ParserState$NNLDocComment$NBNNNN: ParserState,
		ClassState: ClassState,
		ClassState$LClassState$LParsedObjectType$ALToken$LParsedObjectType$ALParsedObjectType$ALParsedObjectType$NALClassDefinition$ALTemplateClassDefinition$: ClassState,
		Scope: Scope,
		Scope$LScope$ALLocalVariable$LLocalVariable$ALArgumentDeclaration$ALStatement$ALMemberFunctionDefinition$B: Scope,
		Parser: Parser,
		Parser$LToken$SLCompletionRequest$: Parser
	},
	"system:src/classdef.jsx": {
		TemplateDefinition: TemplateDefinition,
		TemplateDefinition$: TemplateDefinition,
		ClassDefinition: ClassDefinition,
		ClassDefinition$LToken$SNLParsedObjectType$ALParsedObjectType$ALMemberDefinition$ALClassDefinition$ALTemplateClassDefinition$ALParsedObjectType$LDocComment$: ClassDefinition,
		MemberDefinition: MemberDefinition,
		MemberDefinition$LToken$LToken$NALMemberFunctionDefinition$LDocComment$: MemberDefinition,
		MemberVariableDefinition: MemberVariableDefinition,
		MemberVariableDefinition$LToken$LToken$NLType$LExpression$ALMemberFunctionDefinition$LDocComment$: MemberVariableDefinition,
		MemberFunctionDefinition: MemberFunctionDefinition,
		MemberFunctionDefinition$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$: MemberFunctionDefinition,
		InstantiatedMemberFunctionDefinition: InstantiatedMemberFunctionDefinition,
		InstantiatedMemberFunctionDefinition$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$: InstantiatedMemberFunctionDefinition,
		TemplateFunctionDefinition: TemplateFunctionDefinition,
		TemplateFunctionDefinition$LToken$LToken$NALToken$LType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$: TemplateFunctionDefinition,
		TemplateClassDefinition: TemplateClassDefinition,
		TemplateClassDefinition$LToken$SNALToken$LParsedObjectType$ALParsedObjectType$ALMemberDefinition$ALClassDefinition$ALTemplateClassDefinition$ALParsedObjectType$LDocComment$: TemplateClassDefinition,
		InstantiatedClassDefinition: InstantiatedClassDefinition,
		InstantiatedClassDefinition$LTemplateClassDefinition$ALType$LParsedObjectType$ALParsedObjectType$ALMemberDefinition$ALClassDefinition$ALTemplateClassDefinition$ALParsedObjectType$: InstantiatedClassDefinition,
		"MemberFunctionDefinition._CloneStash": MemberFunctionDefinition$x2E_CloneStash,
		"MemberFunctionDefinition._CloneStash$": MemberFunctionDefinition$x2E_CloneStash,
		"MemberFunctionDefinition._CloneStash$LMemberFunctionDefinition$x2E_CloneStash$": MemberFunctionDefinition$x2E_CloneStash$0
	},
	"system:src/type.jsx": {
		Type: Type,
		Type$: Type,
		VoidType: VoidType,
		VoidType$: VoidType,
		NullType: NullType,
		NullType$: NullType,
		PrimitiveType: PrimitiveType,
		PrimitiveType$: PrimitiveType,
		BooleanType: BooleanType,
		BooleanType$: BooleanType,
		IntegerType: IntegerType,
		IntegerType$: IntegerType,
		NumberType: NumberType,
		NumberType$: NumberType,
		StringType: StringType,
		StringType$: StringType,
		VariantType: VariantType,
		VariantType$: VariantType,
		NullableType: NullableType,
		NullableType$LType$: NullableType,
		VariableLengthArgumentType: VariableLengthArgumentType,
		VariableLengthArgumentType$LType$: VariableLengthArgumentType,
		ObjectType: ObjectType,
		ObjectType$LClassDefinition$: ObjectType,
		ParsedObjectType: ParsedObjectType,
		ParsedObjectType$LQualifiedName$ALType$: ParsedObjectType,
		FunctionType: FunctionType,
		FunctionType$: FunctionType,
		FunctionChoiceType: FunctionChoiceType,
		FunctionChoiceType$ALResolvedFunctionType$: FunctionChoiceType,
		ResolvedFunctionType: ResolvedFunctionType,
		ResolvedFunctionType$LToken$LType$ALType$B: ResolvedFunctionType,
		StaticFunctionType: StaticFunctionType,
		StaticFunctionType$LToken$LType$ALType$B: StaticFunctionType,
		MemberFunctionType: MemberFunctionType,
		MemberFunctionType$LToken$LType$LType$ALType$B: MemberFunctionType
	},
	"system:src/completion.jsx": {
		CompletionRequest: CompletionRequest,
		CompletionRequest$NN: CompletionRequest,
		CompletionCandidates: CompletionCandidates,
		CompletionCandidates$: CompletionCandidates,
		KeywordCompletionCandidate: KeywordCompletionCandidate,
		KeywordCompletionCandidate$S: KeywordCompletionCandidate,
		CompletionCandidatesOfTopLevel: CompletionCandidatesOfTopLevel,
		CompletionCandidatesOfTopLevel$LParser$F$LClassDefinition$B$: CompletionCandidatesOfTopLevel,
		_CompletionCandidatesWithLocal: _CompletionCandidatesWithLocal,
		_CompletionCandidatesWithLocal$LParser$: _CompletionCandidatesWithLocal,
		_CompletionCandidatesOfNamespace: _CompletionCandidatesOfNamespace,
		_CompletionCandidatesOfNamespace$LImport$F$LClassDefinition$B$: _CompletionCandidatesOfNamespace,
		_CompletionCandidatesOfProperty: _CompletionCandidatesOfProperty,
		_CompletionCandidatesOfProperty$LExpression$: _CompletionCandidatesOfProperty
	},
	"system:src/instruments.jsx": {
		_StatementTransformer: _StatementTransformer,
		_StatementTransformer$LCodeTransformer$S: _StatementTransformer,
		_ConstructorInvocationStatementTransformer: _ConstructorInvocationStatementTransformer,
		_ConstructorInvocationStatementTransformer$LCodeTransformer$LConstructorInvocationStatement$: _ConstructorInvocationStatementTransformer,
		_ExpressionStatementTransformer: _ExpressionStatementTransformer,
		_ExpressionStatementTransformer$LCodeTransformer$LExpressionStatement$: _ExpressionStatementTransformer,
		_FunctionStatementTransformer: _FunctionStatementTransformer,
		_FunctionStatementTransformer$LCodeTransformer$LFunctionStatement$: _FunctionStatementTransformer,
		_ReturnStatementTransformer: _ReturnStatementTransformer,
		_ReturnStatementTransformer$LCodeTransformer$LReturnStatement$: _ReturnStatementTransformer,
		_YieldStatementTransformer: _YieldStatementTransformer,
		_YieldStatementTransformer$LCodeTransformer$LYieldStatement$: _YieldStatementTransformer,
		_DeleteStatementTransformer: _DeleteStatementTransformer,
		_DeleteStatementTransformer$LCodeTransformer$LDeleteStatement$: _DeleteStatementTransformer,
		_BreakStatementTransformer: _BreakStatementTransformer,
		_BreakStatementTransformer$LCodeTransformer$LBreakStatement$: _BreakStatementTransformer,
		_ContinueStatementTransformer: _ContinueStatementTransformer,
		_ContinueStatementTransformer$LCodeTransformer$LContinueStatement$: _ContinueStatementTransformer,
		_LabellableStatementTransformer: _LabellableStatementTransformer,
		_LabellableStatementTransformer$LCodeTransformer$S: _LabellableStatementTransformer,
		_DoWhileStatementTransformer: _DoWhileStatementTransformer,
		_DoWhileStatementTransformer$LCodeTransformer$LDoWhileStatement$: _DoWhileStatementTransformer,
		_ForInStatementTransformer: _ForInStatementTransformer,
		_ForInStatementTransformer$LCodeTransformer$LForInStatement$: _ForInStatementTransformer,
		_ForStatementTransformer: _ForStatementTransformer,
		_ForStatementTransformer$LCodeTransformer$LForStatement$: _ForStatementTransformer,
		_IfStatementTransformer: _IfStatementTransformer,
		_IfStatementTransformer$LCodeTransformer$LIfStatement$: _IfStatementTransformer,
		_SwitchStatementTransformer: _SwitchStatementTransformer,
		_SwitchStatementTransformer$LCodeTransformer$LSwitchStatement$: _SwitchStatementTransformer,
		_CaseStatementTransformer: _CaseStatementTransformer,
		_CaseStatementTransformer$LCodeTransformer$LCaseStatement$: _CaseStatementTransformer,
		_DefaultStatementTransformer: _DefaultStatementTransformer,
		_DefaultStatementTransformer$LCodeTransformer$LDefaultStatement$: _DefaultStatementTransformer,
		_WhileStatementTransformer: _WhileStatementTransformer,
		_WhileStatementTransformer$LCodeTransformer$LWhileStatement$: _WhileStatementTransformer,
		_TryStatementTransformer: _TryStatementTransformer,
		_TryStatementTransformer$LCodeTransformer$LTryStatement$: _TryStatementTransformer,
		_CatchStatementTransformer: _CatchStatementTransformer,
		_CatchStatementTransformer$LCodeTransformer$LCatchStatement$: _CatchStatementTransformer,
		_ThrowStatementTransformer: _ThrowStatementTransformer,
		_ThrowStatementTransformer$LCodeTransformer$LThrowStatement$: _ThrowStatementTransformer,
		_AssertStatementTransformer: _AssertStatementTransformer,
		_AssertStatementTransformer$LCodeTransformer$LAssertStatement$: _AssertStatementTransformer,
		_LogStatementTransformer: _LogStatementTransformer,
		_LogStatementTransformer$LCodeTransformer$LLogStatement$: _LogStatementTransformer,
		_DebuggerStatementTransformer: _DebuggerStatementTransformer,
		_DebuggerStatementTransformer$LCodeTransformer$LDebuggerStatement$: _DebuggerStatementTransformer,
		CodeTransformer: CodeTransformer,
		CodeTransformer$: CodeTransformer
	},
	"system:src/expression.jsx": {
		Expression: Expression,
		Expression$LToken$: Expression,
		Expression$LExpression$: Expression$0,
		LeafExpression: LeafExpression,
		LeafExpression$LToken$: LeafExpression,
		OperatorExpression: OperatorExpression,
		OperatorExpression$LToken$: OperatorExpression,
		OperatorExpression$LExpression$: OperatorExpression$0,
		LocalExpression: LocalExpression,
		LocalExpression$LToken$LLocalVariable$: LocalExpression,
		ClassExpression: ClassExpression,
		ClassExpression$LToken$LType$: ClassExpression,
		NullExpression: NullExpression,
		NullExpression$LToken$LType$: NullExpression,
		BooleanLiteralExpression: BooleanLiteralExpression,
		BooleanLiteralExpression$LToken$: BooleanLiteralExpression,
		IntegerLiteralExpression: IntegerLiteralExpression,
		IntegerLiteralExpression$LToken$: IntegerLiteralExpression,
		NumberLiteralExpression: NumberLiteralExpression,
		NumberLiteralExpression$LToken$: NumberLiteralExpression,
		StringLiteralExpression: StringLiteralExpression,
		StringLiteralExpression$LToken$: StringLiteralExpression,
		RegExpLiteralExpression: RegExpLiteralExpression,
		RegExpLiteralExpression$LToken$: RegExpLiteralExpression,
		RegExpLiteralExpression$LToken$LType$: RegExpLiteralExpression$0,
		ArrayLiteralExpression: ArrayLiteralExpression,
		ArrayLiteralExpression$LToken$ALExpression$LType$: ArrayLiteralExpression,
		MapLiteralElement: MapLiteralElement,
		MapLiteralElement$LToken$LExpression$: MapLiteralElement,
		MapLiteralExpression: MapLiteralExpression,
		MapLiteralExpression$LToken$ALMapLiteralElement$LType$: MapLiteralExpression,
		ThisExpression: ThisExpression,
		ThisExpression$LToken$LClassDefinition$: ThisExpression,
		FunctionExpression: FunctionExpression,
		FunctionExpression$LToken$LMemberFunctionDefinition$: FunctionExpression,
		UnaryExpression: UnaryExpression,
		UnaryExpression$LToken$LExpression$: UnaryExpression,
		BitwiseNotExpression: BitwiseNotExpression,
		BitwiseNotExpression$LToken$LExpression$: BitwiseNotExpression,
		InstanceofExpression: InstanceofExpression,
		InstanceofExpression$LToken$LExpression$LType$: InstanceofExpression,
		AsExpression: AsExpression,
		AsExpression$LToken$LExpression$LType$: AsExpression,
		AsNoConvertExpression: AsNoConvertExpression,
		AsNoConvertExpression$LToken$LExpression$LType$: AsNoConvertExpression,
		LogicalNotExpression: LogicalNotExpression,
		LogicalNotExpression$LToken$LExpression$: LogicalNotExpression,
		IncrementExpression: IncrementExpression,
		IncrementExpression$LToken$LExpression$: IncrementExpression,
		PostIncrementExpression: PostIncrementExpression,
		PostIncrementExpression$LToken$LExpression$: PostIncrementExpression,
		PreIncrementExpression: PreIncrementExpression,
		PreIncrementExpression$LToken$LExpression$: PreIncrementExpression,
		PropertyExpression: PropertyExpression,
		PropertyExpression$LToken$LExpression$LToken$ALType$: PropertyExpression,
		PropertyExpression$LToken$LExpression$LToken$ALType$LType$: PropertyExpression$0,
		TypeofExpression: TypeofExpression,
		TypeofExpression$LToken$LExpression$: TypeofExpression,
		SignExpression: SignExpression,
		SignExpression$LToken$LExpression$: SignExpression,
		BinaryExpression: BinaryExpression,
		BinaryExpression$LToken$LExpression$LExpression$: BinaryExpression,
		AdditiveExpression: AdditiveExpression,
		AdditiveExpression$LToken$LExpression$LExpression$: AdditiveExpression,
		ArrayExpression: ArrayExpression,
		ArrayExpression$LToken$LExpression$LExpression$: ArrayExpression,
		AssignmentExpression: AssignmentExpression,
		AssignmentExpression$LToken$LExpression$LExpression$: AssignmentExpression,
		BinaryNumberExpression: BinaryNumberExpression,
		BinaryNumberExpression$LToken$LExpression$LExpression$: BinaryNumberExpression,
		EqualityExpression: EqualityExpression,
		EqualityExpression$LToken$LExpression$LExpression$: EqualityExpression,
		InExpression: InExpression,
		InExpression$LToken$LExpression$LExpression$: InExpression,
		LogicalExpression: LogicalExpression,
		LogicalExpression$LToken$LExpression$LExpression$: LogicalExpression,
		ShiftExpression: ShiftExpression,
		ShiftExpression$LToken$LExpression$LExpression$: ShiftExpression,
		ConditionalExpression: ConditionalExpression,
		ConditionalExpression$LToken$LExpression$LExpression$LExpression$: ConditionalExpression,
		ConditionalExpression$LToken$LExpression$LExpression$LExpression$LType$: ConditionalExpression$0,
		CallExpression: CallExpression,
		CallExpression$LToken$LExpression$ALExpression$: CallExpression,
		CallExpression$LCallExpression$: CallExpression$0,
		SuperExpression: SuperExpression,
		SuperExpression$LToken$LToken$ALExpression$: SuperExpression,
		SuperExpression$LSuperExpression$: SuperExpression$0,
		NewExpression: NewExpression,
		NewExpression$LToken$LType$ALExpression$: NewExpression,
		NewExpression$LNewExpression$: NewExpression$0,
		CommaExpression: CommaExpression,
		CommaExpression$LToken$LExpression$LExpression$: CommaExpression
	},
	"system:src/statement.jsx": {
		Statement: Statement,
		Statement$: Statement,
		ConstructorInvocationStatement: ConstructorInvocationStatement,
		ConstructorInvocationStatement$LToken$LType$ALExpression$: ConstructorInvocationStatement,
		ConstructorInvocationStatement$LToken$LType$ALExpression$LFunctionType$: ConstructorInvocationStatement$0,
		UnaryExpressionStatement: UnaryExpressionStatement,
		UnaryExpressionStatement$LExpression$: UnaryExpressionStatement,
		ExpressionStatement: ExpressionStatement,
		ExpressionStatement$LExpression$: ExpressionStatement,
		FunctionStatement: FunctionStatement,
		FunctionStatement$LToken$LMemberFunctionDefinition$: FunctionStatement,
		ReturnStatement: ReturnStatement,
		ReturnStatement$LToken$LExpression$: ReturnStatement,
		YieldStatement: YieldStatement,
		YieldStatement$LToken$LExpression$: YieldStatement,
		DeleteStatement: DeleteStatement,
		DeleteStatement$LToken$LExpression$: DeleteStatement,
		JumpStatement: JumpStatement,
		JumpStatement$LToken$LToken$: JumpStatement,
		BreakStatement: BreakStatement,
		BreakStatement$LToken$LToken$: BreakStatement,
		ContinueStatement: ContinueStatement,
		ContinueStatement$LToken$LToken$: ContinueStatement,
		LabellableStatement: LabellableStatement,
		LabellableStatement$LToken$LToken$: LabellableStatement,
		ContinuableStatement: ContinuableStatement,
		ContinuableStatement$LToken$LToken$ALStatement$: ContinuableStatement,
		DoWhileStatement: DoWhileStatement,
		DoWhileStatement$LToken$LToken$LExpression$ALStatement$: DoWhileStatement,
		ForInStatement: ForInStatement,
		ForInStatement$LToken$LToken$LExpression$LExpression$ALStatement$: ForInStatement,
		ForStatement: ForStatement,
		ForStatement$LToken$LToken$LExpression$LExpression$LExpression$ALStatement$: ForStatement,
		IfStatement: IfStatement,
		IfStatement$LToken$LExpression$ALStatement$ALStatement$: IfStatement,
		SwitchStatement: SwitchStatement,
		SwitchStatement$LToken$LToken$LExpression$ALStatement$: SwitchStatement,
		CaseStatement: CaseStatement,
		CaseStatement$LToken$LExpression$: CaseStatement,
		DefaultStatement: DefaultStatement,
		DefaultStatement$LToken$: DefaultStatement,
		WhileStatement: WhileStatement,
		WhileStatement$LToken$LToken$LExpression$ALStatement$: WhileStatement,
		TryStatement: TryStatement,
		TryStatement$LToken$ALStatement$ALCatchStatement$ALStatement$: TryStatement,
		CatchStatement: CatchStatement,
		CatchStatement$LToken$LCaughtVariable$ALStatement$: CatchStatement,
		ThrowStatement: ThrowStatement,
		ThrowStatement$LToken$LExpression$: ThrowStatement,
		InformationStatement: InformationStatement,
		InformationStatement$LToken$: InformationStatement,
		AssertStatement: AssertStatement,
		AssertStatement$LToken$LExpression$LExpression$: AssertStatement,
		LogStatement: LogStatement,
		LogStatement$LToken$ALExpression$: LogStatement,
		DebuggerStatement: DebuggerStatement,
		DebuggerStatement$LToken$: DebuggerStatement,
		GotoStatement: GotoStatement,
		GotoStatement$S: GotoStatement,
		LabelStatement: LabelStatement,
		LabelStatement$S: LabelStatement
	},
	"system:src/meta.jsx": {
		Meta: Meta,
		Meta$: Meta
	},
	"system:src/jssourcemap.jsx": {
		SourceMapper: SourceMapper,
		SourceMapper$SUSS: SourceMapper
	},
	"system:src/doc.jsx": {
		DocCommentNode: DocCommentNode,
		DocCommentNode$: DocCommentNode,
		DocCommentParameter: DocCommentParameter,
		DocCommentParameter$LToken$: DocCommentParameter,
		DocCommentTag: DocCommentTag,
		DocCommentTag$S: DocCommentTag,
		DocComment: DocComment,
		DocComment$: DocComment,
		DocumentGenerator: DocumentGenerator,
		DocumentGenerator$LCompiler$SS: DocumentGenerator
	},
	"system:lib/js/js/nodejs.jsx": {
		node: node,
		node$: node
	}
};


/**
 * launches _Main.main(:string[]):void invoked by jsx --run|--executable
 */
JSX.runMain = function (sourceFile, args) {
	var module = JSX.require(sourceFile);
	if (! module) {
		throw new ReferenceError("entry point module not found in " + sourceFile);
	}
	if (! module._Main) {
		throw new ReferenceError("entry point _Main not found in " + sourceFile);
	}
	if (! module._Main.main) {
		throw new ReferenceError("entry point _Main.main(:string[]):void not found in " + sourceFile);
	}
	module._Main.main(args);
};

/**
 * launches _Test#test*():void invoked by jsx --test
 */
JSX.runTests = function (sourceFile, tests) {
	var module = JSX.require(sourceFile);
	if (! module) return;

	var testClass = module._Test;

	if (!testClass) return; // skip if there's no test class

	if(tests.length === 0) {
		var p = testClass.prototype;
		for (var m in p) {
			if (p[m] instanceof Function && m.match(/^test\w*$/)) {
				tests.push(m);
			}
		}
	}

	var testCase = new testClass();

	if (testCase.beforeClass != null)
		testCase.beforeClass(tests);

	for (var i = 0; i < tests.length; ++i) {
		(function (method) {
			if (method in testCase) {
				testCase.run(method, function() { testCase[method](); });
			}
			else {
				throw new ReferenceError("No such test method: " + method);
			}
		}(tests[i]));
	}

	if (testCase.afterClass != null)
		testCase.afterClass();
};
/**
 * call a function on load/DOMContentLoaded
 */
function $__jsx_onload (event) {
	window.removeEventListener("load", $__jsx_onload);
	document.removeEventListener("DOMContentLoaded", $__jsx_onload);
	JSX.runMain("system:src/web/jsx-script-loader.jsx", []);
}

window.addEventListener("load", $__jsx_onload);
document.addEventListener("DOMContentLoaded", $__jsx_onload);

})(JSX);
